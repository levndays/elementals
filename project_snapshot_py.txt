Flutter Project Snapshot (Python Script)
Project Root: C:\Users\levndays\elementals_game
Snapshot created on: 2025-06-28T21:58:10.606667
================================================================================

=== FILE: create_snapshot.py ===
--------------------------------------------------
[Content Omitted - Generated/Tooling File]

--------------------------------------------------
=== END OF FILE: create_snapshot.py ===


=== FILE: editor.html ===
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elementals - Level Editor</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:,">
</head>
<body>
    <canvas id="game-canvas"></canvas>
    
    <div id="editor-ui">
        <div id="editor-topbar">
            <button id="editor-load-btn" title="Load Level from .json file">Load</button>
            <input type="file" id="editor-file-input" accept=".json" style="display: none;">
            <button id="editor-save-btn" title="Save Level to .json file">Save</button>
            <div class="separator"></div>
            <button id="editor-mode-translate" class="active" title="Translate Mode (T)">Translate</button>
            <button id="editor-mode-rotate" title="Rotate Mode (R)">Rotate</button>
            <button id="editor-mode-scale" title="Scale Mode (S)">Scale</button>
        </div>

        <div id="editor-main-panel" class="editor-panel">
            <div id="editor-tabs">
                <button class="editor-tab-btn active" data-tab="tab-scene">Scene</button>
                <button class="editor-tab-btn" data-tab="tab-outliner">Outliner</button>
                <button class="editor-tab-btn" data-tab="tab-create">Create</button>
            </div>
            <div id="editor-tab-content-container">
                <div id="tab-scene" class="editor-tab-content active">
                    <!-- Global Scene Settings -->
                    <h4>Global Settings</h4>
                    <label>Skybox Color</label>
                    <input type="color" id="skybox-color-input">
                    <hr>
                    <h4>Ambient Light</h4>
                    <label>Color</label>
                    <input type="color" id="ambient-color-input">
                    <label>Intensity</label>
                    <input type="range" id="ambient-intensity-input" min="0" max="5" step="0.1">
                </div>
                <div id="tab-outliner" class="editor-tab-content">
                    <div id="outliner-list">
                        <!-- Dynamically populated -->
                    </div>
                </div>
                <div id="tab-create" class="editor-tab-content">
                     <h4>Add to Scene</h4>
                     <button id="editor-add-box">Add Box</button>
                     <button id="editor-add-enemy">Add Enemy</button>
                     <button id="add-dirlight-btn">Add Directional Light</button>
                     <hr>
                     <h4>Scene Actions</h4>
                     <button id="editor-set-spawn">Set Initial Spawn to Camera</button>
                     <button id="editor-set-death-spawn">Set Death Spawn to Camera</button>
                </div>
            </div>
        </div>

        <div id="properties-panel" class="editor-panel" style="display: none;">
             <h3>Properties</h3>
             <div id="properties-content">
                <!-- Dynamically populated based on selection -->
             </div>
             <button id="editor-delete-btn" class="delete-button">Delete Selected</button>
        </div>
    </div>


    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
            "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>
    
    <script type="module" src="src/editor_main.js"></script>
</body>
</html>
--------------------------------------------------
=== END OF FILE: editor.html ===


=== FILE: index.html ===
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELEMENTALS</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:,">
</head>
<body>
    <!-- Menu System (wrapper) -->
    <div id="menu-system">
        <!-- Main Menu -->
        <div id="main-menu" class="menu-screen">
            <h1>ELEMENTALS</h1>
            <div class="menu-options">
                <button id="play-btn">Play</button>
                <button id="tutorial-btn">How to Play</button>
            </div>
        </div>
        <!-- Level Select -->
        <div id="level-select-menu" class="menu-screen" style="display: none;">
            <h2>Select Level</h2>
            <div id="level-list" class="menu-list">
                <!-- Dynamically populated -->
            </div>
            <button class="back-button" data-target="main-menu">Back</button>
        </div>
        <!-- Pause Menu -->
        <div id="pause-menu" class="menu-screen" style="display: none;">
            <h2>Paused</h2>
            <div class="menu-options">
                <button id="resume-btn">Resume</button>
                <button id="pause-quit-btn">Quit to Menu</button>
            </div>
        </div>
        <!-- Death Screen -->
        <div id="death-screen" class="menu-screen" style="display: none;">
            <h2>YOU DIED</h2>
            <p id="respawn-timer-text">Respawning in 5...</p>
            <div class="menu-options">
                <button id="death-quit-btn">Return to Menu</button>
            </div>
        </div>
    </div>


    <!-- In-Game UI & VFX -->
    <div id="screen-overlay"></div>
    <div id="vfx-dash-forward"></div>
    <div id="vfx-dash-sideways"></div>
    <div id="vfx-jump-wind"></div>
    <div id="vfx-ground-slam"></div>
    <div id="target-frame"></div>
    <div id="tutorial-text-container" style="display: none;">
        <p id="tutorial-text"></p>
    </div>
    <div id="crosshair"></div>

    <canvas id="game-canvas"></canvas>

    <!-- Game HUD -->
    <div id="game-hud">
        <div id="hud-bottom-left">
            <div id="health-bar-container" class="resource-bar-container">
                <div id="health-bar"></div>
                <span id="health-text" class="resource-text"></span>
            </div>
            <div id="ability-cooldowns">
                <div class="cooldown-container">
                    <div id="double-jump-bar" class="cooldown-bar"></div>
                    <span class="cooldown-label">JUMP</span>
                </div>
                <div class="cooldown-container">
                    <div id="dash-bar" class="cooldown-bar"></div>
                    <span class="cooldown-label">DASH</span>
                </div>
            </div>
        </div>
        <div id="hud-bottom-center">
            <div id="target-info">
                <span id="target-name"></span>
                <div id="target-health-bar-container" class="resource-bar-container">
                    <div id="target-health-bar"></div>
                    <span id="target-health-text" class="resource-text"></span>
                </div>
            </div>
            <div id="abilities-container">
                <div id="ability-0" class="ability-slot"><span class="ability-icon"></span><div class="ability-cooldown-overlay"></div></div>
                <div id="ability-1" class="ability-slot"><span class="ability-icon"></span><div class="ability-cooldown-overlay"></div></div>
                <div id="ability-2" class="ability-slot"><span class="ability-icon"></span><div class="ability-cooldown-overlay"></div></div>
                <div id="ability-3" class="ability-slot"><span class="ability-icon"></span><div class="ability-cooldown-overlay"></div></div>
            </div>
        </div>
        <div id="hud-bottom-right">
            <div id="energy-bar-container" class="resource-bar-container">
                <div id="energy-bar"></div>
                <span id="energy-text" class="resource-text"></span>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
            "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>
    
    <script type="module" src="src/main.js"></script>
</body>
</html>
--------------------------------------------------
=== END OF FILE: index.html ===


=== FILE: style.css ===
--------------------------------------------------
body {
    margin: 0;
    overflow: hidden;
    background-color: #000;
    color: white;
    font-family: 'Consolas', 'Courier New', monospace;
    cursor: default;
}
#game-canvas { display: block; }

/* --- VFX Overlays --- */
#screen-overlay {
    position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
    background-image: radial-gradient(circle at 50% 50%, transparent 50%, rgba(200, 0, 0, 0.9) 85%);
    pointer-events: none; z-index: 100; opacity: 0;
}
#screen-overlay.active {
    animation: damage-effect 0.3s ease-out forwards;
}
@keyframes damage-effect {
    0% { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(1.3); }
}

#vfx-dash-forward, #vfx-dash-sideways, #vfx-jump-wind {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 99; opacity: 0;
}

#vfx-dash-forward {
    background: radial-gradient(ellipse at center, transparent 30%, rgba(200, 220, 255, 0.3) 100%);
    mask-image: radial-gradient(circle at center, black 40%, transparent 60%);
    transform: scale(1.5);
}
#vfx-dash-forward.active {
    animation: dash-forward-effect 0.3s ease-out forwards;
}
@keyframes dash-forward-effect {
    from { opacity: 1; transform: scale(1); mask-size: 100%; }
    to { opacity: 0; transform: scale(1.5); mask-size: 300%;}
}

/* --- REWORKED: SIDE DASH --- */
#vfx-dash-sideways::before,
#vfx-dash-sideways::after {
    content: '';
    position: absolute;
    top: 50%;
    height: 2px;
    width: 40vw; /* Length of the streak */
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.9) 70%, transparent);
    opacity: 0;
    will-change: transform, opacity;
}
#vfx-dash-sideways::after {
    top: 52%;
    width: 25vw;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.5) 80%, transparent);
}
#vfx-dash-sideways.active.left-to-right::before,
#vfx-dash-sideways.active.left-to-right::after {
    animation: whoosh-lr 0.25s ease-out forwards;
}
#vfx-dash-sideways.active.left-to-right::after {
    animation-delay: 0.04s;
}
@keyframes whoosh-lr {
    0%   { transform: translateX(-60vw) scaleX(0.3); opacity: 0.5; }
    20%  { transform: translateX(-30vw) scaleX(1); opacity: 1; }
    100% { transform: translateX(60vw) scaleX(0.3); opacity: 0; }
}
#vfx-dash-sideways.active.right-to-left::before,
#vfx-dash-sideways.active.right-to-left::after {
    animation: whoosh-rl 0.25s ease-out forwards;
}
#vfx-dash-sideways.active.right-to-left::after {
    animation-delay: 0.04s;
}
@keyframes whoosh-rl {
    0%   { transform: translateX(60vw) scaleX(0.3); opacity: 0.5; }
    20%  { transform: translateX(30vw) scaleX(1); opacity: 1; }
    100% { transform: translateX(-60vw) scaleX(0.3); opacity: 0; }
}

/* --- REWORKED: JUMP --- */
#vfx-jump-wind {
    background: white;
    mask-image:
        linear-gradient(to bottom, transparent, black 10%, black 90%, transparent),
        linear-gradient(to bottom, transparent, black 20%, black 80%, transparent),
        linear-gradient(to bottom, transparent, black 30%, black 70%, transparent);
    mask-size: 2px 100vh, 4px 80vh, 2px 100vh;
    mask-repeat: no-repeat;
    mask-position: 45% -100vh, 50% -80vh, 55% -100vh;
    mask-composite: add;
}
#vfx-jump-wind.active {
    animation: jump-rush 0.35s ease-in forwards;
}
@keyframes jump-rush {
    from {
        opacity: 0.7;
        mask-position: 45% -100vh, 50% -80vh, 55% -100vh;
    }
    to {
        opacity: 0;
        mask-position: 45% 100vh, 50% 120vh, 55% 100vh;
    }
}


#vfx-ground-slam {
    position: absolute;
    bottom: 0; left: 50%;
    width: 200vw; height: 100vh;
    transform: translateX(-50%) scale(0);
    background: radial-gradient(ellipse at 50% 100%, rgba(220, 235, 255, 0.5) 0%, transparent 60%);
    pointer-events: none; z-index: 99; opacity: 0;
}
#vfx-ground-slam.active {
    animation: ground-slam-effect 0.4s ease-out forwards;
}
@keyframes ground-slam-effect {
    0% { transform: translateX(-50%) scale(0); opacity: 1; }
    100% { transform: translateX(-50%) scale(1); opacity: 0; }
}
/* --- End VFX --- */

#crosshair {
    position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
    background-color: rgba(255, 255, 255, 0.7); border-radius: 50%;
    transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
}
#target-frame {
    position: absolute; top: 50%; left: 50%; border: 2px solid #2ed573; border-radius: 50%;
    box-shadow: 0 0 10px #2ed573; pointer-events: none; z-index: 9; display: none;
    transform: translate(-50%, -50%); transition: width 0.1s linear, height 0.1s linear, border-color 0.2s linear;
}

/* --- Menu System --- */
#menu-system {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 200;
    pointer-events: none; /* Wrapper is transparent to events */
}
.menu-screen {
    position: absolute;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    backdrop-filter: blur(5px);
    transition: opacity 0.5s ease;
    pointer-events: auto; /* Screens are interactive */
}
.menu-screen h1, .menu-screen h2 {
    text-shadow: 0 0 20px #2ed573;
    margin: 0 0 40px 0;
}
.menu-screen h1 { font-size: 5rem; color: #2ed573; }
.menu-screen h2 { font-size: 4rem; color: #eee; }
#death-screen h2 { color: #ff4757; text-shadow: 0 0 15px #ff4757;}

.menu-options {
    display: flex; flex-direction: column; gap: 15px; margin-top: 20px;
}
.menu-screen button {
    padding: 12px 25px;
    font-size: 1.2rem;
    background-color: #333;
    color: #eee;
    border: 1px solid #555;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    font-family: inherit;
    min-width: 250px;
    transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
}
.menu-screen button:not(:disabled):hover {
    background-color: #2ed573;
    border-color: #2ed573;
    color: #000;
    transform: scale(1.05);
}
.menu-screen button:disabled {
    background-color: #222;
    color: #555;
    cursor: not-allowed;
}

/* Level Select Specifics */
#level-list {
    width: 90%; max-width: 400px;
    max-height: 50vh;
    overflow-y: auto;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 5px;
    padding: 10px;
    background-color: rgba(0,0,0,0.3);
    margin-bottom: 20px;
}
#level-list button { width: 100%; box-sizing: border-box; margin-bottom: 10px; }
.back-button { margin-top: 10px; background-color: #555 !important; }
.back-button:hover { background-color: #777 !important; color: #fff; }

#respawn-timer-text { font-size: 1.5rem; color: #ccc; }

/* Hide game elements when not playing */
body:not(.game-active) #game-hud,
body:not(.game-active) #crosshair,
body:not(.game-active) #target-frame,
body:not(.game-active) #tutorial-text-container {
    display: none !important;
}

/* --- TUTORIAL TEXT OVERLAY --- */
#tutorial-text-container {
    position: absolute;
    bottom: 25%;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    max-width: 600px;
    background-color: rgba(0, 0, 0, 0.75);
    border-left: 4px solid #2ed573;
    padding: 20px 25px;
    z-index: 50;
    pointer-events: none;
    transition: opacity 0.5s ease-out;
}
#tutorial-text {
    color: #eee; font-size: 1.2rem; text-align: center; margin: 0; line-height: 1.5;
}

/* HUD STYLES */
#hud-bottom-left, #hud-bottom-center, #hud-bottom-right {
    position: absolute; bottom: 20px; display: flex; flex-direction: column;
    align-items: center; gap: 8px; pointer-events: none; z-index: 10;
}
#hud-bottom-left { left: 20px; align-items: flex-start; }
#hud-bottom-center { left: 50%; transform: translateX(-50%); }
#hud-bottom-right { right: 20px; align-items: flex-end; }
#ability-cooldowns { display: flex; gap: 10px; width: 250px; }
.cooldown-container {
    flex: 1; height: 10px; background-color: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; padding: 1px; position: relative;
}
.cooldown-bar {
    width: 100%; height: 100%; background-color: #cccccc; border-radius: 2px; transition: width 0.1s linear;
}
.cooldown-bar.on-cooldown { background-color: #555555; }
.cooldown-label {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-size: 8px; font-weight: bold; color: white; text-shadow: 1px 1px 1px black;
}
.resource-bar-container {
    height: 20px; background-color: rgba(0, 0, 0, 0.5); border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 5px; padding: 2px; position: relative; width: 250px;
}
#health-bar {
    height: 100%; background-color: #ff4757; border-radius: 3px; transition: width 0.2s ease-out;
}
#energy-bar {
    height: 100%; background-color: #2ed573; border-radius: 3px; float: right;
    transition: width 0.2s ease-out, background-color 0.3s linear;
}
.resource-text {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-size: 12px; font-weight: bold; color: white; text-shadow: 1px 1px 2px black;
}
#energy-bar-container { text-align: right; }
#abilities-container {
    display: flex; gap: 8px; background-color: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(255, 255, 255, 0.2); padding: 8px; border-radius: 8px;
}
.ability-slot {
    width: 44px; height: 44px; background-color: rgba(0, 0, 0, 0.6);
    border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 5px; display: flex;
    align-items: center; justify-content: center; position: relative; overflow: hidden; transition: all 0.2s ease;
}
.ability-slot.selected { border-color: #2ed573; box-shadow: 0 0 10px #2ed573; }
.ability-icon { font-size: 18px; font-weight: bold; color: white; }
.ability-cooldown-overlay {
    position: absolute; bottom: 0; left: 0; width: 100%; height: 0;
    background-color: rgba(0, 0, 0, 0.7); transition: height 0.1s linear;
}
#target-info {
    padding: 8px 12px; background-color: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 5px; color: white; font-size: 14px; text-align: center; min-width: 200px;
    box-shadow: 0 0 8px rgba(0,255,0,0.5); display: flex; flex-direction: column; align-items: center;
    gap: 5px; margin-bottom: 5px; width: fit-content; display: none;
}
#target-name { font-weight: bold; color: #2ed573; }
#target-health-bar-container { width: 180px; height: 16px; margin: 0; }
#target-health-bar {
    height: 100%; background-color: #ff4757; border-radius: 3px;
    transition: width 0.2s ease-out, background-color 0.3s linear;
}
#target-health-text { font-size: 10px; }

/* --- EDITOR UI --- */
#editor-ui {
    position: absolute; top: 10px; right: 10px; width: 280px;
    display: flex; flex-direction: column; gap: 10px;
    z-index: 100; font-family: 'Consolas', 'Courier New', monospace;
    max-height: calc(100vh - 20px);
}
#editor-topbar {
    background-color: rgba(30, 30, 40, 0.85); border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px; padding: 5px; display: flex; gap: 5px; align-items: center;
}
#editor-topbar .separator { border-right: 1px solid #555; height: 20px; margin: 0 5px; }
.editor-panel {
    background-color: rgba(30, 30, 40, 0.85); border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px; padding: 10px; display: flex; flex-direction: column; gap: 8px;
    color: #eee;
}
#editor-main-panel { flex-shrink: 1; overflow: hidden; }
#properties-panel { flex-shrink: 0; }
#editor-ui h3, #editor-ui h4 {
    margin: 0 0 10px 0; padding-bottom: 5px; font-size: 14px; color: #2ed573;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
#editor-ui h4 { font-size: 13px; color: #ccc; margin-top: 5px; }
#editor-ui button {
    background-color: #333; border: 1px solid #555; color: #ddd; padding: 8px;
    border-radius: 4px; cursor: pointer; font-family: inherit; transition: background-color 0.2s, border-color 0.2s;
    text-align: center;
}
#editor-ui button:hover { background-color: #444; border-color: #777; }
#editor-ui button:active, #editor-ui button.active { background-color: #2ed573; border-color: #2ed573; color: #000; }
.delete-button { background-color: #8c2a2a !important; border-color: #a13b3b !important; color: #fff !important; }
.delete-button:hover { background-color: #a13b3b !important; }
#editor-ui label { display: block; font-size: 12px; margin-bottom: 4px; color: #aaa; }
#editor-ui input, #editor-ui hr { width: 100%; box-sizing: border-box; }
#editor-ui input[type="text"], #editor-ui input[type="number"] {
    background-color: #222; border: 1px solid #444; color: #eee;
    padding: 6px; border-radius: 3px; font-family: inherit;
}
#editor-ui hr { border: none; border-top: 1px solid #444; margin: 10px 0; }
.prop-group { display: flex; gap: 4px; }
.prop-group input { flex: 1; }

/* Tabs */
#editor-tabs { display: flex; border-bottom: 1px solid rgba(255, 255, 255, 0.2); }
.editor-tab-btn {
    flex: 1; border: none; border-radius: 4px 4px 0 0; padding: 8px; margin-bottom: -1px;
    background-color: transparent; border-bottom: 1px solid transparent;
}
.editor-tab-btn.active { background-color: rgba(50, 50, 60, 0.8); border: 1px solid rgba(255, 255, 255, 0.2); border-bottom: 1px solid rgba(50, 50, 60, 0.8); color: #2ed573;}
#editor-tab-content-container {
    padding-top: 10px;
    min-height: 150px;
    max-height: 40vh;
    overflow-y: auto;
}
.editor-tab-content { display: none; flex-direction: column; gap: 8px; }
.editor-tab-content.active { display: flex; }

/* Outliner */
#outliner-list { display: flex; flex-direction: column; gap: 2px; }
.outliner-item {
    padding: 6px 8px; background-color: rgba(255,255,255,0.05); border-radius: 3px;
    cursor: pointer; transition: background-color 0.15s; font-size: 12px;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.outliner-item:hover { background-color: rgba(255,255,255,0.15); }
.outliner-item.selected { background-color: #2ed573; color: black; font-weight: bold; }
--------------------------------------------------
=== END OF FILE: style.css ===


=== FILE: .github/workflows/static.yml ===
--------------------------------------------------
# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

--------------------------------------------------
=== END OF FILE: .github/workflows/static.yml ===


=== FILE: levels/level-mangled-grove.json ===
--------------------------------------------------
{
    "name": "Mangled Grove (Midnight)",
    "spawnPoint": { "x": 0, "y": 3, "z": 140 },
    "deathSpawnPoint": { "x": 0, "y": 3, "z": 140 },
    "settings": {
        "backgroundColor": "0x0A0F1A",
        "fogColor": "0x0A0F1A",
        "fogNear": 20,
        "fogFar": 180,
        "ambientLight": {
            "color": "0x404060",
            "intensity": 0.5
        },
        "directionalLights": [
            {
                "color": "0xE0E8FF",
                "intensity": 9.0,
                "position": { "x": -100, "y": 250, "z": 80 }
            }
        ]
    },
    "objects": [
        {
            "type": "Plane",
            "name": "Forest_Floor",
            "size": [400, 400],
            "position": { "x": 0, "y": 0, "z": 0 },
            "rotation": { "x": -90, "y": 0, "z": 0 },
            "material": { "color": "0x152B15", "roughness": 0.95 },
            "physics": { "mass": 0 },
            "editorSelectable": false
        },
        
        { "type": "Box", "name": "GiantRedwood_Trunk", "size": [15, 150, 15], "position": { "x": 0, "y": 75, "z": 0 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "GiantRedwood_Branch_Low", "size": [35, 4, 12], "position": { "x": 20, "y": 20, "z": 0 }, "rotation": { "y": -10 }, "material": { "color": "0x443322" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "GiantRedwood_Branch_Mid", "size": [12, 4, 40], "position": { "x": 0, "y": 50, "z": -22 }, "rotation": { "y": 5 }, "material": { "color": "0x443322" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "GiantRedwood_Branch_High", "size": [30, 5, 14], "position": { "x": -18, "y": 80, "z": 5 }, "rotation": { "y": 15 }, "material": { "color": "0x443322" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "GiantRedwood_Root1", "size": [8, 8, 25], "position": { "x": 10, "y": 4, "z": 8 }, "rotation": { "y": 45 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "GiantRedwood_Root2", "size": [6, 6, 20], "position": { "x": -8, "y": 3, "z": -10 }, "rotation": { "y": -30 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },

        { "type": "Box", "name": "Canyon_Wall_West", "size": [15, 80, 200], "position": { "x": -140, "y": 40, "z": 0 }, "material": { "color": "0x424242" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Canyon_Ledge1", "size": [15, 4, 25], "position": { "x": -120, "y": 15, "z": -60 }, "rotation": { "y": 5 }, "material": { "color": "0x555555" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Canyon_Ledge2", "size": [12, 4, 18], "position": { "x": -115, "y": 35, "z": 20 }, "rotation": { "y": -5 }, "material": { "color": "0x555555" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Canyon_Arch", "size": [50, 8, 8], "position": { "x": -95, "y": 50, "z": 50 }, "material": { "color": "0x555555" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Canyon_RockPillar", "size": [10, 60, 10], "position": { "x": -80, "y": 30, "z": -80 }, "material": { "color": "0x484848" }, "physics": { "mass": 0 } },

        { "type": "Box", "name": "Ruin_Platform1", "size": [20, 4, 25], "position": { "x": 90, "y": 25, "z": 40 }, "rotation": { "y": 15 }, "material": { "color": "0x455A64" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Ruin_Platform2", "size": [15, 4, 15], "position": { "x": 115, "y": 45, "z": 0 }, "rotation": { "y": -25 }, "material": { "color": "0x455A64" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Ruin_Platform3", "size": [12, 4, 20], "position": { "x": 80, "y": 65, "z": -50 }, "rotation": { "y": 5 }, "material": { "color": "0x455A64" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Ruin_Bridge", "size": [20, 2, 6], "position": { "x": 102, "y": 35, "z": 20 }, "material": { "color": "0x546E7A" }, "physics": { "mass": 0 } },

        { "type": "Box", "name": "Forest_Tree1", "size": [4, 45, 4], "position": { "x": 40, "y": 22.5, "z": 80 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Tree2", "size": [5, 60, 5], "position": { "x": -50, "y": 30, "z": 100 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Tree3", "size": [3, 35, 3], "position": { "x": -80, "y": 17.5, "z": -20 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Tree4", "size": [4, 50, 4], "position": { "x": 120, "y": 25, "z": -90 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Tree5", "size": [5, 55, 5], "position": { "x": 60, "y": 27.5, "z": -130 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Tree6", "size": [4, 40, 4], "position": { "x": -30, "y": 20, "z": -140 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },

        { "type": "Box", "name": "Forest_RockCluster_A1", "size": [15, 10, 12], "position": { "x": 50, "y": 5, "z": 110 }, "rotation": {"y": 30}, "material": { "color": "0x4E4E4E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_RockCluster_A2", "size": [10, 6, 8], "position": { "x": 58, "y": 3, "z": 115 }, "rotation": {"y": 30}, "material": { "color": "0x5A5A5A" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Rock_Large", "size": [25, 18, 20], "position": { "x": -60, "y": 9, "z": 50 }, "rotation": {"y": -50}, "material": { "color": "0x424242" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Rock_Med", "size": [10, 4, 8], "position": { "x": -65, "y": 2, "z": 65 }, "rotation": {"y": 20}, "material": { "color": "0x5A5A5A" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_FallenLog", "size": [20, 3, 3], "position": { "x": 25, "y": 1.5, "z": 50 }, "rotation": {"y": 70}, "material": { "color": "0x4E342E" }, "physics": { "mass": 0 } },

        { "type": "Box", "name": "Platform_Jump1", "size": [8, 2, 8], "position": { "x": 20, "y": 8, "z": 25 }, "material": { "color": "0x443322" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Platform_Jump2", "size": [6, 2, 6], "position": { "x": 28, "y": 14, "z": 15 }, "material": { "color": "0x443322" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Platform_Jump3", "size": [10, 2, 10], "position": { "x": 95, "y": 12, "z": 60 }, "material": { "color": "0x455A64" }, "physics": { "mass": 0 } }
    ],
    "enemies": [
        { "type": "Dummy", "position": { "x": 10, "y": 2, "z": 125 } },
        { "type": "Dummy", "position": { "x": -10, "y": 2, "z": 125 } },
        
        { "type": "Dummy", "position": { "x": 20, "y": 22, "z": 0 } },
        { "type": "Dummy", "position": { "x": 5, "y": 52, "z": -22 } },
        { "type": "Dummy", "position": { "x": -18, "y": 82.5, "z": 15 } },

        { "type": "Dummy", "position": { "x": -120, "y": 17, "z": -65 } },
        { "type": "Dummy", "position": { "x": -115, "y": 37, "z": 28 } },
        { "type": "Dummy", "position": { "x": -80, "y": 62, "z": -80 } },

        { "type": "Dummy", "position": { "x": 90, "y": 27, "z": 45 } },
        { "type": "Dummy", "position": { "x": 85, "y": 27, "z": 35 } },
        { "type": "Dummy", "position": { "x": 115, "y": 47, "z": 5 } },
        { "type": "Dummy", "position": { "x": 80, "y": 67, "z": -45 } },

        { "type": "Dummy", "position": { "x": 50, "y": 12, "z": 110 } },
        { "type": "Dummy", "position": { "x": -60, "y": 20, "z": 50 } },
        { "type": "Dummy", "position": { "x": -55, "y": 2, "z": 100 } },
        { "type": "Dummy", "position": { "x": 120, "y": 2, "z": -110 } },
        { "type": "Dummy", "position": { "x": 20, "y": 2, "z": -100 } },
        { "type": "Dummy", "position": { "x": -25, "y": 2, "z": -50 } }
    ]
}
--------------------------------------------------
=== END OF FILE: levels/level-mangled-grove.json ===


=== FILE: levels/level-tutorial.json ===
--------------------------------------------------
{
  "name": "Custom Level",
  "spawnPoint": {
    "x": -44.98801551832607,
    "y": 8.984053355471769,
    "z": -10.625467485890029
  },
  "deathSpawnPoint": {
    "x": -43.27678684780668,
    "y": 7.839747674467933,
    "z": -9.13641267191703
  },
  "settings": {
    "backgroundColor": "0x1d2938",
    "fogColor": "0x1d2938",
    "fogNear": 20,
    "fogFar": 150,
    "ambientLight": {
      "color": "0x607080",
      "intensity": 0.7
    },
    "directionalLights": [
      {
        "color": "0xffffff",
        "intensity": 1.5,
        "position": {
          "x": -80,
          "y": 100,
          "z": 50
        }
      }
    ]
  },
  "objects": [
    {
      "type": "Box",
      "name": "Platform_Start",
      "size": [
        15,
        2,
        15
      ],
      "position": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Platform_Jump_1",
      "size": [
        10,
        2,
        10
      ],
      "position": {
        "x": 0,
        "y": 0,
        "z": 20
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Platform_Jump_2",
      "size": [
        10,
        2,
        10
      ],
      "position": {
        "x": 15,
        "y": 3,
        "z": 20
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Platform_DoubleJump_Target",
      "size": [
        15,
        2,
        15
      ],
      "position": {
        "x": 15,
        "y": 10,
        "z": 40
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Platform_Dash_Start",
      "size": [
        15,
        2,
        15
      ],
      "position": {
        "x": 15,
        "y": 10,
        "z": 60
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Platform_Dash_End",
      "size": [
        15,
        2,
        15
      ],
      "position": {
        "x": 15,
        "y": 10,
        "z": 90
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Platform_Slam_Tower",
      "size": [
        5,
        25,
        5
      ],
      "position": {
        "x": 15,
        "y": 22.5,
        "z": 90
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Bridge_To_Arena",
      "size": [
        30,
        2,
        8
      ],
      "position": {
        "x": 40,
        "y": 10,
        "z": 90
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Arena_Floor",
      "size": [
        60,
        2,
        60
      ],
      "position": {
        "x": 85,
        "y": 10,
        "z": 90
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Arena_Wall_Back",
      "size": [
        60,
        15,
        2
      ],
      "position": {
        "x": 85,
        "y": 17.5,
        "z": 61
      },
      "material": {
        "color": "0x223344"
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Arena_Wall_Front",
      "size": [
        60,
        15,
        2
      ],
      "position": {
        "x": 85,
        "y": 17.5,
        "z": 119
      },
      "material": {
        "color": "0x223344"
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Arena_Wall_Left",
      "size": [
        2,
        15,
        60
      ],
      "position": {
        "x": 56,
        "y": 17.5,
        "z": 90
      },
      "material": {
        "color": "0x223344"
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Arena_Wall_Right",
      "size": [
        2,
        15,
        60
      ],
      "position": {
        "x": 114,
        "y": 17.5,
        "z": 90
      },
      "material": {
        "color": "0x223344"
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281",
      "size": [
        -14.337207994854166,
        -1.5326680171484088,
        12.768471033444994
      ],
      "position": {
        "x": -43.01285565350706,
        "y": 5.086083636995656,
        "z": -8.96661336105313
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy",
      "size": [
        -4.208012957269948,
        -1.5326680171484088,
        12.768471033444994
      ],
      "position": {
        "x": -44.04379244343043,
        "y": 5.066219354772365,
        "z": 3.4946403812872124
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -46.26813359798705,
        "y": 7.4800669261192,
        "z": 22.107000844728145
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -48.395409662170735,
        "y": 10.719786450366831,
        "z": 36.41924432447844
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -54.1932531582041,
        "y": 13.18059556107957,
        "z": 52.03503159851534
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -54.958576548032475,
        "y": 18.84840733318615,
        "z": 64.32780639821098
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -57.6867224841606,
        "y": 25.175146687548885,
        "z": 77.74885396702486
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -57.63703431691122,
        "y": 25.12654970639061,
        "z": 106.59536866908557
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -65.88732605570398,
        11.51789748887716
      ],
      "position": {
        "x": -65.2440753666263,
        "y": 31.422054024356967,
        "z": 139.4397373046035
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -7.11666436362174,
        -1.5326680171484088,
        21.664703872845354
      ],
      "position": {
        "x": -73.56319029136195,
        "y": 37.187714962965075,
        "z": 134.2421438129049
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -7.11666436362174,
        -1.5326680171484088,
        21.664703872845354
      ],
      "position": {
        "x": -64.24971574707698,
        "y": 28.892288912765864,
        "z": 132.61861510795148
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -7.11666436362174,
        -1.5326680171484088,
        21.664703872845354
      ],
      "position": {
        "x": -60.15226726030613,
        "y": 51.332828177813,
        "z": 148.97630285734766
      },
      "rotation": {
        "x": 25.663425860133525,
        "y": -90.55727509084672,
        "z": -0.2413529991993483
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -12.960599066159523,
        -1.1702203770092008,
        7.572954931487935
      ],
      "position": {
        "x": -59.34608228287116,
        "y": 60.33037788384331,
        "z": 138.2289013476706
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -44.02552743283555,
        -1.1702203770092008,
        7.572954931487935
      ],
      "position": {
        "x": -25.03575772836654,
        "y": 35.02651861542267,
        "z": 138.37481365113624
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    }
  ],
  "enemies": [
    {
      "type": "Dummy",
      "position": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "name": "Katana Target"
    },
    {
      "type": "Dummy",
      "position": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "name": "Fireball Target"
    },
    {
      "type": "Dummy",
      "position": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "name": "Fireflies Target"
    }
  ],
  "triggers": [
    {
      "name": "Welcome",
      "position": {
        "x": -41.75934763757055,
        "y": 5.7614447295826245,
        "z": -9.313608708592323
      },
      "size": [
        16,
        8,
        10.876547004065293
      ],
      "message": "Use your MOUSE to look and W, A, S, D to move.",
      "duration": 8,
      "color": "0x2ed573"
    },
    {
      "name": "Jump",
      "position": {
        "x": -44.13153928946884,
        "y": 9.672358004866954,
        "z": 8.012847526714085
      },
      "size": [
        4.9135478529606775,
        8,
        4
      ],
      "message": "Press SPACE to jump across the platforms.",
      "duration": 5,
      "color": "0x2ed573"
    },
    {
      "name": "DoubleJump",
      "position": {
        "x": -54.34750758720173,
        "y": 16.07210572584555,
        "z": 54.761976264200435
      },
      "size": [
        9.020993927863413,
        8,
        4
      ],
      "message": "This gap is too high. Press SPACE again in mid-air to Double Jump.",
      "duration": 8,
      "color": "0xffa502"
    },
    {
      "name": "DoubleJump_Cooldown",
      "position": {
        "x": -54.96415065519877,
        "y": 22.096436794868733,
        "z": 63.91251282277527
      },
      "size": [
        7.1143018362574075,
        6.015156160833573,
        4
      ],
      "message": "Notice the JUMP bar (bottom-left) goes on cooldown after a double jump.",
      "duration": 8,
      "color": "0xffa502"
    },
    {
      "name": "Dash",
      "position": {
        "x": -57.938917187698486,
        "y": 29.4656789976766,
        "z": 81.26106201212208
      },
      "size": [
        10.164616862428192,
        8,
        4
      ],
      "message": "Double-tap a movement key to Dash across the gap. The DASH bar shows its cooldown.",
      "duration": 8,
      "color": "0xffa502"
    },
    {
      "name": "Slam",
      "position": {
        "x": -57.60454343060415,
        "y": 28.17041333083598,
        "z": 107.49762430104798
      },
      "size": [
        8,
        7.231729781960025,
        8
      ],
      "message": "Climb this tower, then hold SHIFT in the air to Ground Slam onto the bridge.",
      "duration": 10,
      "color": "0xffa502"
    },
    {
      "name": "Combat_Intro",
      "position": {
        "x": 50,
        "y": 13,
        "z": 90
      },
      "size": [
        15,
        8,
        10
      ],
      "message": "Welcome to the combat arena. Destroy all the dummies to complete the tutorial.",
      "duration": 8,
      "color": "0x1e90ff"
    },
    {
      "name": "Melee_Intro",
      "position": {
        "x": 68,
        "y": 13,
        "z": 80
      },
      "size": [
        10,
        8,
        10
      ],
      "message": "LEFT CLICK to use your Katana. Get close to the dummy and strike.",
      "duration": 8,
      "color": "0xff4757"
    },
    {
      "name": "Ability_Intro",
      "position": {
        "x": 85,
        "y": 13,
        "z": 90
      },
      "size": [
        10,
        8,
        10
      ],
      "message": "RIGHT CLICK casts abilities. They cost ENERGY and have COOLDOWNS.",
      "duration": 8,
      "color": "0xff4757"
    },
    {
      "name": "Fireball_Intro",
      "position": {
        "x": 85,
        "y": 13,
        "z": 107
      },
      "size": [
        15,
        8,
        10
      ],
      "message": "Press 1 to select Fireball. Aim and cast it on the dummy.",
      "duration": 8,
      "color": "0xff4757"
    },
    {
      "name": "Fireflies_Intro",
      "position": {
        "x": 102,
        "y": 13,
        "z": 80
      },
      "size": [
        10,
        8,
        10
      ],
      "message": "Press 2 for Fireflies. These homing shots seek out your locked-on target.",
      "duration": 8,
      "color": "0xff4757"
    }
  ]
}
--------------------------------------------------
=== END OF FILE: levels/level-tutorial.json ===


=== FILE: levels/manifest.json ===
--------------------------------------------------
[
    {
        "name": "Tutorial",
        "path": "./levels/level-tutorial.json"
    },
    {
        "name": "Mangled Grove",
        "path": "./levels/level-mangled-grove.json"
    }
]
--------------------------------------------------
=== END OF FILE: levels/manifest.json ===


=== FILE: src/editor_main.js ===
--------------------------------------------------
import { EditorApp } from './editor/EditorApp.js';

// Create a new instance of our editor application
const editorApp = new EditorApp();

// Initialize and start the editor loop
editorApp.init();
--------------------------------------------------
=== END OF FILE: src/editor_main.js ===


=== FILE: src/main.js ===
--------------------------------------------------
import { Game } from './game/Game.js';

// Create a new instance of our game
const game = new Game();

// Initialize and start the game loop
game.init();
--------------------------------------------------
=== END OF FILE: src/main.js ===


=== FILE: src/common/CollisionGroups.js ===
--------------------------------------------------
export const COLLISION_GROUPS = {
    WORLD: 1,
    PLAYER: 2,
    PROJECTILE: 4,
    ENEMY: 8,
};
--------------------------------------------------
=== END OF FILE: src/common/CollisionGroups.js ===


=== FILE: src/editor/EditorApp.js ===
--------------------------------------------------
import * as THREE from 'three';
import { Renderer } from '../engine/Renderer.js';
import { Physics } from '../engine/Physics.js';
import { InputManager } from '../engine/InputManager.js';
import { LevelLoader } from '../world/LevelLoader.js';
import { LevelEditor } from './LevelEditor.js';

export class EditorApp {
    constructor() {
        this.clock = new THREE.Clock();
        this.renderer = new Renderer();
        this.physics = new Physics();
        this.input = new InputManager();

        this.scene = this.renderer.scene;
        this.camera = this.renderer.camera;

        this.updatables = [];
        this.levelObjects = [];
        this.enemies = [];
        this.triggers = [];
        
        this.spawnPoint = { x: 0, y: 5, z: 10 };
        this.spawnPointHelper = null;
        this.deathSpawnPoint = { x: 0, y: 5, z: 12 };
        this.deathSpawnPointHelper = null;

        this.settings = {};
        this.ambientLight = null;
        this.directionalLights = []; // Now stores { light, helper, picker, definition }
    }

    async init() {
        this.levelLoader = new LevelLoader(this);
        const levelData = await this.levelLoader.load('./levels/level-mangled-grove.json');

        this.editor = new LevelEditor(this);
        this.loadLevel(levelData);

        window.editorApp = this;
        this.renderer.renderer.setAnimationLoop(() => this.animate());
    }

    loadLevel(levelData) {
        this.clearLevel();
        const { levelObjects, enemies, ambientLight, directionalLights, triggers } = this.levelLoader.build(levelData);
        
        this.levelObjects = levelObjects;
        this.enemies = enemies;
        this.triggers = (triggers || []).map(triggerData => this.createTrigger(triggerData));
        this.spawnPoint = { ...levelData.spawnPoint };
        this.deathSpawnPoint = { ...(levelData.deathSpawnPoint || levelData.spawnPoint) };
        this.settings = levelData.settings;
        this.ambientLight = ambientLight;
        this.directionalLights = directionalLights.map(light => this.createDirectionalLightWithHelper(light));

        this.createSpawnPointHelper();
        this.createDeathSpawnPointHelper();
        this.editor.setLevelData(this.levelObjects, this.enemies, this.triggers);
    }

    createTrigger(triggerData) {
        const geometry = new THREE.BoxGeometry(...triggerData.size);
        const material = new THREE.MeshBasicMaterial({
            color: parseInt(triggerData.color || "0x00ff00", 16),
            transparent: true,
            opacity: 0.35,
            wireframe: true,
            depthWrite: false
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(triggerData.position.x, triggerData.position.y, triggerData.position.z);
        
        const triggerObject = {
            mesh,
            definition: triggerData
        };

        triggerObject.userData = { gameEntity: { type: 'Trigger', entity: triggerObject } };
        mesh.userData.gameEntity = triggerObject.userData.gameEntity;

        this.scene.add(mesh);
        return triggerObject;
    }

    createDirectionalLightWithHelper(light) {
        const helper = new THREE.DirectionalLightHelper(light, 5, 0xffffff);
        if (helper.lightPlane && helper.lightPlane.material) {
            helper.lightPlane.material.depthTest = false;
        }
        this.scene.add(helper);

        const picker = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        picker.position.copy(light.position);
        this.scene.add(picker);
        
        const lightObject = { light, helper, picker, definition: light.userData.definition };
        lightObject.userData = { gameEntity: { type: 'DirectionalLight', entity: lightObject } };
        picker.userData.gameEntity = lightObject.userData.gameEntity;

        return lightObject;
    }
    
    addDirectionalLight() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(20));

        const lightData = {
            color: "0xffffff",
            intensity: 1,
            position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z }
        };

        if (!this.settings.directionalLights) this.settings.directionalLights = [];
        this.settings.directionalLights.push(lightData);
        
        const newLight = this.levelLoader.createDirectionalLight(lightData);
        const newLightObject = this.createDirectionalLightWithHelper(newLight);
        this.directionalLights.push(newLightObject);

        this.editor.select(newLightObject);
    }
    
    removeDirectionalLight(lightObjectToRemove) {
        if (!lightObjectToRemove) return;
        const index = this.directionalLights.indexOf(lightObjectToRemove);
        if (index > -1) {
            this.scene.remove(lightObjectToRemove.light);
            this.scene.remove(lightObjectToRemove.helper);
            this.scene.remove(lightObjectToRemove.picker);

            lightObjectToRemove.helper.dispose();
            lightObjectToRemove.picker.geometry.dispose();
            lightObjectToRemove.picker.material.dispose();

            this.directionalLights.splice(index, 1);
            this.settings.directionalLights.splice(index, 1);
        }
    }

    createSpawnPointHelper() {
        if (this.spawnPointHelper) this.scene.remove(this.spawnPointHelper);
        
        const helper = new THREE.AxesHelper(2);
        helper.material.depthTest = false;
        helper.position.set(this.spawnPoint.x, this.spawnPoint.y, this.spawnPoint.z);

        const pickerBox = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.5, 0.5), 
            new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 })
        );
        helper.add(pickerBox);
        
        helper.userData.gameEntity = { type: 'SpawnPoint', entity: helper };
        pickerBox.userData.gameEntity = helper.userData.gameEntity;
        
        this.spawnPointHelper = helper;
        this.scene.add(this.spawnPointHelper);
    }

    createDeathSpawnPointHelper() {
        if (this.deathSpawnPointHelper) this.scene.remove(this.deathSpawnPointHelper);
        
        const helper = new THREE.AxesHelper(2);
        helper.material.depthTest = false;
        helper.position.set(this.deathSpawnPoint.x, this.deathSpawnPoint.y, this.deathSpawnPoint.z);
    
        const pickerBox = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.5, 0.5), 
            new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.6 }) // Red color
        );
        helper.add(pickerBox);
        
        helper.userData.gameEntity = { type: 'DeathSpawnPoint', entity: helper };
        pickerBox.userData.gameEntity = helper.userData.gameEntity;
        
        this.deathSpawnPointHelper = helper;
        this.scene.add(this.deathSpawnPointHelper);
    }

    clearLevel() {
        [...this.levelObjects, ...this.enemies, ...this.triggers].forEach(obj => {
            if (obj.mesh) this.scene.remove(obj.mesh);
            if (obj.body) this.physics.queueForRemoval(obj.body);
        });
        this.levelObjects = [];
        this.enemies = [];
        this.triggers = [];

        if (this.spawnPointHelper) this.scene.remove(this.spawnPointHelper);
        this.spawnPointHelper = null;
        
        if (this.deathSpawnPointHelper) this.scene.remove(this.deathSpawnPointHelper);
        this.deathSpawnPointHelper = null;

        this.directionalLights.forEach(lightObj => this.removeDirectionalLight(lightObj));
        this.directionalLights = [];
        
        if (this.ambientLight) this.scene.remove(this.ambientLight);
        this.ambientLight = null;
    }

    animate() {
        const deltaTime = this.clock.getDelta();
        this.physics.update(deltaTime);
        this.editor.update(deltaTime);
        this.renderer.render();
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorApp.js ===


=== FILE: src/editor/LevelEditor.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { TransformControls } from 'three/addons/controls/TransformControls.js';

export class LevelEditor {
    constructor(app) {
        this.app = app;
        this.scene = app.scene;
        this.camera = app.camera;
        this.renderer = app.renderer.renderer;
        this.physics = app.physics;
        this.input = app.input;

        this.levelObjects = [];
        this.enemies = [];
        this.triggers = [];
        this.selectedObject = null;
        this.clipboard = null;
        
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();

        this.tempVec3 = new THREE.Vector3();
        this.tempQuat = new THREE.Quaternion();
        
        this.onMouseDownHandler = this.onMouseDown.bind(this);
        this.onKeyDownHandler = this.onKeyDown.bind(this);
        this.onContextMenuHandler = (e) => e.preventDefault();

        this.initUI();
        this.initControls();
        this.addEventListeners();
    }

    addEventListeners() {
        this.renderer.domElement.addEventListener('mousedown', this.onMouseDownHandler, false);
        this.renderer.domElement.addEventListener('contextmenu', this.onContextMenuHandler, false);
        document.addEventListener('keydown', this.onKeyDownHandler);
    }

    dispose() {
        this.renderer.domElement.removeEventListener('mousedown', this.onMouseDownHandler, false);
        this.renderer.domElement.removeEventListener('contextmenu', this.onContextMenuHandler, false);
        document.removeEventListener('keydown', this.onKeyDownHandler);
        this.transformControls.dispose();
        this.scene.remove(this.transformControls);
        this.scene.remove(this.selectionBox);
        this.selectionBox.geometry.dispose();
        this.selectionBox.material.dispose();
    }

    initUI() {
        // Top Bar
        document.getElementById('editor-load-btn').onclick = () => document.getElementById('editor-file-input').click();
        document.getElementById('editor-file-input').onchange = (e) => this.loadFile(e);
        document.getElementById('editor-save-btn').onclick = () => this.saveFile();
        document.getElementById('editor-mode-translate').onclick = () => this.setTransformMode('translate');
        document.getElementById('editor-mode-rotate').onclick = () => this.setTransformMode('rotate');
        document.getElementById('editor-mode-scale').onclick = () => this.setTransformMode('scale');

        // Tabs
        this.tabs = document.querySelectorAll('.editor-tab-btn');
        this.tabContents = document.querySelectorAll('.editor-tab-content');
        this.tabs.forEach(tab => {
            tab.onclick = () => this.switchTab(tab.dataset.tab);
        });

        // Scene Tab
        document.getElementById('skybox-color-input').oninput = (e) => this.updateSkyboxColor(e.target.value);
        document.getElementById('ambient-color-input').oninput = (e) => this.updateAmbientLight('color', e.target.value);
        document.getElementById('ambient-intensity-input').oninput = (e) => this.updateAmbientLight('intensity', e.target.value);

        // Create Tab
        document.getElementById('editor-add-box').onclick = () => this.addBox();
        document.getElementById('editor-add-enemy').onclick = () => this.addEnemy();
        document.getElementById('add-dirlight-btn').onclick = () => this.app.addDirectionalLight();
        document.getElementById('editor-set-spawn').onclick = () => this.setSpawnPointToCamera();
        document.getElementById('editor-set-death-spawn').onclick = () => this.setDeathSpawnPointToCamera();

        // Outliner
        this.outlinerList = document.getElementById('outliner-list');
        this.outlinerList.onclick = (e) => {
            const item = e.target.closest('.outliner-item');
            if (item) {
                this.selectByUUID(item.dataset.uuid);
            }
        };

        // Properties Panel
        this.propertiesPanel = document.getElementById('properties-panel');
        this.propertiesContent = document.getElementById('properties-content');
        document.getElementById('editor-delete-btn').onclick = () => this.deleteSelected();
    }

    initControls() {
        this.transformControls = new TransformControls(this.camera, this.renderer.domElement);
        
        this.transformControls.addEventListener('dragging-changed', (event) => {
            this.input.enabled = !event.value; // Disable camera controls while dragging
            if (!event.value && this.selectedObject && this.transformControls.mode === 'scale') {
                const attachedMesh = this.selectedObject.mesh || this.selectedObject;
                const def = this.selectedObject.definition;
                if (def && def.size) {
                    def.size[0] *= attachedMesh.scale.x;
                    def.size[1] *= attachedMesh.scale.y;
                    if (def.size.length > 2) def.size[2] *= attachedMesh.scale.z;
                    attachedMesh.scale.set(1, 1, 1);
                    this.applyDefinition(this.selectedObject);
                    this.updatePropertiesPanel();
                }
            }
        });
        
        this.transformControls.addEventListener('objectChange', () => {
            if (this.selectedObject) {
                this.syncObjectTransforms();
                this.updatePropertiesPanel();
            }
        });
        this.scene.add(this.transformControls);

        this.selectionBox = new THREE.BoxHelper();
        this.selectionBox.material.depthTest = false;
        this.selectionBox.material.transparent = true;
        this.selectionBox.visible = false;
        this.scene.add(this.selectionBox);
    }
    
    onKeyDown(event) {
        if (event.target.tagName === 'INPUT' || this.transformControls.dragging) return;

        if (event.ctrlKey) {
            switch (event.code) {
                case 'KeyC': event.preventDefault(); this.copySelected(); break;
                case 'KeyV': event.preventDefault(); this.pasteFromClipboard(); break;
            }
        } else {
            switch (event.code) {
                case 'KeyT': this.setTransformMode('translate'); break;
                case 'KeyR': this.setTransformMode('rotate'); break;
                case 'KeyS': this.setTransformMode('scale'); break;
                case 'Delete':
                case 'Backspace':
                    this.deleteSelected();
                    break;
            }
        }
    }

    onMouseDown(event) {
        if (event.button !== 0 || this.transformControls.dragging || this.input.isClickOnUI(event.clientX, event.clientY)) return;
        
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        this.raycaster.setFromCamera(this.mouse, this.camera);

        const pickableMeshes = this.levelObjects.map(o => o.mesh)
            .concat(this.enemies.map(e => e.mesh))
            .concat(this.app.directionalLights.map(l => l.picker))
            .concat(this.triggers.map(t => t.mesh))
            .concat(this.app.spawnPointHelper ? [this.app.spawnPointHelper] : [])
            .concat(this.app.deathSpawnPointHelper ? [this.app.deathSpawnPointHelper] : []);
            
        const intersects = this.raycaster.intersectObjects(pickableMeshes, true);
        const validIntersects = intersects.filter(i => i.object.userData.gameEntity && i.object.userData.gameEntity.entity);
        
        if (validIntersects.length > 0) {
            const entity = validIntersects[0].object.userData.gameEntity.entity;
            if (entity.definition && entity.definition.editorSelectable === false) {
                 this.deselect();
            } else {
                 this.select(entity);
            }
        } else {
            this.deselect();
        }
    }

    // --- Selection and UI Management ---

    select(entity) {
        if (!entity || this.selectedObject === entity) return;
        this.deselect(); // Clear previous selection
        
        this.selectedObject = entity;
        const entityType = entity.userData?.gameEntity?.type;
        let objectToAttach;

        if (entityType === 'DirectionalLight') {
            objectToAttach = entity.picker;
            entity.picker.material.visible = true;
        } else {
            objectToAttach = entity.mesh || entity; // Covers objects, enemies, triggers, and spawn point
        }

        this.transformControls.attach(objectToAttach);
        this.selectionBox.setFromObject(objectToAttach);
        this.selectionBox.visible = true;
        this.propertiesPanel.style.display = 'flex';
        
        this.updatePropertiesPanel();
        this.updateOutliner();
        
        // Disable transform modes if not applicable
        const isEnemy = entity.isDead !== undefined;
        const canRotate = !(entityType === 'SpawnPoint' || entityType === 'DeathSpawnPoint' || entityType === 'DirectionalLight' || entityType === 'Trigger');
        const canScale = !(entityType === 'SpawnPoint' || entityType === 'DeathSpawnPoint' || entityType === 'DirectionalLight' || isEnemy);
        
        document.getElementById('editor-mode-rotate').disabled = !canRotate;
        document.getElementById('editor-mode-scale').disabled = !canScale;

        if (!canRotate && this.transformControls.getMode() === 'rotate') {
            this.setTransformMode('translate');
        }
        if (!canScale && this.transformControls.getMode() === 'scale') {
            this.setTransformMode('translate');
        }
    }

    deselect() {
        if (!this.selectedObject) return;
        
        const entityType = this.selectedObject.userData?.gameEntity?.type;
        if (entityType === 'DirectionalLight') {
            this.selectedObject.picker.material.visible = false;
        }

        this.selectedObject = null;
        this.transformControls.detach();
        this.selectionBox.visible = false;
        this.propertiesPanel.style.display = 'none';
        this.updateOutliner();
        
        // Re-enable all transform mode buttons
        document.getElementById('editor-mode-rotate').disabled = false;
        document.getElementById('editor-mode-scale').disabled = false;
    }

    selectByUUID(uuid) {
        const allEntities = [
            ...this.app.levelObjects, 
            ...this.app.enemies, 
            ...this.app.directionalLights,
            ...this.triggers,
            this.app.spawnPointHelper,
            this.app.deathSpawnPointHelper,
        ].filter(e => e); // Filter out null/undefined

        const entityToSelect = allEntities.find(e => {
            const mesh = e.mesh || e.picker || e; // Handle different entity structures
            return mesh.uuid === uuid;
        });
        
        if (entityToSelect) {
            this.select(entityToSelect);
        }
    }
    
    updateOutliner() {
        this.outlinerList.innerHTML = '';
        const createItem = (entity, name, uuid) => {
            const item = document.createElement('div');
            item.className = 'outliner-item';
            item.textContent = name;
            item.dataset.uuid = uuid;
            if (entity === this.selectedObject) {
                item.classList.add('selected');
            }
            this.outlinerList.appendChild(item);
        };

        if (this.app.spawnPointHelper) {
            createItem(this.app.spawnPointHelper, 'Initial Spawn Point', this.app.spawnPointHelper.uuid);
        }
        if (this.app.deathSpawnPointHelper) {
            createItem(this.app.deathSpawnPointHelper, 'Death Spawn Point', this.app.deathSpawnPointHelper.uuid);
        }
        this.app.directionalLights.forEach((l, i) => createItem(l, `Directional Light ${i+1}`, l.picker.uuid));
        this.app.levelObjects.forEach(o => createItem(o, o.definition.name || 'Object', o.mesh.uuid));
        this.app.enemies.forEach(e => createItem(e, e.name || 'Enemy', e.mesh.uuid));
        this.triggers.forEach((t, i) => createItem(t, t.definition.name || `Trigger ${i+1}`, t.mesh.uuid));
    }
    
    updatePropertiesPanel() {
        if (!this.selectedObject) {
            this.propertiesPanel.style.display = 'none';
            return;
        }
        this.propertiesContent.innerHTML = ''; // Clear previous content

        const entity = this.selectedObject;
        const entityType = entity.userData?.gameEntity?.type;
        
        if (!entityType) return; // Exit if type can't be determined
        
        const fragment = document.createDocumentFragment();

        const createVec3Inputs = (label, vector, callback) => {
            fragment.appendChild(document.createElement('label')).textContent = label;
            const group = fragment.appendChild(document.createElement('div'));
            group.className = 'prop-group';
            ['x', 'y', 'z'].forEach(axis => {
                const input = document.createElement('input');
                input.type = 'number';
                input.step = label.toLowerCase().includes('rot') ? 1 : 0.1;
                input.value = vector[axis].toFixed(2);
                input.onchange = (e) => callback(axis, parseFloat(e.target.value));
                group.appendChild(input);
            });
        };
        
        const createSizeInputs = (label, sizeArr, callback) => {
             fragment.appendChild(document.createElement('label')).textContent = label;
             const group = fragment.appendChild(document.createElement('div'));
             group.className = 'prop-group';
             sizeArr.forEach((val, index) => {
                 const input = document.createElement('input');
                 input.type = 'number';
                 input.step = 0.1;
                 input.value = val.toFixed(2);
                 input.onchange = (e) => callback(index, parseFloat(e.target.value));
                 group.appendChild(input);
             });
        };
        
        const createRangeInput = (label, value, min, max, step, callback) => {
            fragment.appendChild(document.createElement('label')).textContent = label;
            const input = fragment.appendChild(document.createElement('input'));
            input.type = 'range';
            input.min = min; input.max = max; input.step = step;
            input.value = value;
            input.oninput = (e) => callback(parseFloat(e.target.value));
        };
        
        const createColorInput = (label, color, callback) => {
            fragment.appendChild(document.createElement('label')).textContent = label;
            const input = fragment.appendChild(document.createElement('input'));
            input.type = 'color';
            input.value = '#' + color.getHexString();
            input.oninput = (e) => callback(e.target.value);
        };
        
        const createTextInput = (label, value, callback) => {
            fragment.appendChild(document.createElement('label')).textContent = label;
            const input = fragment.appendChild(document.createElement('input'));
            input.type = 'text';
            input.value = value;
            input.onchange = (e) => callback(e.target.value);
        };
        
        if (entityType === 'Trigger') {
            const def = entity.definition;
            createTextInput('Name', def.name || '', (val) => this.updateSelectedProp('name', null, val));
            createVec3Inputs('Position', entity.mesh.position, (axis, val) => this.updateSelectedProp('position', axis, val));
            createSizeInputs('Size', def.size, (index, val) => this.updateSelectedProp('size', index, val));
            fragment.appendChild(document.createElement('hr'));
            createTextInput('Message', def.message || '', (val) => this.updateSelectedProp('message', null, val));
            createColorInput('Color', entity.mesh.material.color, (val) => this.updateSelectedProp('color', null, val));
        } else if (entityType === 'SpawnPoint' || entityType === 'DeathSpawnPoint') {
            createVec3Inputs('Position', entity.position, (axis, val) => this.updateSelectedProp('position', axis, val));
        } else if (entityType === 'DirectionalLight') {
             createColorInput('Color', entity.light.color, (val) => this.updateSelectedProp('color', null, val));
             createRangeInput('Intensity', entity.light.intensity, 0, 10, 0.1, (val) => this.updateSelectedProp('intensity', null, val));
             createVec3Inputs('Position (Direction)', entity.light.position, (axis, val) => this.updateSelectedProp('position', axis, val));
        } else { // Generic Object or Enemy
            const def = entity.definition;
            const mesh = entity.mesh;
            
            const nameLabel = fragment.appendChild(document.createElement('label'));
            nameLabel.textContent = `Name: ${def.name || def.type}`;

            createVec3Inputs('Position', mesh.position, (axis, val) => this.updateSelectedProp('position', axis, val));

            if (entity.isDead === undefined && def.type !== 'Plane') {
                 const eulerRot = new THREE.Euler().setFromQuaternion(mesh.quaternion, 'YXZ');
                 const degRot = { x: THREE.MathUtils.radToDeg(eulerRot.x), y: THREE.MathUtils.radToDeg(eulerRot.y), z: THREE.MathUtils.radToDeg(eulerRot.z) };
                 createVec3Inputs('Rotation', degRot, (axis, val) => this.updateSelectedProp('rotation', axis, val));
            }
            if (def.size) {
                 createSizeInputs('Size', def.size, (index, val) => this.updateSelectedProp('size', index, val));
            }
        }
        
        this.propertiesContent.appendChild(fragment);
    }
    
    // --- Data Manipulation ---

    updateSelectedProp(prop, key, value) {
        if (!this.selectedObject) return;

        const entity = this.selectedObject;
        const entityType = entity.userData?.gameEntity?.type;
        const def = entity.definition;

        if (entityType === 'Trigger') {
            const mesh = entity.mesh;
            if (prop === 'name') def.name = value;
            if (prop === 'position') mesh.position[key] = value;
            if (prop === 'size') def.size[key] = value;
            if (prop === 'message') def.message = value;
            if (prop === 'color') { mesh.material.color.set(value); def.color = value.replace('#', '0x'); }
            this.applyDefinition(entity);
        } else if (entityType === 'SpawnPoint' || entityType === 'DeathSpawnPoint') {
            if (prop === 'position') entity.position[key] = value;
        } else if (entityType === 'DirectionalLight') {
            if (prop === 'color') { entity.light.color.set(value); def.color = value.replace('#', '0x'); }
            if (prop === 'intensity') { entity.light.intensity = value; def.intensity = value; }
            if (prop === 'position') { entity.light.position[key] = value; entity.picker.position[key] = value; def.position[key] = value; entity.helper.update(); }
        } else { // Generic Object / Enemy
            const mesh = entity.mesh;
            if (prop === 'position') mesh.position[key] = value;
            if (prop === 'rotation') {
                const euler = new THREE.Euler().setFromQuaternion(mesh.quaternion, 'YXZ');
                euler[key] = THREE.MathUtils.degToRad(value);
                mesh.quaternion.setFromEuler(euler);
            }
            if (prop === 'size') def.size[key] = value;
            this.applyDefinition(entity);
        }
        this.syncObjectTransforms();
    }
    
    applyDefinition(obj) {
        if (obj.userData?.gameEntity?.type === 'SpawnPoint' || obj.userData?.gameEntity?.type === 'DeathSpawnPoint') {
            this.selectionBox.setFromObject(obj);
            return;
        }

        const def = obj.definition;
        const mesh = obj.mesh;
        const body = obj.body;
        
        mesh.position.set(def.position.x, def.position.y, def.position.z);
        if (def.rotation && obj.isDead === undefined) {
             mesh.rotation.set(
                THREE.MathUtils.degToRad(def.rotation.x || 0),
                THREE.MathUtils.degToRad(def.rotation.y || 0),
                THREE.MathUtils.degToRad(def.rotation.z || 0)
            );
        }

        if(obj.userData?.gameEntity?.type === 'Trigger' && def.size) {
            mesh.geometry.dispose();
            mesh.geometry = new THREE.BoxGeometry(...def.size);
        } else if(def.size && def.type === 'Box' && body?.shapes[0]) {
            const halfExtents = new CANNON.Vec3(def.size[0]/2, def.size[1]/2, def.size[2]/2);
            body.shapes[0].halfExtents.copy(halfExtents);
            body.shapes[0].updateConvexPolyhedronRepresentation();
            body.updateBoundingRadius();
            mesh.geometry.dispose();
            mesh.geometry = new THREE.BoxGeometry(...def.size);
        }
        
        this.syncObjectTransforms();
        this.selectionBox.setFromObject(mesh);
    }
    
    syncObjectTransforms() {
        if (!this.selectedObject) return;
        
        const entity = this.selectedObject;
        const entityType = entity.userData?.gameEntity?.type;
        
        if (entityType === 'Trigger') {
            entity.definition.position = { x: entity.mesh.position.x, y: entity.mesh.position.y, z: entity.mesh.position.z };
        } else if (entityType === 'SpawnPoint') {
            this.app.spawnPoint.x = entity.position.x;
            this.app.spawnPoint.y = entity.position.y;
            this.app.spawnPoint.z = entity.position.z;
        } else if (entityType === 'DeathSpawnPoint') {
            this.app.deathSpawnPoint.x = entity.position.x;
            this.app.deathSpawnPoint.y = entity.position.y;
            this.app.deathSpawnPoint.z = entity.position.z;
        } else if (entityType === 'DirectionalLight') {
             entity.light.position.copy(entity.picker.position);
             entity.definition.position = { x: entity.light.position.x, y: entity.light.position.y, z: entity.light.position.z };
             entity.helper.update();
        } else { // Object or Enemy
            const mesh = entity.mesh;
            const body = entity.body;
            if (body) {
                body.position.copy(mesh.position);
                body.quaternion.copy(mesh.quaternion);
            }
        }
    }
    
    deleteSelected() {
        if (!this.selectedObject) return;
        const entity = this.selectedObject;
        const entityType = entity.userData.gameEntity.type;
        
        if (entityType === 'SpawnPoint' || entityType === 'DeathSpawnPoint') return;

        if (entityType === 'Trigger') {
            const index = this.triggers.findIndex(t => t === entity);
            if (index > -1) this.triggers.splice(index, 1);
            this.scene.remove(entity.mesh);
            entity.mesh.geometry.dispose();
            entity.mesh.material.dispose();
        } else if (entityType === 'DirectionalLight') {
            this.app.removeDirectionalLight(entity);
        } else if (entityType === 'Enemy') {
            if(entity.body) this.physics.queueForRemoval(entity.body);
            const index = this.enemies.findIndex(e => e === entity);
            if (index > -1) this.enemies.splice(index, 1);
            this.scene.remove(entity.mesh);
        } else { // Generic Object
            if(entity.body) this.physics.queueForRemoval(entity.body);
            const index = this.levelObjects.findIndex(o => o === entity);
            if (index > -1) this.levelObjects.splice(index, 1);
            this.scene.remove(entity.mesh);
        }
        
        this.deselect();
        this.updateOutliner();
    }
    
    copySelected() {
        if (!this.selectedObject) return;
        
        const entity = this.selectedObject;
        const entityType = entity.userData?.gameEntity?.type;

        if (entityType === 'Object' || entityType === 'Enemy' || entityType === 'Trigger') {
            this.syncObjectTransforms(); 
            
            if (entityType === 'Object') {
                const rot = new THREE.Euler().setFromQuaternion(entity.mesh.quaternion, 'YXZ');
                entity.definition.rotation = {x: THREE.MathUtils.radToDeg(rot.x), y: THREE.MathUtils.radToDeg(rot.y), z: THREE.MathUtils.radToDeg(rot.z)};
            }

            this.clipboard = JSON.parse(JSON.stringify(entity.definition));
            if (!this.clipboard.type) this.clipboard.type = entityType;
            console.log(`Copied ${this.clipboard.name || entityType} to clipboard.`);
        } else {
            console.log('Cannot copy this entity type:', entityType);
            this.clipboard = null;
        }
    }

    pasteFromClipboard() {
        if (!this.clipboard) return;

        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(15));
        
        const newDef = JSON.parse(JSON.stringify(this.clipboard));
        newDef.position = { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z };
        newDef.name = `${newDef.name || newDef.type}_copy`;

        let newEntity;
        const entityType = newDef.type;

        if (entityType === 'Dummy') {
            newEntity = this.app.levelLoader.createEnemy(newDef);
            this.app.enemies.push(newEntity);
        } else if (entityType === 'Trigger') {
            newEntity = this.app.createTrigger(newDef);
            this.app.triggers.push(newEntity);
        } else {
            newEntity = this.app.levelLoader.createObject(newDef);
            this.app.levelObjects.push(newEntity);
        }
        
        if (newEntity) this.select(newEntity);
    }
    
    addBox() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
        const boxData = {
            type: "Box", name: `Box_${Date.now()}`, size: [2, 2, 2],
            position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
            rotation: { x: 0, y: 0, z: 0 },
            material: { color: "0xcccccc" }, physics: { mass: 0 }
        };
        const newObj = this.app.levelLoader.createObject(boxData);
        this.levelObjects.push(newObj);
        this.select(newObj);
    }
    
    addEnemy() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
        const enemyData = { type: "Dummy", position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z } };
        const newEnemy = this.app.levelLoader.createEnemy(enemyData);
        this.enemies.push(newEnemy);
        this.select(newEnemy);
    }

    loadFile(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                this.app.loadLevel(JSON.parse(e.target.result));
            } catch (err) {
                console.error("Error parsing level file:", err);
                alert("Invalid level file.");
            }
        };
        reader.readAsText(file);
    }

    saveFile() {
        this.app.levelObjects.forEach(obj => {
            obj.definition.position = {x: obj.mesh.position.x, y: obj.mesh.position.y, z: obj.mesh.position.z};
            const rot = new THREE.Euler().setFromQuaternion(obj.mesh.quaternion, 'YXZ');
            obj.definition.rotation = {x: THREE.MathUtils.radToDeg(rot.x), y: THREE.MathUtils.radToDeg(rot.y), z: THREE.MathUtils.radToDeg(rot.z)};
        });
        this.app.enemies.forEach(enemy => {
            enemy.definition.position = {x: enemy.mesh.position.x, y: enemy.mesh.position.y, z: enemy.mesh.position.z};
        });
        this.triggers.forEach(trigger => {
            trigger.definition.position = {x: trigger.mesh.position.x, y: trigger.mesh.position.y, z: trigger.mesh.position.z};
        });

        const levelData = {
            name: "Custom Level",
            spawnPoint: this.app.spawnPoint,
            deathSpawnPoint: this.app.deathSpawnPoint,
            settings: this.app.settings,
            objects: this.app.levelObjects.map(obj => obj.definition),
            enemies: this.app.enemies.map(enemy => enemy.definition),
            triggers: this.triggers.map(t => t.definition)
        };
        
        const blob = new Blob([JSON.stringify(levelData, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'custom-level.json';
        a.click();
        URL.revokeObjectURL(a.href);
    }
    
    updateSkyboxColor(color) {
        this.app.scene.background = new THREE.Color(color);
        this.app.settings.backgroundColor = color.replace('#', '0x');
    }
    
    updateAmbientLight(prop, value) {
        const light = this.app.ambientLight;
        const setting = this.app.settings.ambientLight;
        if (prop === 'color') { light.color.set(value); setting.color = value.replace('#', '0x'); }
        if (prop === 'intensity') { light.intensity = parseFloat(value); setting.intensity = parseFloat(value); }
    }

    switchTab(tabId) {
        this.tabs.forEach(tab => tab.classList.remove('active'));
        this.tabContents.forEach(content => content.classList.remove('active'));
        document.querySelector(`.editor-tab-btn[data-tab="${tabId}"]`).classList.add('active');
        document.getElementById(tabId).classList.add('active');
    }

    setTransformMode(mode) {
        if (this.transformControls.object) {
            this.transformControls.setMode(mode);
            document.getElementById('editor-mode-translate').classList.toggle('active', mode === 'translate');
            document.getElementById('editor-mode-rotate').classList.toggle('active', mode === 'rotate');
            document.getElementById('editor-mode-scale').classList.toggle('active', mode === 'scale');
        }
    }

    setSpawnPointToCamera() {
        this.camera.getWorldPosition(this.app.spawnPointHelper.position);
        this.syncObjectTransforms();
    }
    
    setDeathSpawnPointToCamera() {
        this.camera.getWorldPosition(this.app.deathSpawnPointHelper.position);
        this.syncObjectTransforms();
    }
    
    setLevelData(levelObjects, enemies, triggers) {
        this.levelObjects = levelObjects;
        this.enemies = enemies;
        this.triggers = triggers || [];
        this.deselect();
        this.updateOutliner();
        
        const settings = this.app.settings;
        if (!settings) return;
        document.getElementById('skybox-color-input').value = '#' + new THREE.Color(parseInt(settings.backgroundColor || "0x000000", 16)).getHexString();
        document.getElementById('ambient-color-input').value = '#' + new THREE.Color(parseInt(settings.ambientLight.color, 16)).getHexString();
        document.getElementById('ambient-intensity-input').value = settings.ambientLight.intensity;
    }
    
    update(deltaTime) {
        if (this.transformControls.dragging || !this.input.enabled) {
            this.input.update();
            return;
        }

        const moveSpeed = 50 * deltaTime;
        const forward = new THREE.Vector3();
        this.camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(this.camera.up, forward).negate();
        
        if (this.input.keys['KeyW']) this.camera.position.addScaledVector(forward, moveSpeed);
        if (this.input.keys['KeyS']) this.camera.position.addScaledVector(forward, -moveSpeed);
        if (this.input.keys['KeyA']) this.camera.position.addScaledVector(right, -moveSpeed);
        if (this.input.keys['KeyD']) this.camera.position.addScaledVector(right, moveSpeed);
        if (this.input.keys['Space']) this.camera.position.y += moveSpeed;
        if (this.input.keys['ShiftLeft']) this.camera.position.y -= moveSpeed;
        
        if (this.input.mouse.rightClick && !this.input.isClickOnUI(this.input.mouse.screenX, this.input.mouse.screenY)) {
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            euler.setFromQuaternion(this.camera.quaternion);
            euler.y -= this.input.mouse.movementX * 0.002;
            euler.x -= this.input.mouse.movementY * 0.002;
            euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
            this.camera.quaternion.setFromEuler(euler);
        }

        this.input.update();
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/LevelEditor.js ===


=== FILE: src/engine/InputManager.js ===
--------------------------------------------------
export class InputManager {
    constructor() {
        this.keys = {};
        this.mouse = {
            movementX: 0,
            movementY: 0,
            leftClick: false,
            rightClick: false,
            screenX: 0,
            screenY: 0,
        };
        this.enabled = true;

        document.addEventListener('keydown', (e) => this.keys[e.code] = true);
        document.addEventListener('keyup', (e) => this.keys[e.code] = false);

        document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        document.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
    }

    handleMouseMove(event) {
        this.mouse.screenX = event.clientX;
        this.mouse.screenY = event.clientY;
        // Always update movement properties. The consumer (game/editor) will decide how to use them.
        // The game uses them when pointer is locked. The editor will use them when a mouse button is held.
        this.mouse.movementX = event.movementX;
        this.mouse.movementY = event.movementY;
    }

    handleMouseDown(event) {
        if (event.button === 0) this.mouse.leftClick = true;
        if (event.button === 2) this.mouse.rightClick = true;
    }
    
    handleMouseUp(event) {
        if (event.button === 0) this.mouse.leftClick = false;
        if (event.button === 2) this.mouse.rightClick = false;
    }
    
    isClickOnUI(x, y) {
        const editorUI = document.getElementById('editor-ui');
        if (!editorUI) return false;

        const rect = editorUI.getBoundingClientRect();
        return (
            x >= rect.left &&
            x <= rect.right &&
            y >= rect.top &&
            y <= rect.bottom
        );
    }

    update() {
        this.mouse.movementX = 0;
        this.mouse.movementY = 0;
    }
}
--------------------------------------------------
=== END OF FILE: src/engine/InputManager.js ===


=== FILE: src/engine/Physics.js ===
--------------------------------------------------
import * as CANNON from 'cannon-es';

export class Physics {
    constructor() {
        this.world = new CANNON.World({
            gravity: new CANNON.Vec3(0, -9.82, 0)
        });

        // A queue for bodies to be safely removed after the physics step.
        this.bodiesToRemove = [];
    }

    /**
     * Safely queues a physics body for removal from the world.
     * The body will be removed after the next physics step.
     * @param {CANNON.Body} body The body to remove.
     */
    queueForRemoval(body) {
        // Avoid adding the same body multiple times.
        if (body && !this.bodiesToRemove.includes(body)) {
            this.bodiesToRemove.push(body);
        }
    }

    update(deltaTime) {
        // Run the simulation step first.
        this.world.step(1 / 60, deltaTime, 3);

        // AFTER the simulation, safely remove any bodies from the queue.
        if (this.bodiesToRemove.length > 0) {
            for (const body of this.bodiesToRemove) {
                this.world.removeBody(body);
            }
            // Clear the queue for the next frame.
            this.bodiesToRemove = [];
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/engine/Physics.js ===


=== FILE: src/engine/Renderer.js ===
--------------------------------------------------
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

export class Renderer {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);

        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            canvas: document.getElementById('game-canvas')
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        
        // --- PERFORMANCE: Shadow Map Configuration ---
        // Enabling shadows is expensive. Configuring them properly is key.
        this.renderer.shadowMap.enabled = true;
        // PCFSoftShadowMap gives softer, more realistic shadows than the default.
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        
        this.bloomPass = null; // Will be initialized in setupPostProcessing

        window.addEventListener('resize', () => this.onWindowResize());
    }

    setupPostProcessing(scene, camera, viewModelScene) {
        this.composer = new EffectComposer(this.renderer);
        this.composer.addPass(new RenderPass(scene, camera));

        // Add a separate render pass for the view model (e.g., player hands)
        // This ensures they render on top of the main scene without clipping.
        if (viewModelScene) {
            const viewModelPass = new RenderPass(viewModelScene, camera);
            viewModelPass.clear = false; // Don't clear the color buffer
            viewModelPass.clearDepth = true; // DO clear the depth buffer
            this.composer.addPass(viewModelPass);
        }
        
        // MODIFIED: Tuned bloom pass to be less aggressive.
        this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        this.bloomPass.threshold = 0.9;
        this.bloomPass.strength = 0.7;
        this.bloomPass.radius = 0.5;
        this.composer.addPass(this.bloomPass);
    }
    
    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        if (this.composer) {
            this.composer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    render() {
        if (this.composer) {
            this.composer.render();
        } else {
            this.renderer.render(this.scene, this.camera);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/engine/Renderer.js ===


=== FILE: src/game/Game.js ===
--------------------------------------------------
import * as THREE from 'three';
import { Renderer } from '../engine/Renderer.js';
import { Physics } from '../engine/Physics.js';
import { InputManager } from '../engine/InputManager.js';
import { LevelLoader } from '../world/LevelLoader.js';
import { Player } from './entities/Player.js';
import { HUD } from './ui/HUD.js';
import { TutorialManager } from './ui/TutorialManager.js';

export class Game {
    constructor() {
        this.clock = new THREE.Clock();
        this.renderer = new Renderer();
        this.physics = new Physics();
        this.input = new InputManager();

        this.viewModelScene = new THREE.Scene();

        this.updatables = []; 
        this.activeEffects = [];
        this.levelObjects = [];
        this.enemies = [];

        // --- Game State & UI ---
        this.gameState = 'MENU'; // MENU, LOADING, PLAYING, PAUSED, DEAD
        this.respawnTimer = 0;
        this.RESPAWN_COOLDOWN = 5.0;

        this.ui = {
            main: document.getElementById('main-menu'),
            levelSelect: document.getElementById('level-select-menu'),
            pause: document.getElementById('pause-menu'),
            death: document.getElementById('death-screen'),
            levelList: document.getElementById('level-list'),
            respawnTimerText: document.getElementById('respawn-timer-text'),
            playBtn: document.getElementById('play-btn'),
            tutorialBtn: document.getElementById('tutorial-btn'),
            resumeBtn: document.getElementById('resume-btn'),
            pauseQuitBtn: document.getElementById('pause-quit-btn'),
            deathQuitBtn: document.getElementById('death-quit-btn'),
        };

        this.currentLevelUrl = null;
    }

    async init() {
        this.levelLoader = new LevelLoader(this);
        
        this.renderer.setupPostProcessing(this.renderer.scene, this.renderer.camera, this.viewModelScene);
        
        this.player = new Player(this.renderer.camera, this.physics.world, this.input, this.viewModelScene, this);
        this.player.isDead = true;

        this.hud = new HUD(this.player, this);
        this.updatables.push(this.hud);
        
        this.tutorialManager = new TutorialManager(this);

        await this.populateLevelList();
        this.setupEventListeners();
        this.returnToMenu(); // Start in the main menu

        this._warmupShaders();
        this.renderer.renderer.setAnimationLoop(() => this.animate());
    }

    setupEventListeners() {
        this.ui.playBtn.onclick = () => this.showScreen(this.ui.levelSelect);
        this.ui.tutorialBtn.onclick = () => this.startGame('./levels/level-tutorial.json');

        document.querySelectorAll('.back-button').forEach(btn => 
            btn.onclick = () => this.showScreen(document.getElementById(btn.dataset.target))
        );

        // For unpausing, we just request the lock. The 'pointerlockchange' event handles the rest.
        this.ui.resumeBtn.onclick = () => document.body.requestPointerLock();
        
        this.ui.pauseQuitBtn.onclick = () => this.returnToMenu();
        this.ui.deathQuitBtn.onclick = () => this.returnToMenu();

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                if (this.gameState === 'PAUSED') {
                    // Just request the lock. The 'pointerlockchange' event will handle the rest.
                    document.body.requestPointerLock();
                }
                // If 'PLAYING', the browser's default ESC action will release the lock,
                // which is caught by our 'pointerlockchange' listener to pause the game.
            }
        });

        // This is the definitive source of truth for the pointer lock state.
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === document.body) {
                // We just GAINED pointer lock.
                if (this.gameState === 'PAUSED') {
                    this.gameState = 'PLAYING';
                    this.ui.pause.style.display = 'none';
                    document.body.classList.add('game-active');
                }
            } else {
                // We just LOST pointer lock.
                if (this.gameState === 'PLAYING') {
                    this.gameState = 'PAUSED';
                    this.showScreen(this.ui.pause);
                    document.body.classList.remove('game-active');
                }
            }
        }, false);
    }

    async populateLevelList() {
        try {
            const response = await fetch('./levels/manifest.json');
            const levels = await response.json();
            this.ui.levelList.innerHTML = '';
            for (const level of levels) {
                // Don't show the tutorial in the regular level list
                if (level.name.toLowerCase() === 'tutorial') continue;
                
                const btn = document.createElement('button');
                btn.textContent = level.name;
                btn.onclick = () => this.startGame(level.path);
                this.ui.levelList.appendChild(btn);
            }
        } catch (error) {
            console.error("Could not load level manifest:", error);
            this.ui.levelList.innerHTML = '<p style="color: #ff4757;">Could not load levels.</p>';
        }
    }

    showScreen(screenToShow) {
        Object.values(this.ui).forEach(element => {
            if (element instanceof HTMLElement && element.classList.contains('menu-screen')) {
                element.style.display = 'none';
            }
        });
        screenToShow.style.display = 'flex';
    }

    async startGame(levelUrl) {
        this.gameState = 'LOADING';
        this.currentLevelUrl = levelUrl;
        
        document.body.requestPointerLock();

        this.showScreen(this.ui.main);
        this.ui.main.innerHTML = '<h2>Loading...</h2>';

        await this.loadLevel(levelUrl);

        if (document.pointerLockElement !== document.body) {
            this.returnToMenu();
            return;
        }
        
        this.player.spawn(this.levelLoader.getSpawnPoint());
        this.gameState = 'PLAYING';
        
        Object.values(this.ui).forEach(element => {
            if (element instanceof HTMLElement && element.classList.contains('menu-screen')) {
                 element.style.display = 'none';
            }
        });

        document.body.classList.add('game-active');
    }
    
    handlePlayerDeath() {
        if (this.gameState === 'DEAD') return;
        this.gameState = 'DEAD';
        this.respawnTimer = this.RESPAWN_COOLDOWN;
        this.showScreen(this.ui.death);
        document.body.classList.remove('game-active');
        if (document.pointerLockElement) document.exitPointerLock();
    }
    
    async respawnPlayer() {
        this.gameState = 'LOADING';
        this.ui.death.innerHTML = '<h2>Loading...</h2>';
        
        await this.loadLevel(this.currentLevelUrl);
        
        this.ui.death.innerHTML = `
            <h2>YOU DIED</h2>
            <p id="respawn-timer-text">Respawning in 5...</p>
            <div class="menu-options">
                <button id="death-quit-btn">Return to Menu</button>
            </div>`;
        this.ui.respawnTimerText = document.getElementById('respawn-timer-text');
        this.ui.deathQuitBtn = document.getElementById('death-quit-btn');
        this.ui.deathQuitBtn.onclick = () => this.returnToMenu();
        
        const respawnPos = this.levelLoader.getDeathSpawnPoint() || this.levelLoader.getSpawnPoint();
        this.player.spawn(respawnPos);
        this.gameState = 'PLAYING';
        this.ui.death.style.display = 'none';

        document.body.classList.add('game-active');
        document.body.requestPointerLock();
    }

    returnToMenu() {
        this.gameState = 'MENU';
        this.player.isDead = true;
        this.clearLevel();
        this.showScreen(this.ui.main);
         this.ui.main.innerHTML = `
            <h1>ELEMENTALS</h1>
            <div class="menu-options">
                <button id="play-btn">Play</button>
                <button id="tutorial-btn">How to Play</button>
            </div>`;
        this.ui.playBtn = document.getElementById('play-btn');
        this.ui.tutorialBtn = document.getElementById('tutorial-btn');
        this.ui.playBtn.onclick = () => this.showScreen(this.ui.levelSelect);
        this.ui.tutorialBtn.onclick = () => this.startGame('./levels/level-tutorial.json');
        document.body.classList.remove('game-active');
        if (document.pointerLockElement) document.exitPointerLock();
    }

    async loadLevel(levelUrl) {
        this.clearLevel();
        const levelData = await this.levelLoader.load(levelUrl);
        const { levelObjects, enemies } = this.levelLoader.build(levelData);
        this.levelObjects = levelObjects;
        this.enemies = enemies;
        this.tutorialManager.loadTriggers(levelData.triggers || []);
    }

    clearLevel() {
        this.tutorialManager.clearTriggers();
        for (const obj of this.levelObjects) {
            this.renderer.scene.remove(obj.mesh);
            obj.mesh.geometry.dispose();
            obj.mesh.material.dispose();
            if(obj.body) this.physics.queueForRemoval(obj.body);
        }
        [...this.enemies].forEach(enemy => enemy.die(true));
        this.levelObjects = [];
        this.enemies = [];
    }

    animate() {
        const deltaTime = this.clock.getDelta();
        
        if (this.gameState === 'PLAYING' || this.gameState === 'PAUSED') {
            this.physics.update(deltaTime);
        }
        
        if (this.gameState === 'PLAYING') {
            for (let i = this.updatables.length - 1; i >= 0; i--) {
                this.updatables[i]?.update(deltaTime);
            }
            this.player.update(deltaTime);
        } else if (this.gameState === 'DEAD') {
            this.respawnTimer -= deltaTime;
            this.ui.respawnTimerText.textContent = `Respawning in ${Math.ceil(this.respawnTimer)}...`;
            if (this.respawnTimer <= 0) {
                this.respawnPlayer();
            }
            this.hud.update(); // Update HUD to show empty bars
        } else if (this.gameState === 'PAUSED') {
             this.hud.update();
        }
        
        this.renderer.render();
    }
    
    _warmupShaders() {
        console.log("Warming up shaders...");
        const scene = this.renderer.scene;
        const offscreenPos = new THREE.Vector3(10000, 10000, 10000);
    
        // Materials to pre-compile
        const materials = [
            // Fireball Material
            new THREE.MeshStandardMaterial({ color: 0xff8800, emissive: 0xff4400, emissiveIntensity: 5 }),
            // ParticleExplosion Material
            new THREE.PointsMaterial({ color: 0xff8800, size: 0.1, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }),
            // Enemy Projectile Material
            new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 10 }),
        ];
    
        const dummyGeometry = new THREE.PlaneGeometry(0.01, 0.01);
        const dummyObjects = materials.map(material => {
            const mesh = material.isPointsMaterial 
                ? new THREE.Points(dummyGeometry, material) 
                : new THREE.Mesh(dummyGeometry, material);
            mesh.position.copy(offscreenPos);
            mesh.visible = false;
            scene.add(mesh);
            return { mesh, material };
        });
    
        // Render a single frame to force shader compilation
        this.renderer.render();
    
        // Clean up dummy objects and materials
        dummyObjects.forEach(({ mesh, material }) => {
            scene.remove(mesh);
            material.dispose();
        });
        dummyGeometry.dispose();
    
        console.log("Shaders warmed up.");
    }
}
--------------------------------------------------
=== END OF FILE: src/game/Game.js ===


=== FILE: src/game/abilities/Ability.js ===
--------------------------------------------------
export class Ability {
    constructor(caster, { name, icon, cooldown, energyCost }) {
        this.caster = caster;
        this.name = name || 'Unnamed Ability';
        this.icon = icon || '?';
        this.cooldown = cooldown || 0;
        this.energyCost = energyCost || 0;

        this.cooldownTimer = this.cooldown; // Start ready to cast
    }

    /**
     * Checks if the ability can be cast based on cooldown and energy.
     * @returns {boolean}
     */
    canCast() {
        const isReady = this.cooldownTimer >= this.cooldown;
        const hasEnergy = this.caster.currentEnergy >= this.energyCost;
        return isReady && hasEnergy;
    }

    /**
     * Executes the ability's logic. MUST be overridden by subclasses.
     * @returns {boolean} True if the cast was successful, false otherwise.
     */
    cast() {
        throw new Error("Ability.cast() must be implemented by subclasses.");
    }

    /**
     * Resets the cooldown timer after casting.
     */
    triggerCooldown() {
        this.cooldownTimer = 0;
    }

    /**
     * Gets the current cooldown progress as a value from 0.0 to 1.0.
     * @returns {number}
     */
    getCooldownProgress() {
        if (this.cooldown === 0) return 1.0;
        return Math.min(this.cooldownTimer / this.cooldown, 1.0);
    }
    
    /**
     * Updates the cooldown timer.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    update(deltaTime) {
        if (this.cooldownTimer < this.cooldown) {
            this.cooldownTimer += deltaTime;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/Ability.js ===


=== FILE: src/game/abilities/EnemyProjectile.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../../common/CollisionGroups.js';

/**
 * A projectile fired by an enemy entity. It is given an initial velocity and is affected by gravity.
 */
export class EnemyProjectile {
    constructor({caster, initialVelocity}) {
        this.game = caster.game;
        this.scene = caster.scene;
        this.world = caster.world;
        
        // --- Configuration ---
        this.damage = 100;
        this.lifetime = 3.0;
        this.isDead = false;

        // --- Visuals ---
        const geometry = new THREE.SphereGeometry(0.2, 16, 16);
        const material = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 10 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;
        this.light = new THREE.PointLight(0x00ffff, 200, 20, 2);
        this.mesh.add(this.light);

        // --- Physics ---
        const shape = new CANNON.Sphere(0.2);
        this.body = new CANNON.Body({
            mass: 0.1,
            shape,
            collisionFilterGroup: COLLISION_GROUPS.PROJECTILE,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.PLAYER,
            type: CANNON.Body.DYNAMIC,
            linearDamping: 0,
            angularDamping: 0,
        });

        // --- Trajectory ---
        // Spawn slightly in front of the caster.
        const spawnDirection = new CANNON.Vec3().copy(initialVelocity);
        spawnDirection.normalize(); // This modifies the vector in-place. Do not chain it.
        
        const spawnPos = new CANNON.Vec3().copy(caster.body.position);
        
        // Create the offset vector and add it to the spawn position.
        const offset = spawnDirection.scale(2);
        spawnPos.vadd(offset, spawnPos);
        
        this.body.position.copy(spawnPos);
        
        // Use the pre-calculated velocity from the enemy AI.
        this.body.velocity.copy(initialVelocity);
        
        this.body.addEventListener('collide', (event) => this.onCollide(event));

        // --- Finalize ---
        this.scene.add(this.mesh);
        this.world.addBody(this.body);
        this.game.updatables.push(this);
    }

    onCollide(event) {
        if (event.body === this.game.player.body) {
            this.game.player.takeDamage(this.damage);
        }
        this.cleanup();
    }

    update(deltaTime) {
        if (this.isDead) return;

        this.lifetime -= deltaTime;
        if (this.lifetime <= 0) {
            this.cleanup();
            return;
        }
        this.mesh.position.copy(this.body.position);
    }
    
    cleanup() {
        if (this.isDead) return;
        this.isDead = true;
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.game.physics.queueForRemoval(this.body);
        const updatableIndex = this.game.updatables.indexOf(this);
        if (updatableIndex > -1) {
            this.game.updatables.splice(updatableIndex, 1);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/EnemyProjectile.js ===


=== FILE: src/game/abilities/Fireball.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { ParticleExplosion } from './ParticleExplosion.js';
import { COLLISION_GROUPS } from '../../common/CollisionGroups.js';

export class Fireball {
    constructor(caster) {
        this.caster = caster;
        this.scene = caster.game.renderer.scene; // Use the main game scene
        this.game = caster.game;
        this.physics = caster.game.physics;
        this.world = this.physics.world;

        this.MAX_TRAVEL_DISTANCE = 70;
        this.SPEED = 35;
        this.LIFETIME = this.MAX_TRAVEL_DISTANCE / this.SPEED;
        this.RADIUS = 0.3;
        this.GROW_DURATION = 0.2;
        this.LINGER_DURATION = 3.0;
        this.SHRINK_DURATION = 0.5;
        this.FINAL_SCALE = 40;
        this.DAMAGE_PER_SECOND = 75;
        
        this.state = 'TRAVELING';
        this.stateTimer = 0;
        this.isDead = false;
        this.body = null;
        this.preStepHandler = this.applyAntiGravity.bind(this);

        // --- PERFORMANCE: Reusable objects for AOE checks ---
        this._aoeExplosionCenter = new THREE.Vector3();
        this._aoePlayerPosition = new THREE.Vector3();
        this._aoeEnemyPosition = new THREE.Vector3();

        const geometry = new THREE.SphereGeometry(this.RADIUS, 32, 32);
        const material = new THREE.MeshStandardMaterial({
            color: 0xff8800, emissive: 0xff4400, emissiveIntensity: 5,
            roughness: 0.6, metalness: 0.2,
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.receiveShadow = false;
        this.mesh.castShadow = false;
        
        const camera = this.caster.camera;
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);

        const startPosition = new THREE.Vector3();
        camera.getWorldPosition(startPosition).add(cameraDirection.clone().multiplyScalar(1.5));
        
        // --- Physics Body ---
        const shape = new CANNON.Sphere(this.RADIUS);
        this.body = new CANNON.Body({
            mass: 0.5,
            shape,
            collisionFilterGroup: COLLISION_GROUPS.PROJECTILE,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY,
            type: CANNON.Body.DYNAMIC,
            linearDamping: 0,
            angularDamping: 0,
        });

        this.body.position.copy(startPosition);
        this.body.velocity.copy(cameraDirection.multiplyScalar(this.SPEED));
        
        this.body.addEventListener('collide', (event) => {
            // Prevent explosion center from being inside a wall.
            // We find the contact normal and nudge the detonation point slightly away from the surface.
            const contactNormal = new CANNON.Vec3();
            
            // The contact normal (ni) points from the second body (bj) to the first (bi).
            // We need a normal that consistently points away from the surface we hit.
            if (event.contact.bi.id === this.body.id) {
                // If we are body 'i', the normal already points away from the other object.
                contactNormal.copy(event.contact.ni);
            } else {
                // If we are body 'j', we need to flip the normal.
                event.contact.ni.negate(contactNormal);
            }

            const hitPoint = new CANNON.Vec3().copy(this.body.position);
            // Nudge the explosion center 10cm away from the wall to ensure it's in open space.
            hitPoint.vadd(contactNormal.scale(0.1), hitPoint);

            this.detonate(hitPoint);
        });

        this.mesh.position.copy(this.body.position);

        this.light = new THREE.PointLight(0xffaa33, 500, 100, 2);
        this.light.castShadow = true;
        this.scene.add(this.mesh);
        this.scene.add(this.light);
        this.world.addBody(this.body);
        this.world.addEventListener('preStep', this.preStepHandler);
        this.game.updatables.push(this);
    }

    applyAntiGravity() {
        if (!this.body || this.isDead || this.state !== 'TRAVELING') return;
        const antiGravity = new CANNON.Vec3(0, -this.world.gravity.y, 0).scale(this.body.mass);
        this.body.applyForce(antiGravity, this.body.position);
    }

    get explosionRadius() {
        if (this.state === 'GROWING' || this.state === 'LINGERING' || this.state === 'SHRINKING') {
            return this.mesh.scale.x * this.RADIUS;
        }
        return 0;
    }

    detonate(hitPoint) {
        if (this.state !== 'TRAVELING') return;
        
        this.state = 'GROWING';
        this.stateTimer = 0;
        
        this.mesh.position.copy(hitPoint);
        
        if (this.body) {
            this.physics.queueForRemoval(this.body);
            this.body = null;
        }
        
        this.game.activeEffects.push(this);
        new ParticleExplosion(this.scene, this.mesh.position, this.game.updatables);
    }

    update(deltaTime) {
        if (this.isDead) return;
        this.stateTimer += deltaTime;

        this.light.position.copy(this.mesh.position);

        switch (this.state) {
            case 'TRAVELING':
                if (this.stateTimer > this.LIFETIME) {
                    this.detonate(this.body.position);
                    break;
                }
                this.mesh.position.copy(this.body.position);
                break;
            case 'GROWING':
                this.handleGrowing();
                this.updateAoeDamage(deltaTime);
                break;
            case 'LINGERING':
                this.handleLingering();
                this.updateAoeDamage(deltaTime);
                break;
            case 'SHRINKING':
                this.handleShrinking();
                break;
        }
    }
    
    handleGrowing() {
        let progress = Math.min(this.stateTimer / this.GROW_DURATION, 1.0);
        const scale = THREE.MathUtils.lerp(1, this.FINAL_SCALE, progress);
        this.mesh.scale.set(scale, scale, scale);
        this.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(5, 10, progress);
        this.light.intensity = THREE.MathUtils.lerp(500, 1000, progress);

        if (progress >= 1.0) {
            this.mesh.scale.set(this.FINAL_SCALE, this.FINAL_SCALE, this.FINAL_SCALE);
            this.state = 'LINGERING';
            this.stateTimer = 0;
        }
    }

    updateAoeDamage(deltaTime) {
        const explosionRadius = this.explosionRadius;
        if (explosionRadius <= 0) return;

        this._aoeExplosionCenter.copy(this.mesh.position);
        const damage = this.DAMAGE_PER_SECOND * deltaTime;

        const player = this.game.player;
        if (player && player.body) {
            this._aoePlayerPosition.copy(player.body.position);
            const playerRadius = player.body.shapes[0].radius;
            if (this._aoePlayerPosition.distanceTo(this._aoeExplosionCenter) < explosionRadius + playerRadius) {
                player.takeDamage(damage);
            }
        }

        for (const enemy of this.game.enemies) {
            if (enemy && enemy.body && !enemy.isDead) {
                this._aoeEnemyPosition.copy(enemy.body.position);
                const enemyRadius = enemy.body.shapes[0].radius;
                if (this._aoeEnemyPosition.distanceTo(this._aoeExplosionCenter) < explosionRadius + enemyRadius) {
                    enemy.takeDamage(damage);
                }
            }
        }
    }
    
    handleLingering() {
        const pulse = Math.sin(this.stateTimer * Math.PI * 2) * 0.5 + 0.5;
        this.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(8, 12, pulse);
        this.light.intensity = THREE.MathUtils.lerp(20000, 25000, pulse);
        
        if (this.stateTimer >= this.LINGER_DURATION) {
            this.state = 'SHRINKING';
            this.stateTimer = 0;
        }
    }
    
    handleShrinking() {
        let progress = Math.min(this.stateTimer / this.SHRINK_DURATION, 1.0);
        const scale = THREE.MathUtils.lerp(this.FINAL_SCALE, 0, progress);
        this.mesh.scale.set(scale, scale, scale);
        
        this.light.intensity = THREE.MathUtils.lerp(1500, 0, progress);
        this.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(12, 0, progress);
        if (progress >= 1.0) this.cleanup();
    }

    cleanup() {
        if (this.isDead) return;
        this.isDead = true;
        
        this.world.removeEventListener('preStep', this.preStepHandler);

        this.scene.remove(this.mesh);
        this.scene.remove(this.light);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        
        if(this.body) this.physics.queueForRemoval(this.body);

        const effectIndex = this.game.activeEffects.indexOf(this);
        if (effectIndex > -1) this.game.activeEffects.splice(effectIndex, 1);
        const updatableIndex = this.game.updatables.indexOf(this);
        if (updatableIndex > -1) this.game.updatables.splice(updatableIndex, 1);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/Fireball.js ===


=== FILE: src/game/abilities/FireballAbility.js ===
--------------------------------------------------
import { Ability } from './Ability.js';
import { Fireball } from './Fireball.js';

export class FireballAbility extends Ability {
    constructor(caster) {
        super(caster, {
            name: 'Fireball',
            icon: 'FB',
            cooldown: 0.5,
            energyCost: 100,
        });
    }

    /**
     * @override
     */
    cast() {
        if (this.canCast()) {
            new Fireball(this.caster); // Creates the projectile
            this.caster.currentEnergy -= this.energyCost;
            this.caster.lastAbilityTime = this.caster.world.time; // For energy regen delay
            this.triggerCooldown();
            
            console.log(`Casted ${this.name}. Energy: ${this.caster.currentEnergy}/${this.caster.maxEnergy}`);
            return true;
        }
        return false;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FireballAbility.js ===


=== FILE: src/game/abilities/FirefliesAbility.js ===
--------------------------------------------------
import { Ability } from './Ability.js';
import { FireflyProjectile } from './FireflyProjectile.js';

export class FirefliesAbility extends Ability {
    constructor(caster) {
        super(caster, {
            name: 'Fireflies',
            icon: 'FF', // Icon for the HUD
            cooldown: 10.0, // 10-second cooldown
            energyCost: 300, // 300 energy points to cast
        });
        this.numProjectiles = 5; // Number of fireflies to shoot
    }

    /**
     * @override
     * Executes the Fireflies ability.
     * Launches multiple homing projectiles towards the enemy currently targeted by the player's crosshair.
     */
    cast() {
        if (this.canCast()) { // Check if ability is off cooldown and player has enough energy
            // Use the pre-determined target from player's crosshair logic
            const targetEnemy = this.caster.lockedTarget; 

            if (!targetEnemy || targetEnemy.isDead) {
                console.log("Fireflies: No valid enemy target found."); // Modified log message
                // If no target, don't consume resources or trigger cooldown
                return false; 
            }

            // Spawn the specified number of firefly projectiles, all targeting the same enemy
            for (let i = 0; i < this.numProjectiles; i++) {
                // Add a slight delay between projectiles for visual effect
                setTimeout(() => {
                    if (!this.caster.isDead) { // Ensure player is still alive before spawning
                        new FireflyProjectile({ caster: this.caster, target: targetEnemy });
                    }
                }, i * 75); // 75ms delay between each projectile
            }

            // Consume energy and trigger the ability's cooldown
            this.caster.currentEnergy -= this.energyCost;
            this.caster.lastAbilityTime = this.caster.world.time; // Update last ability time for energy regen delay
            this.triggerCooldown();
            
            console.log(`Casted ${this.name}. Energy: ${Math.floor(this.caster.currentEnergy)} / ${this.caster.maxEnergy}`);
            return true;
        }
        return false;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FirefliesAbility.js ===


=== FILE: src/game/abilities/FireflyProjectile.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../../common/CollisionGroups.js';
import { ParticleExplosion } from './ParticleExplosion.js';

export class FireflyProjectile {
    constructor({ caster, target }) {
        this.caster = caster;
        this.target = target;
        this.game = caster.game;
        this.scene = caster.game.renderer.scene; // Use the main game scene
        this.world = caster.world;

        // --- Configuration ---
        this.damage = 100;
        this.lifetime = 5.0;
        this.speed = 18;
        this.homingStrength = 2.5;
        this.isDead = false;
        this.state = 'HOMING'; // State machine: 'HOMING', 'EXPLODING'
        this.preStepHandler = this.applyAntiGravity.bind(this);

        // --- Explosion parameters ---
        this.explosionRadius = 2.5;
        this.explosionDamageRadius = 3.5;
        this.explosionDuration = 0.5;
        this.explosionTimer = 0;
        
        // --- PERFORMANCE: Reusable objects for AOE and Homing ---
        this._aoeExplosionCenter = new THREE.Vector3();
        this._aoeEnemyPosition = new THREE.Vector3();
        this._homingTargetBasePos = new CANNON.Vec3();
        this._homingEffectiveTargetPos = new CANNON.Vec3();
        this._homingDirectionToTarget = new CANNON.Vec3();
        this._homingDesiredVelocity = new CANNON.Vec3();
        this._homingSteeringForce = new CANNON.Vec3();

        // --- Trajectory variation parameters ---
        this.wobblePhase = Math.random() * Math.PI * 2;
        this.wobbleAmplitude = 0.5;
        this.wobbleFrequency = 8;
        this.targetPointOffset = new CANNON.Vec3(
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 1,
            (Math.random() - 0.5) * 2
        ).scale(1.5);

        // --- Visuals (Three.js Mesh and Light) ---
        const geometry = new THREE.SphereGeometry(0.15, 8, 8);
        const material = new THREE.MeshStandardMaterial({
            color: 0xffa500,
            emissive: 0xffa500,
            emissiveIntensity: 5,
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = false;
        this.light = new THREE.PointLight(0xffa500, 150, 10, 2);
        this.mesh.add(this.light);

        // --- Physics (Cannon.js Body) ---
        const shape = new CANNON.Sphere(0.15);
        this.body = new CANNON.Body({
            mass: 0.05,
            shape,
            collisionFilterGroup: COLLISION_GROUPS.PROJECTILE,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY,
            type: CANNON.Body.DYNAMIC,
            linearDamping: 0,
            angularDamping: 0,
        });
        this.body.allowSleep = false;
        
        const playerCamera = this.caster.camera;
        const initialDirection = new THREE.Vector3();
        playerCamera.getWorldDirection(initialDirection);
        const coneSpreadAngle = THREE.MathUtils.degToRad(15);
        const randomAxis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
        const randomQuaternion = new THREE.Quaternion().setFromAxisAngle(randomAxis, (Math.random() - 0.5) * 2 * coneSpreadAngle);
        initialDirection.applyQuaternion(randomQuaternion);
        const initialPosition = new THREE.Vector3();
        playerCamera.getWorldPosition(initialPosition).add(initialDirection.clone().multiplyScalar(0.7));
        this.body.position.copy(initialPosition);
        
        const initialVelocity = new CANNON.Vec3().copy(initialDirection).scale(this.speed);
        this.body.velocity.copy(initialVelocity);

        this.body.addEventListener('collide', (event) => this.onCollide(event));

        this.scene.add(this.mesh);
        this.world.addBody(this.body);
        this.world.addEventListener('preStep', this.preStepHandler);
        this.game.updatables.push(this);
    }

    applyAntiGravity() {
        if (!this.body || this.isDead || this.state !== 'HOMING') return;
        const antiGravity = new CANNON.Vec3(0, -this.world.gravity.y, 0).scale(this.body.mass);
        this.body.applyForce(antiGravity, this.body.position);
    }

    onCollide(event) {
        if (this.state !== 'HOMING') return;
        this.detonate();
    }

    update(deltaTime) {
        if (this.isDead) return;

        switch (this.state) {
            case 'HOMING':
                this.lifetime -= deltaTime;
                if (this.lifetime <= 0) {
                    this.detonate();
                    return;
                }
                this.wobblePhase += deltaTime * this.wobbleFrequency;
                if (this.target && this.target.body && !this.target.isDead) {
                    this._homingTargetBasePos.copy(this.target.body.position);
                    this._homingTargetBasePos.vadd(this.targetPointOffset, this._homingEffectiveTargetPos);

                    const currentWobbleX = Math.sin(this.wobblePhase) * this.wobbleAmplitude;
                    const currentWobbleZ = Math.cos(this.wobblePhase) * this.wobbleAmplitude;
                    this._homingEffectiveTargetPos.x += currentWobbleX;
                    this._homingEffectiveTargetPos.z += currentWobbleZ;

                    const distanceToEffectiveTarget = this.body.position.distanceTo(this._homingEffectiveTargetPos);
                    if (distanceToEffectiveTarget <= this.explosionRadius) {
                        this.detonate();
                        return;
                    }
                    
                    this._homingEffectiveTargetPos.vsub(this.body.position, this._homingDirectionToTarget);
                    this._homingDirectionToTarget.normalize();
                    this._homingDirectionToTarget.scale(this.speed, this._homingDesiredVelocity);

                    this._homingDesiredVelocity.vsub(this.body.velocity, this._homingSteeringForce);
                    this._homingSteeringForce.scale(this.homingStrength * deltaTime, this._homingSteeringForce);
                    this.body.velocity.vadd(this._homingSteeringForce, this.body.velocity);

                    if (this.body.velocity.length() > this.speed) {
                        this.body.velocity.normalize();
                        this.body.velocity.scale(this.speed, this.body.velocity);
                    }
                }
                this.mesh.position.copy(this.body.position);
                this.mesh.quaternion.copy(this.body.quaternion);
                break;

            case 'EXPLODING':
                this.explosionTimer += deltaTime;
                this.light.intensity = THREE.MathUtils.lerp(150, 0, this.explosionTimer / this.explosionDuration);
                if (this.explosionTimer >= this.explosionDuration) {
                    this.cleanup();
                }
                break;
        }
    }

    detonate() {
        if (this.state !== 'HOMING') return;
        
        this.state = 'EXPLODING';
        this.explosionTimer = 0;

        this.game.physics.queueForRemoval(this.body);
        new ParticleExplosion(this.scene, this.mesh.position, this.game.updatables);
        this.applyAoEDamage(this.mesh.position, this.explosionDamageRadius, this.damage);
        this.mesh.visible = false;
    }

    applyAoEDamage(explosionCenter, radius, damageAmount) {
        this._aoeExplosionCenter.copy(explosionCenter);
        for (const enemy of [...this.game.enemies]) { 
            if (enemy && enemy.body && !enemy.isDead) {
                this._aoeEnemyPosition.copy(enemy.body.position);
                const enemyRadius = enemy.body.shapes[0].radius;
                if (this._aoeEnemyPosition.distanceTo(this._aoeExplosionCenter) < radius + enemyRadius) {
                    enemy.takeDamage(damageAmount);
                }
            }
        }
    }

    cleanup() {
        if (this.isDead) return;
        this.isDead = true;

        this.world.removeEventListener('preStep', this.preStepHandler);

        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();

        const updatableIndex = this.game.updatables.indexOf(this);
        if (updatableIndex > -1) {
            this.game.updatables.splice(updatableIndex, 1);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FireflyProjectile.js ===


=== FILE: src/game/abilities/ParticleExplosion.js ===
--------------------------------------------------
import * as THREE from 'three';

export class ParticleExplosion {
    constructor(scene, position, updatables) {
        this.scene = scene;
        this.updatables = updatables; // The central array of objects to update

        this.LIFESPAN = 1.2; // How long the particles last
        this.elapsedTime = 0;
        
        const particleCount = 200;
        const positions = new Float32Array(particleCount * 3);
        this.velocities = [];

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            // All particles start at the center of the explosion
            positions[i3] = 0;
            positions[i3 + 1] = 0;
            positions[i3 + 2] = 0;

            // Create a random direction vector
            const vec = new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
            );
            vec.normalize();
            // Give it a random speed
            vec.multiplyScalar(Math.random() * 15 + 5); 
            this.velocities.push(vec);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
            color: 0xff8800,
            size: 0.2,
            transparent: true,
            blending: THREE.AdditiveBlending, // Makes colors add up for a fiery look
            depthWrite: false, // Prevents particles from occluding each other weirdly
        });

        this.points = new THREE.Points(geometry, material);
        this.points.position.copy(position);
        this.scene.add(this.points);

        // Add this particle system to the central update loop
        this.updatables.push(this);
    }

    update(deltaTime) {
        this.elapsedTime += deltaTime;
        const progress = this.elapsedTime / this.LIFESPAN;

        if (progress >= 1) {
            this.cleanup();
            return;
        }

        // Animate particles outward
        const positions = this.points.geometry.attributes.position.array;
        for (let i = 0; i < this.velocities.length; i++) {
            const i3 = i * 3;
            positions[i3] += this.velocities[i].x * deltaTime;
            positions[i3 + 1] += this.velocities[i].y * deltaTime;
            positions[i3 + 2] += this.velocities[i].z * deltaTime;
        }
        this.points.geometry.attributes.position.needsUpdate = true;
        
        // Fade out the particles over their lifespan
        this.points.material.opacity = 1.0 - progress;
    }

    cleanup() {
        // Remove from scene and free memory
        this.scene.remove(this.points);
        this.points.geometry.dispose();
        this.points.material.dispose();

        // Remove self from the central update loop
        const index = this.updatables.indexOf(this);
        if (index > -1) {
            this.updatables.splice(index, 1);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/ParticleExplosion.js ===


=== FILE: src/game/entities/Enemy.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { HealthBar } from '../ui/HealthBar.js';
import { COLLISION_GROUPS } from '../../common/CollisionGroups.js';
import { EnemyProjectile } from '../abilities/EnemyProjectile.js';
import { DamageNumber } from '../ui/DamageNumber.js';

export class Enemy {
    constructor({ game, name = 'Dummy' }) {
        this.game = game;
        this.scene = game.renderer.scene;
        this.world = game.physics.world;
        this.name = name;
        
        // --- Core Parameters ---
        this.maxHealth = 1000;
        this.currentHealth = this.maxHealth;
        this.speed = 8;
        this.isDead = false;

        // --- Hit Feedback ---
        this.flashDuration = 0.15;
        this.flashTimer = 0;
        this.originalEmissive = null; // Will be set after mesh creation

        // --- AI State & Parameters ---
        this.state = 'IDLE'; // IDLE, SEARCHING, COMBAT
        this.lastKnownPlayerPosition = new THREE.Vector3();
        this.perception = {
            detectionRange: 40,
            loseSightRange: 50,
            attackRange: 30,
            optimalRange: 22,
            minimumRange: 10,
            hasLineOfSight: false,
            distanceToPlayer: Infinity,
        };
        
        // --- PERFORMANCE: AI Throttling ---
        // Stagger AI updates to prevent all enemies from running heavy logic on the same frame.
        this.AI_UPDATE_INTERVAL = 0.1; // Update AI logic 10 times per second
        this.aiUpdateTimer = Math.random() * this.AI_UPDATE_INTERVAL; // Random initial offset

        // --- PERFORMANCE: Reusable Objects to prevent GC churn ---
        this._perceptionRayFrom = new CANNON.Vec3();
        this._perceptionRayTo = new CANNON.Vec3();
        this._lookAtTarget = new THREE.Vector3();
        this._tempQuaternion = new CANNON.Quaternion();
        this._tempObject3D = new THREE.Object3D();

        // --- Combat & Movement Abilities ---
        this.strafeDirection = 1;
        this.strafeDirectionTimer = 0;
        this.turnSpeed = 0.1;
        this.jumpHeight = 8;
        this.jumpCooldown = 2.0;
        this.jumpTimer = this.jumpCooldown;

        this.dashSpeed = 32;
        this.dashDuration = 0.2;
        this.dashCooldown = 2.0;
        this.dashTimer = this.dashCooldown;
        this.isDashing = false;
        this.dashStateTimer = 0;
        this.dashDirection = new THREE.Vector3();
        
        this.attackCooldown = 1.5;
        this.attackTimer = this.attackCooldown;

        this.createMesh();
        this.createPhysicsBody();
        
        if (this.game.player) {
            this.healthBar = new HealthBar(this);
        } else {
            this.healthBar = null;
        }
        
        this.game.updatables.push(this);
    }
    
    createMesh() {
        const geometry = new THREE.CapsuleGeometry(0.7, 1.0, 4, 8);
        const material = new THREE.MeshStandardMaterial({ color: 0x990000, roughness: 0.4 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;
        this.scene.add(this.mesh);

        // Store original material state for hit flash
        this.originalEmissive = new THREE.Color(this.mesh.material.emissive.getHex());
    }

    createPhysicsBody() {
        const shape = new CANNON.Sphere(0.8);
        this.body = new CANNON.Body({
            mass: 80,
            shape,
            fixedRotation: true,
            collisionFilterGroup: COLLISION_GROUPS.ENEMY,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.PLAYER | COLLISION_GROUPS.ENEMY,
        });
        this.world.addBody(this.body);
    }

    spawn(position) {
        this.body.position.set(position.x, position.y, position.z);
        this.body.velocity.set(0, 0, 0);
        this.currentHealth = this.maxHealth;
        this.isDead = false;
        if (this.healthBar) {
            this.healthBar.updateHealth(this.currentHealth, this.maxHealth);
            this.healthBar.setVisible(true);
        }
        this.body.type = CANNON.Body.DYNAMIC;
        this.lastKnownPlayerPosition.copy(position);
    }

    takeDamage(amount) {
        if (this.isDead) return;
        this.currentHealth -= amount;

        // --- Hit Feedback ---
        // 1. Flash effect
        this.mesh.material.emissive.setHex(0xffffff);
        this.flashTimer = this.flashDuration;
        // 2. Floating damage number
        new DamageNumber({
            game: this.game,
            position: new THREE.Vector3().copy(this.body.position).add(new THREE.Vector3(0, 1.5, 0)),
            text: `${Math.floor(amount)}`
        });
        // --- End Hit Feedback ---

        if (this.healthBar) {
            this.healthBar.updateHealth(this.currentHealth, this.maxHealth);
        }
        if (this.currentHealth <= 0) {
            this.currentHealth = 0;
            this.die();
        }
    }

    die(isEditorClear = false) {
        if (this.isDead) return;
        this.isDead = true;

        if (this.healthBar) {
            this.healthBar.setVisible(false);
            this.healthBar.dispose();
        }
        
        if (this.body) this.game.physics.queueForRemoval(this.body);
        
        if (this.mesh) {
            this.scene.remove(this.mesh);
            this.mesh.geometry.dispose();
            this.mesh.material.dispose();
        }

        const enemyIndex = this.game.enemies.indexOf(this);
        if (enemyIndex > -1 && !isEditorClear) {
             this.game.enemies.splice(enemyIndex, 1);
        }
        
        const updatableIndex = this.game.updatables.indexOf(this);
        if (updatableIndex > -1) {
            this.game.updatables.splice(updatableIndex, 1);
        }
    }

    update(deltaTime) {
        if (this.isDead) return;

        // Handle hit flash
        if (this.flashTimer > 0) {
            this.flashTimer -= deltaTime;
            const flashProgress = 1 - Math.max(0, this.flashTimer / this.flashDuration);
            this.mesh.material.emissive.lerpColors(new THREE.Color(0xffffff), this.originalEmissive, flashProgress);
            if (this.flashTimer <= 0) {
                this.mesh.material.emissive.copy(this.originalEmissive);
            }
        }

        if (this.game.player) {
            this.updateTimers(deltaTime);
            
            // --- PERFORMANCE: AI Throttling ---
            this.aiUpdateTimer += deltaTime;
            if (this.aiUpdateTimer >= this.AI_UPDATE_INTERVAL) {
                this.runAI(deltaTime);
                this.aiUpdateTimer = 0;
            }
        }

        // Only update movement/physics every frame if not dashing
        if (!this.isDashing && this.state !== 'IDLE') {
             this.applyMovementBasedOnState();
        }
        
        if (this.body && this.mesh) {
            this.mesh.position.copy(this.body.position);
            this.mesh.quaternion.copy(this.body.quaternion);
        }
    }

    updateTimers(deltaTime) {
        this.jumpTimer += deltaTime;
        this.dashTimer += deltaTime;
        this.attackTimer += deltaTime;
        this.strafeDirectionTimer -= deltaTime;
        if(this.isDashing) this.dashStateTimer += deltaTime;
    }

    // This runs less frequently due to throttling
    runAI(deltaTime) {
        this.updatePerception();
        this.updateState();
        this.executeStateActions(deltaTime);
    }

    updatePerception() {
        const player = this.game.player;
        if (!player || !player.body) return;
        this.perception.distanceToPlayer = this.body.position.distanceTo(player.body.position);
        
        this._perceptionRayFrom.copy(this.body.position);
        this._perceptionRayTo.copy(player.body.position);
        this.perception.hasLineOfSight = !this.world.raycastClosest(
            this._perceptionRayFrom, this._perceptionRayTo, { collisionFilterMask: COLLISION_GROUPS.WORLD, skipBackfaces: true }
        );
        if (this.perception.hasLineOfSight) {
            this.lastKnownPlayerPosition.copy(player.body.position);
        }
    }

    updateState() {
        if (this.perception.hasLineOfSight && this.perception.distanceToPlayer < this.perception.detectionRange) {
            this.state = 'COMBAT';
        } else if (this.state === 'COMBAT' && this.perception.distanceToPlayer > this.perception.loseSightRange) {
            this.state = 'SEARCHING';
        } else if (this.state === 'SEARCHING' && this.body.position.distanceTo(this.lastKnownPlayerPosition) < 2) {
            this.state = 'IDLE';
        }
    }

    // This handles actions based on the current state. It's called by the throttled runAI.
    executeStateActions(deltaTime) {
        if (this.isDashing) {
            if (this.dashStateTimer >= this.dashDuration) this.isDashing = false;
            return;
        }

        this.faceTarget(this.lastKnownPlayerPosition);

        if (this.state === 'COMBAT') {
            this.handleCombatDecisions();
        }
    }
    
    // This is called every frame to apply velocity based on the AI's decided state.
    applyMovementBasedOnState() {
        this.body.wakeUp();

        switch (this.state) {
            case 'IDLE':
                this.body.velocity.x *= 0.9; this.body.velocity.z *= 0.9;
                break;
            case 'SEARCHING':
                const searchDir = new CANNON.Vec3().copy(this.lastKnownPlayerPosition).vsub(this.body.position);
                searchDir.y = 0;
                searchDir.normalize();
                this.body.velocity.x = searchDir.x * this.speed;
                this.body.velocity.z = searchDir.z * this.speed;
                break;
            case 'COMBAT':
                this.repositionDuringCombat();
                break;
        }
    }
    
    handleCombatDecisions() {
        const { distanceToPlayer, hasLineOfSight, attackRange } = this.perception;
        const canShoot = hasLineOfSight && this.attackTimer >= this.attackCooldown;
        const toPlayerDir = new CANNON.Vec3().copy(this.lastKnownPlayerPosition).vsub(this.body.position);
        toPlayerDir.y = 0;

        if (canShoot && distanceToPlayer <= attackRange) {
            this.shoot();
        }

        this.navigateObstacles();
        if (this.dashTimer >= this.dashCooldown && Math.random() < 0.2) { // Increased chance due to less frequent checks
            const right = new THREE.Vector3().crossVectors(toPlayerDir, new THREE.Vector3(0,1,0)).normalize();
            right.multiplyScalar(Math.random() > 0.5 ? 1 : -1);
            this.dash(right);
        }
    }

    repositionDuringCombat() {
        const { distanceToPlayer, optimalRange, minimumRange } = this.perception;
        const toPlayerDir = new CANNON.Vec3().copy(this.lastKnownPlayerPosition).vsub(this.body.position);
        toPlayerDir.y = 0;
        if (toPlayerDir.lengthSquared() > 0) toPlayerDir.normalize();

        if (this.attackTimer < this.attackCooldown / 2) { // Pause briefly after shooting
             this.body.velocity.x *= 0.8;
             this.body.velocity.z *= 0.8;
             return;
        }

        if (distanceToPlayer > optimalRange) {
            this.body.velocity.x = toPlayerDir.x * this.speed;
            this.body.velocity.z = toPlayerDir.z * this.speed;
        } else if (distanceToPlayer < minimumRange) {
            this.body.velocity.x = -toPlayerDir.x * this.speed * 0.8;
            this.body.velocity.z = -toPlayerDir.z * this.speed * 0.8;
        } else {
            if (this.strafeDirectionTimer <= 0) {
                this.strafeDirection = Math.random() > 0.5 ? 1 : -1;
                this.strafeDirectionTimer = Math.random() * 2 + 1.5;
            }
            const rightDir = new CANNON.Vec3(toPlayerDir.z, 0, -toPlayerDir.x);
            this.body.velocity.x = rightDir.x * this.speed * 0.7 * this.strafeDirection;
            this.body.velocity.z = rightDir.z * this.speed * 0.7 * this.strafeDirection;
        }
    }

    faceTarget(targetPosition) {
        this._lookAtTarget.copy(targetPosition);
        this._lookAtTarget.y = this.body.position.y;
        this._tempObject3D.position.copy(this.body.position);
        this._tempObject3D.lookAt(this._lookAtTarget);
        this._tempQuaternion.copy(this._tempObject3D.quaternion);
        this.body.quaternion.slerp(this._tempQuaternion, this.turnSpeed, this.body.quaternion);
    }
    
    navigateObstacles() {
        if (this.body.velocity.lengthSquared() < 0.1) return;

        const moveDirection = new CANNON.Vec3().copy(this.body.velocity);
        moveDirection.normalize();

        const rayFrom = new CANNON.Vec3().copy(this.body.position);
        const rayTo = rayFrom.clone().vadd(moveDirection.scale(2));
        
        if (this.world.raycastClosest(rayFrom, rayTo, { collisionFilterMask: COLLISION_GROUPS.WORLD }, new CANNON.RaycastResult())) {
            if (this.jumpTimer >= this.jumpCooldown) this.jump();
        }
    }
    
    jump() {
        const rayFrom = new CANNON.Vec3().copy(this.body.position);
        const rayTo = rayFrom.clone().vadd(new CANNON.Vec3(0, -1.1, 0));
        if (this.world.raycastClosest(rayFrom, rayTo, {collisionFilterMask: COLLISION_GROUPS.WORLD}, new CANNON.RaycastResult())) {
             this.body.velocity.y = this.jumpHeight;
             this.jumpTimer = 0;
        }
    }

    dash(direction) {
        this.isDashing = true;
        this.dashTimer = 0;
        this.dashStateTimer = 0;
        this.dashDirection.copy(direction).normalize();
        this.dashDirection.y = 0;
        this.dashDirection.normalize();
        this.body.velocity.x = this.dashDirection.x * this.dashSpeed;
        this.body.velocity.y = 0;
        this.body.velocity.z = this.dashDirection.z * this.dashSpeed;
    }

    calculateBallisticLaunchVelocity(startPos, targetPos, projectileSpeed, gravity) {
        const delta = new THREE.Vector3().subVectors(targetPos, startPos);
        const deltaXZ = new THREE.Vector2(delta.x, delta.z);
        const distXZ = deltaXZ.length();
        const v = projectileSpeed, g = gravity, y = delta.y, x = distXZ;
        const discriminant = v**4 - g * (g * x**2 + 2 * y * v**2);
        if (discriminant < 0) return null;
        const angle = Math.atan2(v**2 - Math.sqrt(discriminant), g * x);
        const Vy = v * Math.sin(angle);
        const Vxz = v * Math.cos(angle);
        const dirXZ = deltaXZ.normalize();
        return new THREE.Vector3(dirXZ.x * Vxz, Vy, dirXZ.y * Vxz);
    }

    shoot() {
        this.attackTimer = 0;
        const projectileSpeed = 40;
        const timeToTarget = this.perception.distanceToPlayer / projectileSpeed;
        const playerVelocity = new CANNON.Vec3().copy(this.game.player.body.velocity);
        const predictionTime = Math.min(timeToTarget, 1.0);
        const predictedPosition = new THREE.Vector3().copy(this.lastKnownPlayerPosition).add(
            new THREE.Vector3().copy(playerVelocity).multiplyScalar(predictionTime)
        );
        predictedPosition.y += 0.5;

        const casterPosition = new THREE.Vector3().copy(this.body.position);
        const gravityMagnitude = Math.abs(this.world.gravity.y);
        let launchVelocity = this.calculateBallisticLaunchVelocity(
            casterPosition, predictedPosition, projectileSpeed, gravityMagnitude
        );
        
        if (!launchVelocity) {
            launchVelocity = new THREE.Vector3().subVectors(predictedPosition, casterPosition).normalize().multiplyScalar(projectileSpeed);
        }

        new EnemyProjectile({ caster: this, initialVelocity: launchVelocity });
    }
}
--------------------------------------------------
=== END OF FILE: src/game/entities/Enemy.js ===


=== FILE: src/game/entities/Player.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { FireballAbility } from '../abilities/FireballAbility.js';
import { FirefliesAbility } from '../abilities/FirefliesAbility.js';
import { COLLISION_GROUPS } from '../../common/CollisionGroups.js';
import { Katana } from '../weapons/Katana.js';

export class Player {
    constructor(camera, world, inputManager, scene, game) {
        this.camera = camera;
        this.world = world;
        this.input = inputManager;
        this.scene = scene; // This is the viewModelScene
        this.game = game;

        // --- Core Parameters ---
        this.speed = 8;
        this.jumpHeight = 8;
        this.maxJumps = 2;
        this.spawnPoint = { x: 0, y: 10, z: 0 }; 

        // --- Health & Energy ---
        this.maxHealth = 1000;
        this.currentHealth = this.maxHealth;
        this.maxEnergy = 1000;
        this.currentEnergy = this.maxEnergy;
        this.energyRegenRate = 25;
        this.energyRegenDelay = 5;

        // --- Internal State ---
        this.isDead = false;
        this.jumpsRemaining = 0;
        this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
        this.PI_2 = Math.PI / 2;
        this.isDashing = false;
        this.isSlamming = false;
        this.lastAbilityTime = -this.energyRegenDelay;
        
        // --- Targeting System ---
        this.lockedTarget = null;
        this.maxTargetingRange = 100;
        this.maxAngularDeviation = Math.tan(THREE.MathUtils.degToRad(15)); 

        // --- VFX ---
        this.originalFov = camera.fov;
        this.targetFov = this.originalFov;
        this.vfx = {
            damage: document.getElementById('screen-overlay'),
            dashForward: document.getElementById('vfx-dash-forward'),
            dashSideways: document.getElementById('vfx-dash-sideways'),
            jump: document.getElementById('vfx-jump-wind'),
            slam: document.getElementById('vfx-ground-slam'),
        };

        // --- PERFORMANCE: Reusable Objects ---
        this._targetRayOrigin = new THREE.Vector3();
        this._targetRayDirection = new THREE.Vector3();
        this._enemyPos = new THREE.Vector3();
        this._oToP = new THREE.Vector3();
        this._losRayFrom = new CANNON.Vec3();
        this._losRayTo = new CANNON.Vec3();
        this._forward = new THREE.Vector3();
        this._right = new THREE.Vector3();

        // --- Weapon & Ability Systems ---
        this.weapon = new Katana(this);
        this.abilities = [null, null, null, null];
        this.selectedAbilityIndex = 0;
        this.abilities[0] = new FireballAbility(this);
        this.abilities[1] = new FirefliesAbility(this);

        // --- Movement Mechanics ---
        this.DOUBLE_JUMP_COOLDOWN = 1.5;
        this.doubleJumpOnCooldown = false;
        this.doubleJumpCooldownTimer = this.DOUBLE_JUMP_COOLDOWN;
        this.DASH_SPEED_MULTIPLIER = 4;
        this.DASH_DURATION = 0.2;
        this.DASH_COOLDOWN = 2.0;
        this.DOUBLE_TAP_WINDOW = 300;
        this.dashOnCooldown = false;
        this.dashCooldownTimer = this.DASH_COOLDOWN;
        this.dashTimer = 0;
        this.dashDirection = new THREE.Vector3();
        this.keyLastPress = {};
        this.keyPreviousState = {};

        // --- View Model ---
        this.camera.add(this.weapon.mesh);
        this.scene.add(this.camera);


        this.createPhysicsBody();
        this.setupEventListeners();
        this.setupVFXListeners();
    }
    
    createPhysicsBody() {
        const playerShape = new CANNON.Sphere(0.8);
        const playerMaterial = new CANNON.Material("playerMaterial");
        this.body = new CANNON.Body({
            mass: 70,
            shape: playerShape,
            material: playerMaterial,
            fixedRotation: true,
            collisionFilterGroup: COLLISION_GROUPS.PLAYER,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY | COLLISION_GROUPS.PROJECTILE,
        });

        const worldMaterial = this.world.defaultMaterial;
        const playerWorldContactMaterial = new CANNON.ContactMaterial(worldMaterial, playerMaterial, {
            friction: 0.1,
            restitution: 0.1,
        });
        this.world.addContactMaterial(playerWorldContactMaterial);
        this.world.addBody(this.body);
    }

    setupVFXListeners() {
        Object.values(this.vfx).forEach(element => {
            if (element) {
                element.addEventListener('animationend', () => {
                    element.classList.remove('active', 'right-to-left', 'left-to-right');
                });
            }
        });
    }

    triggerVFX(element, ...classes) {
        if (!element) return;
        // This pattern reliably restarts a CSS animation
        element.classList.remove('active', 'right-to-left', 'left-to-right');
        void element.offsetWidth; // Force reflow
        element.classList.add('active', ...classes);
    }
    
    setupEventListeners() {
        this.world.addEventListener('postStep', () => {
            if (!this.isDead) {
                this.camera.position.copy(this.body.position);
            }
        });

        this.body.addEventListener('collide', (event) => {
            const contactNormal = new CANNON.Vec3();
            if (event.contact.bi.id === this.body.id) {
                event.contact.ni.negate(contactNormal);
            } else {
                contactNormal.copy(event.contact.ni);
            }

            const isGroundContact = contactNormal.dot(CANNON.Vec3.UNIT_Y) > 0.5;

            if (isGroundContact) {
                if (this.isSlamming) {
                    this.triggerVFX(this.vfx.slam);
                    this.isSlamming = false;
                }
                this.jumpsRemaining = this.maxJumps;
                if (!this.doubleJumpOnCooldown) {
                    this.doubleJumpCooldownTimer = this.DOUBLE_JUMP_COOLDOWN;
                }
            }
        });
        
        this.game.renderer.renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
        document.addEventListener('mousedown', (event) => {
            if (document.pointerLockElement) {
                if (event.button === 0) { this.weapon.attack(); } 
                else if (event.button === 2) { this.handleAbilities(true); }
            }
        });
    }
    
    spawn(position) {
        this.isDead = false;
        this.spawnPoint = { ...position };
        this.body.position.set(position.x, position.y, position.z);
        this.body.velocity.set(0, 0, 0);
        this.body.wakeUp();
        this.currentHealth = this.maxHealth;
        this.currentEnergy = this.maxEnergy;
        this.jumpsRemaining = 0;
        this.lastAbilityTime = this.world.time - this.energyRegenDelay;
    }

    takeDamage(amount) {
        if (this.isDead) return;
        this.currentHealth -= amount;
        this.triggerVFX(this.vfx.damage);
        if (this.currentHealth <= 0) {
            this.currentHealth = 0;
            this.die();
        }
    }

    die(isEditorClear = false) {
        if (this.isDead || isEditorClear) return;
        this.isDead = true;
        this.game.handlePlayerDeath();
    }

    updateLook() {
        this.euler.y -= this.input.mouse.movementX * 0.002;
        this.euler.x -= this.input.mouse.movementY * 0.002;
        this.euler.x = Math.max(-this.PI_2, Math.min(this.PI_2, this.euler.x));
        this.camera.quaternion.setFromEuler(this.euler);
        this.input.update();
    }
    
    handleMovementCooldowns(deltaTime) {
        if (this.doubleJumpOnCooldown) {
            this.doubleJumpCooldownTimer += deltaTime;
            if (this.doubleJumpCooldownTimer >= this.DOUBLE_JUMP_COOLDOWN) {
                this.doubleJumpOnCooldown = false;
            }
        }
        if (this.dashOnCooldown) {
            this.dashCooldownTimer += deltaTime;
            if (this.dashCooldownTimer >= this.DASH_COOLDOWN) {
                this.dashOnCooldown = false;
            }
        }
    }

    handleAbilities(shouldCast) {
        if (shouldCast) {
            const selectedAbility = this.abilities[this.selectedAbilityIndex];
            if (selectedAbility) { selectedAbility.cast(); }
        }
    }

    handleEnergyRegen(deltaTime) {
        if (this.world.time - this.lastAbilityTime > this.energyRegenDelay) {
            if (this.currentEnergy < this.maxEnergy) {
                this.currentEnergy = Math.min(this.maxEnergy, this.currentEnergy + this.energyRegenRate * deltaTime);
            }
        }
    }

    handleDash() {
        // Get camera basis vectors
        this.camera.getWorldDirection(this._forward);
        this._forward.y = 0;
        this._forward.normalize();
        this._right.crossVectors(this._forward, new THREE.Vector3(0, 1, 0)).normalize();

        // Project dash direction onto basis vectors
        const dotForward = this.dashDirection.dot(this._forward);
        const dotRight = this.dashDirection.dot(this._right);
        
        // Determine primary dash direction
        if (Math.abs(dotForward) > Math.abs(dotRight)) { // Forward or backward
            this.triggerVFX(this.vfx.dashForward);
            if (dotForward > 0) { // Forward
                this.targetFov = this.originalFov + 15;
            } else { // Backward
                this.targetFov = this.originalFov - 10;
            }
        } else { // Sideways
            if (dotRight > 0) { // Right
                this.triggerVFX(this.vfx.dashSideways, 'right-to-left');
            } else { // Left
                this.triggerVFX(this.vfx.dashSideways, 'left-to-right');
            }
        }
    }
    
    handleMovement(deltaTime) {
        const xInput = (this.input.keys['KeyD'] ? 1 : 0) - (this.input.keys['KeyA'] ? 1 : 0);
        const zInput = (this.input.keys['KeyW'] ? 1 : 0) - (this.input.keys['KeyS'] ? 1 : 0);

        this.camera.getWorldDirection(this._forward);
        this._forward.y = 0;
        this._forward.normalize();
        this._right.crossVectors(this._forward, new THREE.Vector3(0, 1, 0)).normalize();

        const moveDirection = new THREE.Vector3();
        if (zInput) { moveDirection.add(this._forward.clone().multiplyScalar(zInput)); }
        if (xInput) { moveDirection.add(this._right.clone().multiplyScalar(xInput)); }
        
        if (moveDirection.lengthSq() > 0) { moveDirection.normalize(); }

        const now = performance.now();
        ['KeyW', 'KeyA', 'KeyS', 'KeyD'].forEach(key => {
            const isPressed = this.input.keys[key];
            if (isPressed && !this.keyPreviousState[key]) {
                if (now - (this.keyLastPress[key] || 0) < this.DOUBLE_TAP_WINDOW) {
                    if (!this.dashOnCooldown && !this.isDashing) {
                        this.isDashing = true;
                        this.dashOnCooldown = true;
                        this.dashTimer = 0;
                        this.dashCooldownTimer = 0;
                        this.dashDirection.copy(moveDirection).normalize();
                        this.handleDash();
                    }
                }
                this.keyLastPress[key] = now;
            }
            this.keyPreviousState[key] = isPressed;
        });

        if (this.isDashing) {
            this.dashTimer += deltaTime;
            const dashSpeed = this.speed * this.DASH_SPEED_MULTIPLIER;
            this.body.velocity.x = this.dashDirection.x * dashSpeed;
            this.body.velocity.z = this.dashDirection.z * dashSpeed;
            if (this.dashTimer >= this.DASH_DURATION) {
                this.isDashing = false;
            }
        } else {
            this.body.velocity.x = moveDirection.x * this.speed;
            this.body.velocity.z = moveDirection.z * this.speed;
        }

        if (this.input.keys['Space']) {
            if (this.jumpsRemaining > 0) {
                const performJump = () => {
                    this.body.velocity.y = this.jumpHeight;
                    this.jumpsRemaining--;
                    this.triggerVFX(this.vfx.jump);
                };
                if (this.jumpsRemaining === 1 && this.maxJumps === 2) {
                    if (!this.doubleJumpOnCooldown) {
                        this.doubleJumpOnCooldown = true;
                        this.doubleJumpCooldownTimer = 0;
                        performJump();
                    }
                } else {
                    performJump();
                }
            }
            this.input.keys['Space'] = false;
        }

        if (this.input.keys['ShiftLeft']) {
            if (this.jumpsRemaining < this.maxJumps && !this.isSlamming) {
                this.isSlamming = true;
                this.body.velocity.y = -25;
            }
        }
    }

    updateTargetingLogic() {
        this.camera.getWorldPosition(this._targetRayOrigin);
        this.camera.getWorldDirection(this._targetRayDirection);

        let bestEnemy = null;
        let minScore = Infinity;

        for (const enemy of this.game.enemies) { 
            if (enemy.isDead || !enemy.body || !enemy.mesh) continue;
            this._enemyPos.copy(enemy.body.position);
            const enemyHeight = enemy.mesh.geometry?.parameters?.height || 2;
            this._enemyPos.y += enemyHeight / 2;
            const distanceToEnemy = this._targetRayOrigin.distanceTo(this._enemyPos);
            if (distanceToEnemy > this.maxTargetingRange) continue;
            this._oToP.subVectors(this._enemyPos, this._targetRayOrigin).normalize();
            const dotProduct = this._oToP.dot(this._targetRayDirection);
            const angle = Math.acos(Math.min(1, Math.max(-1, dotProduct)));
            const angularDeviation = Math.tan(angle);
            if (angularDeviation < this.maxAngularDeviation) {
                this._losRayFrom.copy(this._targetRayOrigin);
                this._losRayTo.copy(this._enemyPos);
                const hasLineOfSight = !this.world.raycastClosest(
                    this._losRayFrom, this._losRayTo, { collisionFilterMask: COLLISION_GROUPS.WORLD, skipBackfaces: true }
                );
                if (hasLineOfSight) {
                    const score = (angularDeviation * angularDeviation * 100) + distanceToEnemy; 
                    if (score < minScore) {
                        minScore = score;
                        bestEnemy = enemy;
                    }
                }
            }
        }
        this.lockedTarget = bestEnemy;
    }
    
    updateVFX(deltaTime) {
        // FOV Lerping
        if (Math.abs(this.camera.fov - this.targetFov) > 0.01) {
            this.camera.fov = THREE.MathUtils.lerp(this.camera.fov, this.targetFov, deltaTime * 10);
            this.camera.updateProjectionMatrix();
        }
        
        // Return to normal FOV after a dash
        if (!this.isDashing && this.targetFov !== this.originalFov) {
            this.targetFov = this.originalFov;
        }
    }

    update(deltaTime) {
        if (this.isDead) return;

        if (document.pointerLockElement) { this.updateLook(); }

        this.handleMovementCooldowns(deltaTime);
        this.handleEnergyRegen(deltaTime);
        this.handleMovement(deltaTime);
        this.updateTargetingLogic();
        this.weapon.update(deltaTime);
        this.updateVFX(deltaTime);

        for (const ability of this.abilities) {
            if (ability) { ability.update(deltaTime); }
        }

        for (let i = 1; i <= 4; i++) {
            if (this.input.keys[`Digit${i}`]) {
                this.selectedAbilityIndex = i - 1;
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/entities/Player.js ===


=== FILE: src/game/ui/DamageNumber.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Creates a floating text sprite that displays damage dealt, moves upwards, and fades out.
 */
export class DamageNumber {
    constructor({ game, position, text }) {
        this.game = game;
        this.scene = game.renderer.scene;
        this.camera = game.renderer.camera;

        this.lifetime = 1.0;
        this.elapsedTime = 0;
        this.upwardSpeed = 2.0;

        const canvas = this.createCanvas(text);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;

        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
        this.sprite = new THREE.Sprite(material);
        this.sprite.renderOrder = 1000; // Render on top of most things
        this.sprite.scale.set(canvas.width / 100, canvas.height / 100, 1.0);
        this.sprite.position.copy(position);
        
        // Add some random horizontal offset to prevent perfect stacking
        this.sprite.position.x += (Math.random() - 0.5) * 0.5;

        this.scene.add(this.sprite);
        this.game.updatables.push(this);
    }

    /**
     * Creates a canvas element with the styled damage text.
     * @param {string} text - The text to draw.
     * @returns {HTMLCanvasElement}
     */
    createCanvas(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const fontSize = 48;
        context.font = `bold ${fontSize}px Arial`;
        
        const textMetrics = context.measureText(text);
        canvas.width = textMetrics.width + 10;
        canvas.height = fontSize + 10;

        // Canvas context is reset on resize, so re-apply font and styles
        context.font = `bold ${fontSize}px Arial`;
        context.fillStyle = 'rgba(255, 255, 100, 1)'; // Yellowish color for damage
        context.strokeStyle = 'rgba(0, 0, 0, 1)';
        context.lineWidth = 5;
        context.textAlign = 'center';
        
        const x = canvas.width / 2;
        const y = canvas.height / 2 + fontSize / 3;

        context.strokeText(text, x, y);
        context.fillText(text, x, y);

        return canvas;
    }

    update(deltaTime) {
        this.elapsedTime += deltaTime;
        if (this.elapsedTime >= this.lifetime) {
            this.cleanup();
            return;
        }

        // Move upwards
        this.sprite.position.y += this.upwardSpeed * deltaTime;

        // Fade out
        const progress = this.elapsedTime / this.lifetime;
        this.sprite.material.opacity = 1.0 - progress;
    }

    cleanup() {
        this.scene.remove(this.sprite);
        this.sprite.material.map.dispose();
        this.sprite.material.dispose();

        const index = this.game.updatables.indexOf(this);
        if (index > -1) {
            this.game.updatables.splice(index, 1);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/ui/DamageNumber.js ===


=== FILE: src/game/ui/HealthBar.js ===
--------------------------------------------------
import * as THREE from 'three';

export class HealthBar {
    constructor(entity) {
        this.entity = entity;
        this.scene = entity.scene;

        const healthBarGroup = new THREE.Group();

        // Background
        const bgMaterial = new THREE.SpriteMaterial({ color: 0x550000 });
        const bgSprite = new THREE.Sprite(bgMaterial);
        bgSprite.scale.set(1.0, 0.1, 1.0);
        healthBarGroup.add(bgSprite);

        // Foreground
        const fgMaterial = new THREE.SpriteMaterial({ color: 0x00ff00 });
        this.fgSprite = new THREE.Sprite(fgMaterial);
        this.fgSprite.scale.set(1.0, 0.1, 1.0);
        this.fgSprite.position.z = 0.1; // Render on top of background
        healthBarGroup.add(this.fgSprite);

        this.group = healthBarGroup;
        this.group.position.y = 1.5; // Offset above the entity's center
        this.entity.mesh.add(this.group);
    }

    updateHealth(currentHealth, maxHealth) {
        const percent = Math.max(0, currentHealth / maxHealth);
        this.fgSprite.scale.x = percent;
        // The sprite is centered, so we need to shift its position as it scales down.
        this.fgSprite.position.x = -0.5 * (1 - percent);

        if (percent < 0.3) {
            this.fgSprite.material.color.setHex(0xff0000); // Red
        } else if (percent < 0.6) {
            this.fgSprite.material.color.setHex(0xffff00); // Yellow
        } else {
            this.fgSprite.material.color.setHex(0x00ff00); // Green
        }
    }

    setVisible(visible) {
        this.group.visible = visible;
    }

    dispose() {
        this.entity.mesh.remove(this.group);
        this.fgSprite.material.dispose();
        this.group.children[0].material.dispose(); // bg material
    }
}
--------------------------------------------------
=== END OF FILE: src/game/ui/HealthBar.js ===


=== FILE: src/game/ui/HUD.js ===
--------------------------------------------------
import * as THREE from 'three';

export class HUD {
    constructor(player, game) {
        this.player = player;
        this.game = game;
        this.overlayElement = document.getElementById('screen-overlay');

        // Resource Bars
        this.healthBarElement = document.getElementById('health-bar');
        this.healthTextElement = document.getElementById('health-text');
        this.energyBarElement = document.getElementById('energy-bar');
        this.energyTextElement = document.getElementById('energy-text');

        // Movement Cooldowns
        this.doubleJumpBarElement = document.getElementById('double-jump-bar');
        this.dashBarElement = document.getElementById('dash-bar');
        
        // Ability Slots
        this.abilitySlots = [];
        for (let i = 0; i < 4; i++) {
            const slot = document.getElementById(`ability-${i}`);
            this.abilitySlots.push({
                element: slot,
                icon: slot.querySelector('.ability-icon'),
                cooldownOverlay: slot.querySelector('.ability-cooldown-overlay'),
            });
        }

        // Target Info Elements
        this.targetInfoElement = document.getElementById('target-info');
        this.targetNameElement = document.getElementById('target-name');
        this.targetHealthBarContainer = document.getElementById('target-health-bar-container');
        this.targetHealthBarElement = document.getElementById('target-health-bar');
        this.targetHealthTextElement = document.getElementById('target-health-text');
        
        // 2D Target Frame Element
        this.targetFrameElement = document.getElementById('target-frame');
        this.targetVector = new THREE.Vector3(); // Re-use vector to avoid GC churn

        // Tutorial Text Elements
        this.tutorialTextContainer = document.getElementById('tutorial-text-container');
        this.tutorialTextElement = document.getElementById('tutorial-text');
        this.tutorialTimer = null;

        if (!this.healthBarElement || !this.energyBarElement || !this.abilitySlots[3].element || !this.targetInfoElement || !this.targetFrameElement || !this.tutorialTextContainer) {
            console.error("Required HUD elements not found in the DOM!");
        }
    }

    update() {
        if (!this.player) return;
        this.updateResourceBars();
        this.updateMovementCooldowns();
        this.updateAbilitySlots();
        this.updateTargetInfo();
    }

    showTutorialText(message, duration) {
        if (this.tutorialTimer) clearTimeout(this.tutorialTimer);

        this.tutorialTextElement.innerHTML = message; // Use innerHTML to support kbd tags if needed
        this.tutorialTextContainer.style.opacity = '1';
        this.tutorialTextContainer.style.display = 'block';
        
        this.tutorialTimer = setTimeout(() => {
            this.hideTutorialText();
        }, duration * 1000);
    }

    hideTutorialText() {
        this.tutorialTextContainer.style.opacity = '0';
        // Use a timeout to hide the element after the transition ends
        setTimeout(() => {
            this.tutorialTextContainer.style.display = 'none';
        }, 500); // Must match the CSS transition duration
    }

    updateResourceBars() {
        // Health
        const healthPercent = (this.player.currentHealth / this.player.maxHealth) * 100;
        this.healthBarElement.style.width = `${healthPercent}%`;
        this.healthTextElement.textContent = `${Math.ceil(this.player.currentHealth)} / ${this.player.maxHealth}`;

        // Energy
        const energyPercent = (this.player.currentEnergy / this.player.maxEnergy) * 100;
        this.energyBarElement.style.width = `${energyPercent}%`;
        this.energyTextElement.textContent = `${Math.floor(this.player.currentEnergy)} / ${this.player.maxEnergy}`;
        
        if (energyPercent < 25) this.energyBarElement.style.backgroundColor = '#ff4757';
        else if (energyPercent < 50) this.energyBarElement.style.backgroundColor = '#ffa502';
        else this.energyBarElement.style.backgroundColor = '#2ed573';
    }

    updateMovementCooldowns() {
        const djReady = !this.player.doubleJumpOnCooldown;
        this.doubleJumpBarElement.style.width = djReady ? '100%' : `${(this.player.doubleJumpCooldownTimer / this.player.DOUBLE_JUMP_COOLDOWN) * 100}%`;
        djReady && this.player.jumpsRemaining > 0 ? this.doubleJumpBarElement.classList.remove('on-cooldown') : this.doubleJumpBarElement.classList.add('on-cooldown');
        
        const dashReady = !this.player.dashOnCooldown;
        this.dashBarElement.style.width = dashReady ? '100%' : `${(this.player.dashCooldownTimer / this.player.DASH_COOLDOWN) * 100}%`;
        dashReady ? this.dashBarElement.classList.remove('on-cooldown') : this.dashBarElement.classList.add('on-cooldown');
    }

    updateAbilitySlots() {
        for (let i = 0; i < this.abilitySlots.length; i++) {
            const slotUI = this.abilitySlots[i];
            const ability = this.player.abilities[i];

            if (ability) {
                slotUI.icon.textContent = ability.icon;
                const cooldownProgress = ability.getCooldownProgress();
                slotUI.cooldownOverlay.style.height = `${(1 - cooldownProgress) * 100}%`;
            } else {
                slotUI.icon.textContent = '';
                slotUI.cooldownOverlay.style.height = '0%';
            }

            if (i === this.player.selectedAbilityIndex) {
                slotUI.element.classList.add('selected');
            } else {
                slotUI.element.classList.remove('selected');
            }
        }
    }

    // REWORKED: Function to update target info panel and 2D frame
    updateTargetInfo() {
        const target = this.player.lockedTarget;

        if (target && !target.isDead) {
            // --- Update Target Info Panel ---
            this.targetInfoElement.style.display = 'flex';
            this.targetNameElement.textContent = target.name || 'Enemy';
            
            const healthPercent = (target.currentHealth / target.maxHealth) * 100;
            this.targetHealthBarElement.style.width = `${healthPercent}%`;
            this.targetHealthTextElement.textContent = `${Math.ceil(target.currentHealth)} / ${target.maxHealth}`;

            if (healthPercent < 30) {
                this.targetHealthBarElement.style.backgroundColor = '#ff4757'; // Red
            } else if (healthPercent < 60) {
                this.targetHealthBarElement.style.backgroundColor = '#ffa502'; // Orange
            } else {
                this.targetHealthBarElement.style.backgroundColor = '#2ed573'; // Green
            }

            // --- Update 2D Target Frame ---
            const targetPosition = this.targetVector.copy(target.body.position);
            // Aim for the center of the enemy's mesh
            const enemyHeight = target.mesh.geometry?.parameters?.height || 2;
            targetPosition.y += enemyHeight / 2;
            
            // Project 3D world space to 2D screen space
            targetPosition.project(this.game.renderer.camera);
            
            // Check if target is in front of the camera
            if (targetPosition.z < 1) {
                const x = (targetPosition.x * 0.5 + 0.5) * window.innerWidth;
                const y = (targetPosition.y * -0.5 + 0.5) * window.innerHeight;

                this.targetFrameElement.style.display = 'block';
                this.targetFrameElement.style.left = `${x}px`;
                this.targetFrameElement.style.top = `${y}px`;

                // Scale the frame based on distance from camera
                const distance = this.player.camera.position.distanceTo(target.body.position);
                const frameSize = Math.max(30, Math.min(150, 4000 / distance)); // Clamp size
                this.targetFrameElement.style.width = `${frameSize}px`;
                this.targetFrameElement.style.height = `${frameSize}px`;
            } else {
                this.targetFrameElement.style.display = 'none';
            }
        } else {
            // Hide all target info if no target or target is dead
            this.targetInfoElement.style.display = 'none';
            this.targetFrameElement.style.display = 'none';
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/ui/HUD.js ===


=== FILE: src/game/ui/TutorialManager.js ===
--------------------------------------------------
import * as CANNON from 'cannon-es';
import * as THREE from 'three';

export class TutorialManager {
    constructor(game) {
        this.game = game;
        this.world = game.physics.world;
        this.scene = game.renderer.scene;
        this.hud = game.hud;
        this.triggers = []; // Now stores {mesh, body}
        this.collisionHandler = this.onPlayerCollide.bind(this);
    }

    loadTriggers(triggersData) {
        this.clearTriggers();
        if (!triggersData || triggersData.length === 0) return;

        triggersData.forEach(data => {
            // --- Visual Mesh ---
            const geometry = new THREE.BoxGeometry(...data.size);
            const material = new THREE.MeshBasicMaterial({
                color: parseInt(data.color || "0xffffff", 16),
                transparent: true,
                opacity: 0.25,
                depthWrite: false, // Prevents weird rendering artifacts with other transparent objects
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(data.position.x, data.position.y, data.position.z);
            this.scene.add(mesh);
            
            // --- Physics Body ---
            const shape = new CANNON.Box(new CANNON.Vec3(data.size[0] / 2, data.size[1] / 2, data.size[2] / 2));
            const body = new CANNON.Body({
                type: CANNON.Body.STATIC,
                isTrigger: true // Player can pass through, but it still detects collision
            });
            body.addShape(shape);
            body.position.copy(mesh.position);
            
            // Attach our custom data to the physics body
            body.tutorialData = {
                message: data.message,
                duration: data.duration || 5,
                hasFired: false
            };
            
            this.world.addBody(body);
            this.triggers.push({ mesh, body });
        });
        
        // Listen for collisions on the player's body
        this.game.player.body.addEventListener('collide', this.collisionHandler);
    }

    onPlayerCollide(event) {
        const contactBody = event.body;
        const tutorialData = contactBody.tutorialData;

        if (tutorialData && !tutorialData.hasFired) {
            this.hud.showTutorialText(tutorialData.message, tutorialData.duration);
            tutorialData.hasFired = true; // Fire only once

            // Find the corresponding mesh and make it fade out
            const trigger = this.triggers.find(t => t.body === contactBody);
            if (trigger && trigger.mesh) {
                // Simple fade out effect
                let currentOpacity = trigger.mesh.material.opacity;
                const fadeInterval = setInterval(() => {
                    currentOpacity -= 0.05;
                    if (currentOpacity <= 0) {
                        trigger.mesh.visible = false;
                        clearInterval(fadeInterval);
                    } else {
                        trigger.mesh.material.opacity = currentOpacity;
                    }
                }, 20);
            }
        }
    }

    clearTriggers() {
        if (this.game.player?.body) {
            this.game.player.body.removeEventListener('collide', this.collisionHandler);
        }
        this.triggers.forEach(({ mesh, body }) => {
            this.scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
            this.world.removeBody(body)
        });
        this.triggers = [];
    }
}
--------------------------------------------------
=== END OF FILE: src/game/ui/TutorialManager.js ===


=== FILE: src/game/weapons/Katana.js ===
--------------------------------------------------
import * as THREE from 'three';
import { Weapon } from './Weapon.js';

export class Katana extends Weapon {
    constructor(wielder) {
        super(wielder, {
            name: 'Katana',
            damage: 250,
            cooldown: 0.6,
        });

        // --- Melee Parameters ---
        this.swingRange = 4.0;
        
        // --- Animation Parameters ---
        this.isSwinging = false;
        this.swingProgress = 0;
        this.swingDuration = 0.4; // A bit longer for a more complex animation
        // Damage is applied ~100ms into the animation, during the fastest part of the slash
        this.hitTiming = 100;
        
        // --- PERFORMANCE & Animation State: Reusable objects ---
        this._hitCheckPos = new THREE.Vector3();
        this._enemyPos = new THREE.Vector3();
        this._forward = new THREE.Vector3();

        // --- Define Keyframes for the Swing Animation ---
        // Idle pose (default)
        this.idlePosition = new THREE.Vector3(0.4, -0.4, -0.8);
        this.idleRotation = new THREE.Euler(0, -Math.PI / 12, Math.PI / 24, 'YXZ');
        
        // Start of the swing (wind-up pose, bottom-right)
        this.swingStartPosition = new THREE.Vector3(0.6, -0.6, -0.5);
        this.swingStartRotation = new THREE.Euler(Math.PI / 8, Math.PI / 3, -Math.PI / 6, 'YXZ');

        // End of the swing (follow-through pose, top-left)
        this.swingEndPosition = new THREE.Vector3(-0.4, -0.1, -0.6);
        this.swingEndRotation = new THREE.Euler(-Math.PI / 6, -Math.PI / 2, Math.PI / 4, 'YXZ');

        // Pre-calculate quaternions to avoid re-creation in the update loop
        this.qIdle = new THREE.Quaternion().setFromEuler(this.idleRotation);
        this.qSwingStart = new THREE.Quaternion().setFromEuler(this.swingStartRotation);
        this.qSwingEnd = new THREE.Quaternion().setFromEuler(this.swingEndRotation);

        this.createMesh();
        // Set initial state
        this.mesh.position.copy(this.idlePosition);
        this.mesh.quaternion.copy(this.qIdle);
    }

    createMesh() {
        this.mesh = new THREE.Group();

        const bladeMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.9, roughness: 0.3 });
        const bladeGeom = new THREE.BoxGeometry(0.04, 0.9, 0.01); 
        const blade = new THREE.Mesh(bladeGeom, bladeMat);
        blade.position.y = 0.45;
        blade.castShadow = true;

        const guardMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6, roughness: 0.5 });
        const guardGeom = new THREE.BoxGeometry(0.06, 0.02, 0.15);
        const guard = new THREE.Mesh(guardGeom, guardMat);
        guard.position.y = 0;
        guard.castShadow = true;

        const hiltMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
        const hiltGeom = new THREE.CylinderGeometry(0.025, 0.02, 0.25, 8);
        const hilt = new THREE.Mesh(hiltGeom, hiltMat);
        hilt.position.y = -0.125;
        hilt.castShadow = true;
        
        this.mesh.add(blade, guard, hilt);
    }

    attack() {
        if (!this.canAttack() || this.isSwinging) return false;

        this.isSwinging = true;
        this.swingProgress = 0;
        this.triggerCooldown();

        setTimeout(() => {
            this.detectHit();
        }, this.hitTiming);

        return true;
    }

    update(deltaTime) {
        super.update(deltaTime); // Update cooldown timer

        if (this.isSwinging) {
            this.swingProgress += deltaTime;
            const totalProgress = Math.min(this.swingProgress / this.swingDuration, 1.0);

            // Define animation phases by their end points (e.g., wind-up ends at 15% of total duration)
            const windUpEnd = 0.15;
            const slashEnd = 0.50; // Wind-up (0.15) + Slash (0.35)

            let phaseProgress;

            if (totalProgress < windUpEnd) {
                // Phase 1: Wind-up (Idle -> Start)
                phaseProgress = totalProgress / windUpEnd;
                // Ease-out makes the wind-up start fast and settle into the pose
                const easeProgress = 1 - Math.pow(1 - phaseProgress, 2);
                this.mesh.position.lerpVectors(this.idlePosition, this.swingStartPosition, easeProgress);
                this.mesh.quaternion.copy(this.qIdle).slerp(this.qSwingStart, easeProgress);

            } else if (totalProgress < slashEnd) {
                // Phase 2: Slash (Start -> End)
                phaseProgress = (totalProgress - windUpEnd) / (slashEnd - windUpEnd);
                // Ease-out quart makes for a very fast, snappy slash
                const easeProgress = 1 - Math.pow(1 - phaseProgress, 4);
                this.mesh.position.lerpVectors(this.swingStartPosition, this.swingEndPosition, easeProgress);
                this.mesh.quaternion.copy(this.qSwingStart).slerp(this.qSwingEnd, easeProgress);

            } else {
                // Phase 3: Recovery (End -> Idle)
                phaseProgress = (totalProgress - slashEnd) / (1.0 - slashEnd);
                // Ease-in makes the recovery smooth
                const easeProgress = phaseProgress * phaseProgress;
                this.mesh.position.lerpVectors(this.swingEndPosition, this.idlePosition, easeProgress);
                this.mesh.quaternion.copy(this.qSwingEnd).slerp(this.qIdle, easeProgress);
            }

            if (totalProgress >= 1.0) {
                this.isSwinging = false;
                this.mesh.position.copy(this.idlePosition);
                this.mesh.quaternion.copy(this.qIdle);
            }
        }
    }

    detectHit() {
        const camera = this.wielder.camera;
        camera.getWorldDirection(this._forward);
        
        const playerPos = this.wielder.body.position;

        for (const enemy of this.wielder.game.enemies) {
            if (enemy.isDead || !enemy.body) continue;

            this._enemyPos.copy(enemy.body.position);
            const distance = playerPos.distanceTo(this._enemyPos);

            if (distance < this.swingRange + enemy.body.shapes[0].radius) {
                const toEnemy = this._enemyPos.clone().sub(playerPos).normalize();
                const dot = this._forward.dot(toEnemy);
                
                // cos(50 degrees) ~= 0.64, a generous frontal cone for the swing
                if (dot > 0.64) { 
                    enemy.takeDamage(this.damage);
                    // To prevent hitting multiple enemies with one swing, we break.
                    // Remove this for a cleave effect.
                    break;
                }
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/Katana.js ===


=== FILE: src/game/weapons/Weapon.js ===
--------------------------------------------------
export class Weapon {
    constructor(wielder, { name, damage, cooldown }) {
        this.wielder = wielder;
        this.name = name || 'Unnamed Weapon';
        this.damage = damage || 10;
        this.cooldown = cooldown || 0.5;
        this.cooldownTimer = this.cooldown;
        this.mesh = null; // To be created by subclasses
    }

    canAttack() {
        return this.cooldownTimer >= this.cooldown;
    }

    attack() {
        throw new Error("Weapon.attack() must be implemented by subclasses.");
    }

    triggerCooldown() {
        this.cooldownTimer = 0;
    }

    update(deltaTime) {
        if (this.cooldownTimer < this.cooldown) {
            this.cooldownTimer += deltaTime;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/Weapon.js ===


=== FILE: src/world/LevelLoader.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../common/CollisionGroups.js';
import { Enemy } from '../game/entities/Enemy.js';

export class LevelLoader {
    constructor(game) {
        this.game = game;
        this.scene = game.renderer.scene;
        this.world = game.physics.world;
        this.spawnPoint = null;
        this.deathSpawnPoint = null;
    }

    async load(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Failed to load level: ${response.statusText}`);
        }
        const data = await response.json();
        this.spawnPoint = data.spawnPoint;
        this.deathSpawnPoint = data.deathSpawnPoint;
        return data;
    }

    getSpawnPoint() {
        return this.spawnPoint || { x: 0, y: 10, z: 0 };
    }

    getDeathSpawnPoint() {
        return this.deathSpawnPoint;
    }

    build(levelData) {
        // Skybox and Fog
        this.scene.background = new THREE.Color(parseInt(levelData.settings.backgroundColor || "0x000000", 16));
        this.scene.fog = new THREE.Fog(parseInt(levelData.settings.fogColor, 16), levelData.settings.fogNear, levelData.settings.fogFar);
        
        // Clean old lights
        this.scene.children.filter(c => c.isLight).forEach(l => this.scene.remove(l));
        
        // Ambient
        const ambientLight = new THREE.AmbientLight(parseInt(levelData.settings.ambientLight.color, 16), levelData.settings.ambientLight.intensity);
        this.scene.add(ambientLight);
        
        // Directional Lights
        const directionalLights = [];
        // Ensure directionalLights array exists on settings for new levels
        if (!levelData.settings.directionalLights) {
            levelData.settings.directionalLights = [];
        }
        const lightDefs = levelData.settings.directionalLights;

        // Backwards compatibility for old single-light format
        if (levelData.settings.directionalLight && lightDefs.length === 0) {
            lightDefs.push(levelData.settings.directionalLight);
        }

        lightDefs.forEach(lightData => {
            const light = this.createDirectionalLight(lightData);
            directionalLights.push(light);
        });

        const levelObjects = [];
        const enemies = [];

        levelData.objects.forEach(objData => {
            const obj = this.createObject(objData);
            levelObjects.push(obj);
        });

        if (levelData.enemies) {
            levelData.enemies.forEach(enemyData => {
                const enemy = this.createEnemy(enemyData);
                enemies.push(enemy);
            });
        }
        
        // Return triggers to be handled by the TutorialManager
        return { levelObjects, enemies, ambientLight, directionalLights, triggers: levelData.triggers };
    }

    createDirectionalLight(lightData) {
        const light = new THREE.DirectionalLight(parseInt(lightData.color, 16), lightData.intensity);
        light.position.set(lightData.position.x, lightData.position.y, lightData.position.z);
        light.castShadow = true;
        light.userData.definition = lightData; 
        this.scene.add(light);
        return light;
    }

    createObject(objData) {
        let mesh, body, shape;
        const mat = new THREE.MeshStandardMaterial({
            color: objData.material ? parseInt(objData.material.color, 16) : 0xcccccc,
            roughness: (objData.material && objData.material.roughness) || 0.8
        });

        const size = objData.size || [1, 1, 1];

        if (objData.type === 'Plane') {
            mesh = new THREE.Mesh(new THREE.PlaneGeometry(size[0], size[1]), mat);
            shape = new CANNON.Plane();
        } else { // Default to Box
            mesh = new THREE.Mesh(new THREE.BoxGeometry(...size), mat);
            const halfExtents = new CANNON.Vec3(size[0] / 2, size[1] / 2, size[2] / 2);
            shape = new CANNON.Box(halfExtents);
        }
        
        const mass = (objData.physics && objData.physics.mass) || 0;
        body = new CANNON.Body({
            type: mass > 0 ? CANNON.Body.DYNAMIC : CANNON.Body.STATIC,
            mass: mass,
            shape: shape,
            collisionFilterGroup: COLLISION_GROUPS.WORLD
        });
        
        const position = objData.position || {x:0, y:5, z:0};
        mesh.position.set(position.x, position.y, position.z);
        body.position.copy(mesh.position);
        
        if (objData.rotation) {
            mesh.rotation.set(
                THREE.MathUtils.degToRad(objData.rotation.x || 0),
                THREE.MathUtils.degToRad(objData.rotation.y || 0),
                THREE.MathUtils.degToRad(objData.rotation.z || 0)
            );
            body.quaternion.copy(mesh.quaternion);
        }
        
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        this.scene.add(mesh);
        this.world.addBody(body);

        const levelObject = { mesh, body, definition: objData };
        levelObject.userData = { gameEntity: { type: 'Object', entity: levelObject } };
        mesh.userData.gameEntity = levelObject.userData.gameEntity;
        
        return levelObject;
    }

    createEnemy(enemyData) {
        const enemy = new Enemy({ game: this.game, name: enemyData.name || 'Dummy' });
        enemy.spawn(enemyData.position);
        
        enemy.definition = enemyData; // Definition attached directly to the instance
        enemy.userData = { gameEntity: { type: 'Enemy', entity: enemy } };
        enemy.mesh.userData.gameEntity = enemy.userData.gameEntity;
        return enemy;
    }
}
--------------------------------------------------
=== END OF FILE: src/world/LevelLoader.js ===


================================================================================
Snapshot Complete.
