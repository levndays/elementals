Flutter Project Snapshot (Python Script)
Project Root: C:\Users\levndays\Desktop\elementals
Snapshot created on: 2025-06-29T13:41:01.895758
================================================================================

=== FILE: create_snapshot.py ===
--------------------------------------------------
[Content Omitted - Generated/Tooling File]

--------------------------------------------------
=== END OF FILE: create_snapshot.py ===


=== FILE: editor.html ===
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elementals - Level Editor</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:,">
</head>
<body>
    <canvas id="game-canvas"></canvas>
    
    <div id="editor-ui">
        <!-- TOP TOOLBAR -->
        <div id="editor-toolbar">
            <div class="toolbar-group">
                <button id="editor-load-btn" title="Load Level (.json)">Load</button>
                <input type="file" id="editor-file-input" accept=".json" style="display: none;">
                <button id="editor-save-btn" title="Save Level (.json)">Save</button>
                <button id="editor-info-btn" title="Player Metrics Info">Info</button>
            </div>
            <div class="separator"></div>
            <div class="toolbar-group">
                <button id="editor-mode-translate" class="active" title="Translate (T)">T</button>
                <button id="editor-mode-rotate" title="Rotate (R)">R</button>
                <button id="editor-mode-scale" title="Scale (S)">S</button>
            </div>
        </div>

        <!-- MAIN SCROLLABLE PANEL -->
        <div id="editor-main-panel">
            <!-- SCENE SETTINGS -->
            <details class="editor-accordion" open>
                <summary>Scene</summary>
                <div class="accordion-content">
                    <label>Skybox Color</label>
                    <input type="color" id="skybox-color-input">
                    <hr>
                    <h4>Ambient Light</h4>
                    <label>Color</label>
                    <input type="color" id="ambient-color-input">
                    <label>Intensity</label>
                    <input type="range" id="ambient-intensity-input" min="0" max="5" step="0.1">
                </div>
            </details>

            <!-- CREATE -->
            <details class="editor-accordion" open>
                <summary>Create</summary>
                <div class="accordion-content">
                    <h4>Geometry & Actors</h4>
                    <button id="editor-add-box">Add Box</button>
                    <button id="editor-add-enemy">Add Enemy</button>
                    <button id="add-dirlight-btn">Add Directional Light</button>
                    <h4>Volumes & Triggers</h4>
                    <button id="editor-add-msg-trigger">Add Message Trigger</button>
                    <button id="editor-add-death-trigger">Add Death Zone</button>
                    <hr>
                    <h4>Scene Points</h4>
                    <button id="editor-set-spawn">Set Initial Spawn to Camera</button>
                    <button id="editor-set-death-spawn">Set Death Spawn to Camera</button>
                </div>
            </details>
            
            <!-- VIEW OPTIONS -->
            <details class="editor-accordion">
                <summary>View Options</summary>
                <div class="accordion-content">
                    <div class="checkbox-row">
                        <input type="checkbox" id="view-toggle-msg-triggers" checked>
                        <label for="view-toggle-msg-triggers">Message Triggers</label>
                    </div>
                    <div class="checkbox-row">
                        <input type="checkbox" id="view-toggle-death-triggers" checked>
                        <label for="view-toggle-death-triggers">Death Zones</label>
                    </div>
                    <div class="checkbox-row">
                        <input type="checkbox" id="view-toggle-light-helpers" checked>
                        <label for="view-toggle-light-helpers">Light Helpers</label>
                    </div>
                     <div class="checkbox-row">
                        <input type="checkbox" id="view-toggle-spawn-helpers" checked>
                        <label for="view-toggle-spawn-helpers">Spawn Helpers</label>
                    </div>
                </div>
            </details>

            <!-- OUTLINER -->
            <details class="editor-accordion" open>
                <summary>Outliner</summary>
                <div class="accordion-content" id="outliner-list">
                    <!-- Dynamically populated -->
                </div>
            </details>

            <!-- PROPERTIES -->
            <details class="editor-accordion" id="properties-accordion" style="display: none;">
                <summary>Properties</summary>
                <div class="accordion-content" id="properties-content">
                    <!-- Dynamically populated based on selection -->
                </div>
                <button id="editor-delete-btn" class="delete-button">Delete Selected</button>
            </details>
        </div>
    </div>

    <!-- INFO MODAL -->
    <div id="editor-info-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <span class="modal-close-btn">×</span>
            <h3>Player Movement Metrics</h3>
            <pre id="info-modal-text"></pre>
        </div>
    </div>


    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
            "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>
    
    <script type="module" src="src/editor_main.js"></script>
</body>
</html>
--------------------------------------------------
=== END OF FILE: editor.html ===


=== FILE: index.html ===
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELEMENTALS</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:,">
</head>
<body>
    <!-- Menu System (wrapper) -->
    <div id="menu-system">
        <!-- Main Menu -->
        <div id="main-menu" class="menu-screen">
            <h1>ELEMENTALS</h1>
            <div class="menu-options">
                <button id="play-btn">Play</button>
                <button id="tutorial-btn">How to Play</button>
            </div>
        </div>
        <!-- Level Select -->
        <div id="level-select-menu" class="menu-screen" style="display: none;">
            <h2>Select Level</h2>
            <div id="level-list" class="menu-list">
                <!-- Dynamically populated -->
            </div>
            <button class="back-button" data-target="main-menu">Back</button>
        </div>
        <!-- Pause Menu -->
        <div id="pause-menu" class="menu-screen" style="display: none;">
            <h2>Paused</h2>
            <div class="menu-options">
                <button id="resume-btn">Resume</button>
                <button id="pause-quit-btn">Quit to Menu</button>
            </div>
        </div>
        <!-- Death Screen -->
        <div id="death-screen" class="menu-screen" style="display: none;">
            <h2>YOU DIED</h2>
            <p id="respawn-timer-text">Respawning in 5...</p>
            <div class="menu-options">
                <button id="death-quit-btn">Return to Menu</button>
            </div>
        </div>
    </div>


    <!-- In-Game UI & VFX -->
    <div id="screen-overlay"></div>
    <div id="vfx-dash-forward"></div>
    <div id="vfx-dash-sideways"></div>
    <div id="vfx-jump-wind"></div>
    <div id="vfx-ground-slam"></div>
    <div id="target-frame"></div>
    <div id="tutorial-text-container" style="display: none;">
        <p id="tutorial-text"></p>
    </div>
    <div id="crosshair"></div>

    <canvas id="game-canvas"></canvas>

    <!-- Game HUD -->
    <div id="game-hud">
        <div id="hud-bottom-left">
            <div id="health-bar-container" class="resource-bar-container">
                <div id="health-bar"></div>
                <span id="health-text" class="resource-text"></span>
            </div>
            <div id="ability-cooldowns">
                <div class="cooldown-container">
                    <div id="double-jump-bar" class="cooldown-bar"></div>
                    <span class="cooldown-label">JUMP</span>
                </div>
                <div class="cooldown-container">
                    <div id="dash-bar" class="cooldown-bar"></div>
                    <span class="cooldown-label">DASH</span>
                </div>
            </div>
        </div>
        <div id="hud-bottom-center">
            <div id="target-info">
                <span id="target-name"></span>
                <div id="target-health-bar-container" class="resource-bar-container">
                    <div id="target-health-bar"></div>
                    <span id="target-health-text" class="resource-text"></span>
                </div>
            </div>
            <div id="abilities-container">
                <div id="ability-0" class="ability-slot"><span class="ability-icon"></span><div class="ability-cooldown-overlay"></div></div>
                <div id="ability-1" class="ability-slot"><span class="ability-icon"></span><div class="ability-cooldown-overlay"></div></div>
                <div id="ability-2" class="ability-slot"><span class="ability-icon"></span><div class="ability-cooldown-overlay"></div></div>
                <div id="ability-3" class="ability-slot"><span class="ability-icon"></span><div class="ability-cooldown-overlay"></div></div>
            </div>
        </div>
        <div id="hud-bottom-right">
            <div id="energy-bar-container" class="resource-bar-container">
                <div id="energy-bar"></div>
                <span id="energy-text" class="resource-text"></span>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
            "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>
    
    <script type="module" src="src/main.js"></script>
</body>
</html>
--------------------------------------------------
=== END OF FILE: index.html ===


=== FILE: style.css ===
--------------------------------------------------
body {
    margin: 0;
    overflow: hidden;
    background-color: #000;
    color: white;
    font-family: 'Consolas', 'Courier New', monospace;
    cursor: default;
}
#game-canvas { display: block; }

#screen-overlay {
    position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
    background-image: radial-gradient(circle at 50% 50%, transparent 50%, rgba(200, 0, 0, 0.9) 85%);
    pointer-events: none; z-index: 100; opacity: 0;
}
#screen-overlay.active {
    animation: damage-effect 0.3s ease-out forwards;
}
@keyframes damage-effect {
    0% { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(1.3); }
}

#vfx-dash-forward, #vfx-dash-sideways, #vfx-jump-wind {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 99; opacity: 0;
}

#vfx-dash-forward {
    background: radial-gradient(ellipse at center, transparent 30%, rgba(200, 220, 255, 0.3) 100%);
    mask-image: radial-gradient(circle at center, black 40%, transparent 60%);
    transform: scale(1.5);
}
#vfx-dash-forward.active {
    animation: dash-forward-effect 0.3s ease-out forwards;
}
@keyframes dash-forward-effect {
    from { opacity: 1; transform: scale(1); mask-size: 100%; }
    to { opacity: 0; transform: scale(1.5); mask-size: 300%;}
}

/* --- REWORKED: SIDE DASH --- */
#vfx-dash-sideways::before,
#vfx-dash-sideways::after {
    content: '';
    position: absolute;
    top: 50%;
    height: 2px;
    width: 40vw; /* Length of the streak */
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.9) 70%, transparent);
    opacity: 0;
    will-change: transform, opacity;
}
#vfx-dash-sideways::after {
    top: 52%;
    width: 25vw;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.5) 80%, transparent);
}
#vfx-dash-sideways.active.left-to-right::before,
#vfx-dash-sideways.active.left-to-right::after {
    animation: whoosh-lr 0.25s ease-out forwards;
}
#vfx-dash-sideways.active.left-to-right::after {
    animation-delay: 0.04s;
}
@keyframes whoosh-lr {
    0%   { transform: translateX(-60vw) scaleX(0.3); opacity: 0.5; }
    20%  { transform: translateX(-30vw) scaleX(1); opacity: 1; }
    100% { transform: translateX(60vw) scaleX(0.3); opacity: 0; }
}
#vfx-dash-sideways.active.right-to-left::before,
#vfx-dash-sideways.active.right-to-left::after {
    animation: whoosh-rl 0.25s ease-out forwards;
}
#vfx-dash-sideways.active.right-to-left::after {
    animation-delay: 0.04s;
}
@keyframes whoosh-rl {
    0%   { transform: translateX(60vw) scaleX(0.3); opacity: 0.5; }
    20%  { transform: translateX(30vw) scaleX(1); opacity: 1; }
    100% { transform: translateX(-60vw) scaleX(0.3); opacity: 0; }
}

/* --- REWORKED: JUMP --- */
#vfx-jump-wind {
    background: white;
    mask-image:
        linear-gradient(to bottom, transparent, black 10%, black 90%, transparent),
        linear-gradient(to bottom, transparent, black 20%, black 80%, transparent),
        linear-gradient(to bottom, transparent, black 30%, black 70%, transparent);
    mask-size: 2px 100vh, 4px 80vh, 2px 100vh;
    mask-repeat: no-repeat;
    mask-position: 45% -100vh, 50% -80vh, 55% -100vh;
    mask-composite: add;
}
#vfx-jump-wind.active {
    animation: jump-rush 0.35s ease-in forwards;
}
@keyframes jump-rush {
    from {
        opacity: 0.7;
        mask-position: 45% -100vh, 50% -80vh, 55% -100vh;
    }
    to {
        opacity: 0;
        mask-position: 45% 100vh, 50% 120vh, 55% 100vh;
    }
}


#vfx-ground-slam {
    position: absolute;
    bottom: 0; left: 50%;
    width: 200vw; height: 100vh;
    transform: translateX(-50%) scale(0);
    background: radial-gradient(ellipse at 50% 100%, rgba(220, 235, 255, 0.5) 0%, transparent 60%);
    pointer-events: none; z-index: 99; opacity: 0;
}
#vfx-ground-slam.active {
    animation: ground-slam-effect 0.4s ease-out forwards;
}
@keyframes ground-slam-effect {
    0% { transform: translateX(-50%) scale(0); opacity: 1; }
    100% { transform: translateX(-50%) scale(1); opacity: 0; }
}
/* --- End VFX --- */

#crosshair {
    position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
    background-color: rgba(255, 255, 255, 0.7); border-radius: 50%;
    transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
}
#target-frame {
    position: absolute; top: 50%; left: 50%; border: 2px solid #2ed573; border-radius: 50%;
    box-shadow: 0 0 10px #2ed573; pointer-events: none; z-index: 9; display: none;
    transform: translate(-50%, -50%); transition: width 0.1s linear, height 0.1s linear, border-color 0.2s linear;
}

/* --- Menu System --- */
#menu-system {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 200;
    pointer-events: none; /* Wrapper is transparent to events */
}
.menu-screen {
    position: absolute;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    backdrop-filter: blur(5px);
    transition: opacity 0.5s ease;
    pointer-events: auto; /* Screens are interactive */
}
.menu-screen h1, .menu-screen h2 {
    text-shadow: 0 0 20px #2ed573;
    margin: 0 0 40px 0;
}
.menu-screen h1 { font-size: 5rem; color: #2ed573; }
.menu-screen h2 { font-size: 4rem; color: #eee; }
#death-screen h2 { color: #ff4757; text-shadow: 0 0 15px #ff4757;}

.menu-options {
    display: flex; flex-direction: column; gap: 15px; margin-top: 20px;
}
.menu-screen button {
    padding: 12px 25px;
    font-size: 1.2rem;
    background-color: #333;
    color: #eee;
    border: 1px solid #555;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    font-family: inherit;
    min-width: 250px;
    transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
}
.menu-screen button:not(:disabled):hover {
    background-color: #2ed573;
    border-color: #2ed573;
    color: #000;
    transform: scale(1.05);
}
.menu-screen button:disabled {
    background-color: #222;
    color: #555;
    cursor: not-allowed;
}

/* Level Select Specifics */
#level-list {
    width: 90%; max-width: 400px;
    max-height: 50vh;
    overflow-y: auto;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 5px;
    padding: 10px;
    background-color: rgba(0,0,0,0.3);
    margin-bottom: 20px;
}
#level-list button { width: 100%; box-sizing: border-box; margin-bottom: 10px; }
.back-button { margin-top: 10px; background-color: #555 !important; }
.back-button:hover { background-color: #777 !important; color: #fff; }

#respawn-timer-text { font-size: 1.5rem; color: #ccc; }

/* Hide game elements when not playing */
body:not(.game-active) #game-hud,
body:not(.game-active) #crosshair,
body:not(.game-active) #target-frame,
body:not(.game-active) #tutorial-text-container {
    display: none !important;
}

/* --- TUTORIAL TEXT OVERLAY (REWORKED) --- */
#tutorial-text-container {
    position: absolute;
    bottom: 25%;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    max-width: 600px;
    max-height: 25vh; /* Prevent it from growing too tall */
    background-color: rgba(0, 0, 0, 0.75);
    border-left: 4px solid #2ed573;
    padding: 20px 25px;
    z-index: 50;
    pointer-events: auto; /* Allow scrollbar interaction */
    transition: opacity 0.5s ease-out;
    box-sizing: border-box; /* Ensure padding doesn't break layout */
    overflow-y: auto; /* Add scrollbar if content is too long */
}

#tutorial-text {
    color: #eee;
    font-size: 1.2rem;
    text-align: left; /* Better for multi-line text */
    margin: 0;
    line-height: 1.5;
    overflow-wrap: break-word; /* Ensure long words wrap correctly */
    pointer-events: none; /* Clicks should pass through text to the game */
}

#tutorial-text kbd {
    background-color: #eee;
    color: #111;
    border-radius: 3px;
    padding: 2px 6px;
    font-weight: bold;
    font-size: 0.9em;
    border-bottom: 2px solid #ccc;
    text-transform: uppercase;
}

/* --- HUD STYLES --- */
#hud-bottom-left, #hud-bottom-center, #hud-bottom-right {
    position: absolute; bottom: 20px; display: flex; flex-direction: column;
    align-items: center; gap: 8px; pointer-events: none; z-index: 10;
}
#hud-bottom-left { left: 20px; align-items: flex-start; }
#hud-bottom-center { left: 50%; transform: translateX(-50%); }
#hud-bottom-right { right: 20px; align-items: flex-end; }
#ability-cooldowns { display: flex; gap: 10px; width: 250px; }
.cooldown-container {
    flex: 1; height: 10px; background-color: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; padding: 1px; position: relative;
}
.cooldown-bar {
    width: 100%; height: 100%; background-color: #cccccc; border-radius: 2px; transition: width 0.1s linear;
}
.cooldown-bar.on-cooldown { background-color: #555555; }
.cooldown-label {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-size: 8px; font-weight: bold; color: white; text-shadow: 1px 1px 1px black;
}
.resource-bar-container {
    height: 20px; background-color: rgba(0, 0, 0, 0.5); border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 5px; padding: 2px; position: relative; width: 250px;
}
#health-bar {
    height: 100%; background-color: #ff4757; border-radius: 3px; transition: width 0.2s ease-out;
}
#energy-bar {
    height: 100%; background-color: #2ed573; border-radius: 3px; float: right;
    transition: width 0.2s ease-out, background-color 0.3s linear;
}
.resource-text {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-size: 12px; font-weight: bold; color: white; text-shadow: 1px 1px 2px black;
}
#energy-bar-container { text-align: right; }
#abilities-container {
    display: flex; gap: 8px; background-color: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(255, 255, 255, 0.2); padding: 8px; border-radius: 8px;
}
.ability-slot {
    width: 44px; height: 44px; background-color: rgba(0, 0, 0, 0.6);
    border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 5px; display: flex;
    align-items: center; justify-content: center; position: relative; overflow: hidden; transition: all 0.2s ease;
}
.ability-slot.selected { border-color: #2ed573; box-shadow: 0 0 10px #2ed573; }
.ability-icon { font-size: 18px; font-weight: bold; color: white; }
.ability-cooldown-overlay {
    position: absolute; bottom: 0; left: 0; width: 100%; height: 0;
    background-color: rgba(0, 0, 0, 0.7); transition: height 0.1s linear;
}
#target-info {
    padding: 8px 12px; background-color: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 5px; color: white; font-size: 14px; text-align: center; min-width: 200px;
    box-shadow: 0 0 8px rgba(0,255,0,0.5); display: flex; flex-direction: column; align-items: center;
    gap: 5px; margin-bottom: 5px; width: fit-content; display: none;
}
#target-name { font-weight: bold; color: #2ed573; }
#target-health-bar-container { width: 180px; height: 16px; margin: 0; }
#target-health-bar {
    height: 100%; background-color: #ff4757; border-radius: 3px;
    transition: width 0.2s ease-out, background-color 0.3s linear;
}
#target-health-text { font-size: 10px; }

/* --- EDITOR UI REWORK --- */
:root {
    --editor-bg: rgba(35, 38, 46, 0.9);
    --editor-border: rgba(255, 255, 255, 0.15);
    --editor-text: #e0e0e0;
    --editor-text-dark: #a0a0a0;
    --editor-accent: #2ed573;
    --editor-hover: #4a4e58;
    --editor-active: #585c66;
    --editor-input-bg: #1e2025;
}

#editor-ui {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 300px;
    max-height: calc(100vh - 20px);
    background-color: var(--editor-bg);
    border: 1px solid var(--editor-border);
    border-radius: 8px;
    backdrop-filter: blur(8px);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    font-family: 'Consolas', 'Courier New', monospace;
    color: var(--editor-text);
    z-index: 100;
}

#editor-toolbar {
    display: flex;
    padding: 6px;
    gap: 6px;
    border-bottom: 1px solid var(--editor-border);
    flex-shrink: 0;
}
.toolbar-group { display: flex; gap: 4px; }
#editor-toolbar .separator { border-right: 1px solid var(--editor-border); height: 24px; margin: 0 4px; }

#editor-main-panel {
    padding: 8px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* Accordion Styling */
.editor-accordion summary {
    padding: 8px 12px;
    background-color: var(--editor-active);
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    list-style: none; /* Remove default triangle */
    transition: background-color 0.2s;
}
.editor-accordion summary:hover { background-color: var(--editor-hover); }
.editor-accordion summary::-webkit-details-marker { display: none; }
.editor-accordion summary::before { content: '▶ '; font-size: 0.8em; }
.editor-accordion[open] > summary::before { content: '▼ '; }

.accordion-content {
    padding: 12px;
    background-color: rgba(0,0,0,0.2);
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
#properties-accordion > .delete-button {
    margin-top: 12px;
    border-radius: 4px;
}

#editor-ui h4 {
    margin: 5px 0 -5px 0;
    padding-bottom: 5px;
    font-size: 13px;
    color: var(--editor-accent);
    text-transform: uppercase;
    border-bottom: 1px solid var(--editor-border);
}

#editor-ui button {
    background-color: var(--editor-active);
    border: 1px solid var(--editor-border);
    color: var(--editor-text);
    padding: 8px;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
    transition: background-color 0.2s, border-color 0.2s;
    text-align: center;
}
#editor-ui button:hover { background-color: var(--editor-hover); }
#editor-ui button.active {
    background-color: var(--editor-accent);
    border-color: var(--editor-accent);
    color: #000;
    font-weight: bold;
}
.delete-button { background-color: #8c2a2a !important; border-color: #a13b3b !important; color: #fff !important; }
.delete-button:hover { background-color: #a13b3b !important; }

#editor-toolbar button { font-weight: bold; min-width: 32px; }

#editor-ui label { font-size: 12px; color: var(--editor-text-dark); }
#editor-ui input, #editor-ui hr { width: 100%; box-sizing: border-box; }
#editor-ui input[type="text"], #editor-ui input[type="number"], #editor-ui input[type="color"], #editor-ui input[type="range"] {
    background-color: var(--editor-input-bg);
    border: 1px solid var(--editor-border);
    color: var(--editor-text);
    padding: 6px;
    border-radius: 3px;
    font-family: inherit;
}
#editor-ui input[type="color"] { padding: 2px; height: 30px; }
#editor-ui hr { border: none; border-top: 1px solid var(--editor-border); margin: 5px 0; }
.prop-group { display: flex; gap: 4px; }
.prop-group input { flex: 1; }

.checkbox-row {
    display: flex;
    align-items: center;
    gap: 8px;
}
.checkbox-row input[type="checkbox"] { width: auto; }
.checkbox-row label { cursor: pointer; }


/* Outliner */
#outliner-list { padding: 4px; }
.outliner-item {
    padding: 6px 8px;
    background-color: rgba(255,255,255,0.05);
    border-radius: 3px;
    cursor: pointer;
    transition: background-color 0.15s;
    font-size: 12px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.outliner-item:hover { background-color: rgba(255,255,255,0.15); }
.outliner-item.selected {
    background-color: var(--editor-accent);
    color: black;
    font-weight: bold;
}
/* --- END EDITOR UI REWORK --- */

/* --- MODAL STYLES --- */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    z-index: 1000;
    display: flex;
    justify-content: center;
    align-items: center;
}

.modal-content {
    background-color: var(--editor-bg);
    border: 1px solid var(--editor-border);
    border-radius: 8px;
    padding: 20px;
    width: 90%;
    max-width: 500px;
    color: var(--editor-text);
    font-family: 'Consolas', 'Courier New', monospace;
    position: relative;
    box-shadow: 0 5px 25px rgba(0,0,0,0.5);
}

.modal-close-btn {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 24px;
    font-weight: bold;
    color: var(--editor-text-dark);
    cursor: pointer;
    transition: color 0.2s;
}
.modal-close-btn:hover {
    color: var(--editor-text);
}

.modal-content h3 {
    margin-top: 0;
    color: var(--editor-accent);
    border-bottom: 1px solid var(--editor-border);
    padding-bottom: 10px;
    margin-bottom: 15px;
}

#info-modal-text {
    white-space: pre-wrap;
    font-size: 13px;
    line-height: 1.6;
    margin: 0;
}
--------------------------------------------------
=== END OF FILE: style.css ===


=== FILE: .github/workflows/static.yml ===
--------------------------------------------------
# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

--------------------------------------------------
=== END OF FILE: .github/workflows/static.yml ===


=== FILE: levels/level-mangled-grove.json ===
--------------------------------------------------
{
    "name": "Mangled Grove (Midnight)",
    "spawnPoint": { "x": 0, "y": 3, "z": 140 },
    "deathSpawnPoint": { "x": 0, "y": 3, "z": 140 },
    "settings": {
        "backgroundColor": "0x0A0F1A",
        "fogColor": "0x0A0F1A",
        "fogNear": 20,
        "fogFar": 180,
        "ambientLight": {
            "color": "0x404060",
            "intensity": 0.5
        },
        "directionalLights": [
            {
                "color": "0xE0E8FF",
                "intensity": 9.0,
                "position": { "x": -100, "y": 250, "z": 80 },
                "targetPosition": { "x": 0, "y": 0, "z": 0 }
            }
        ]
    },
    "objects": [
        {
            "type": "Plane",
            "name": "Forest_Floor",
            "size": [400, 400],
            "position": { "x": 0, "y": 0, "z": 0 },
            "rotation": { "x": -90, "y": 0, "z": 0 },
            "material": { "color": "0x152B15", "roughness": 0.95 },
            "physics": { "mass": 0 },
            "editorSelectable": false
        },
        
        { "type": "Box", "name": "GiantRedwood_Trunk", "size": [15, 150, 15], "position": { "x": 0, "y": 75, "z": 0 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "GiantRedwood_Branch_Low", "size": [35, 4, 12], "position": { "x": 20, "y": 20, "z": 0 }, "rotation": { "y": -10 }, "material": { "color": "0x443322" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "GiantRedwood_Branch_Mid", "size": [12, 4, 40], "position": { "x": 0, "y": 50, "z": -22 }, "rotation": { "y": 5 }, "material": { "color": "0x443322" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "GiantRedwood_Branch_High", "size": [30, 5, 14], "position": { "x": -18, "y": 80, "z": 5 }, "rotation": { "y": 15 }, "material": { "color": "0x443322" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "GiantRedwood_Root1", "size": [8, 8, 25], "position": { "x": 10, "y": 4, "z": 8 }, "rotation": { "y": 45 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "GiantRedwood_Root2", "size": [6, 6, 20], "position": { "x": -8, "y": 3, "z": -10 }, "rotation": { "y": -30 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },

        { "type": "Box", "name": "Canyon_Wall_West", "size": [15, 80, 200], "position": { "x": -140, "y": 40, "z": 0 }, "material": { "color": "0x424242" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Canyon_Ledge1", "size": [15, 4, 25], "position": { "x": -120, "y": 15, "z": -60 }, "rotation": { "y": 5 }, "material": { "color": "0x555555" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Canyon_Ledge2", "size": [12, 4, 18], "position": { "x": -115, "y": 35, "z": 20 }, "rotation": { "y": -5 }, "material": { "color": "0x555555" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Canyon_Arch", "size": [50, 8, 8], "position": { "x": -95, "y": 50, "z": 50 }, "material": { "color": "0x555555" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Canyon_RockPillar", "size": [10, 60, 10], "position": { "x": -80, "y": 30, "z": -80 }, "material": { "color": "0x484848" }, "physics": { "mass": 0 } },

        { "type": "Box", "name": "Ruin_Platform1", "size": [20, 4, 25], "position": { "x": 90, "y": 25, "z": 40 }, "rotation": { "y": 15 }, "material": { "color": "0x455A64" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Ruin_Platform2", "size": [15, 4, 15], "position": { "x": 115, "y": 45, "z": 0 }, "rotation": { "y": -25 }, "material": { "color": "0x455A64" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Ruin_Platform3", "size": [12, 4, 20], "position": { "x": 80, "y": 65, "z": -50 }, "rotation": { "y": 5 }, "material": { "color": "0x455A64" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Ruin_Bridge", "size": [20, 2, 6], "position": { "x": 102, "y": 35, "z": 20 }, "material": { "color": "0x546E7A" }, "physics": { "mass": 0 } },

        { "type": "Box", "name": "Forest_Tree1", "size": [4, 45, 4], "position": { "x": 40, "y": 22.5, "z": 80 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Tree2", "size": [5, 60, 5], "position": { "x": -50, "y": 30, "z": 100 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Tree3", "size": [3, 35, 3], "position": { "x": -80, "y": 17.5, "z": -20 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Tree4", "size": [4, 50, 4], "position": { "x": 120, "y": 25, "z": -90 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Tree5", "size": [5, 55, 5], "position": { "x": 60, "y": 27.5, "z": -130 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Tree6", "size": [4, 40, 4], "position": { "x": -30, "y": 20, "z": -140 }, "material": { "color": "0x3C2A1E" }, "physics": { "mass": 0 } },

        { "type": "Box", "name": "Forest_RockCluster_A1", "size": [15, 10, 12], "position": { "x": 50, "y": 5, "z": 110 }, "rotation": {"y": 30}, "material": { "color": "0x4E4E4E" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_RockCluster_A2", "size": [10, 6, 8], "position": { "x": 58, "y": 3, "z": 115 }, "rotation": {"y": 30}, "material": { "color": "0x5A5A5A" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Rock_Large", "size": [25, 18, 20], "position": { "x": -60, "y": 9, "z": 50 }, "rotation": {"y": -50}, "material": { "color": "0x424242" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_Rock_Med", "size": [10, 4, 8], "position": { "x": -65, "y": 2, "z": 65 }, "rotation": {"y": 20}, "material": { "color": "0x5A5A5A" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Forest_FallenLog", "size": [20, 3, 3], "position": { "x": 25, "y": 1.5, "z": 50 }, "rotation": {"y": 70}, "material": { "color": "0x4E342E" }, "physics": { "mass": 0 } },

        { "type": "Box", "name": "Platform_Jump1", "size": [8, 2, 8], "position": { "x": 20, "y": 8, "z": 25 }, "material": { "color": "0x443322" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Platform_Jump2", "size": [6, 2, 6], "position": { "x": 28, "y": 14, "z": 15 }, "material": { "color": "0x443322" }, "physics": { "mass": 0 } },
        { "type": "Box", "name": "Platform_Jump3", "size": [10, 2, 10], "position": { "x": 95, "y": 12, "z": 60 }, "material": { "color": "0x455A64" }, "physics": { "mass": 0 } }
    ],
    "enemies": [
        { "type": "Dummy", "position": { "x": 10, "y": 2, "z": 125 } },
        { "type": "Dummy", "position": { "x": -10, "y": 2, "z": 125 } },
        
        { "type": "Dummy", "position": { "x": 20, "y": 22, "z": 0 } },
        { "type": "Dummy", "position": { "x": 5, "y": 52, "z": -22 } },
        { "type": "Dummy", "position": { "x": -18, "y": 82.5, "z": 15 } },

        { "type": "Dummy", "position": { "x": -120, "y": 17, "z": -65 } },
        { "type": "Dummy", "position": { "x": -115, "y": 37, "z": 28 } },
        { "type": "Dummy", "position": { "x": -80, "y": 62, "z": -80 } },

        { "type": "Dummy", "position": { "x": 90, "y": 27, "z": 45 } },
        { "type": "Dummy", "position": { "x": 85, "y": 27, "z": 35 } },
        { "type": "Dummy", "position": { "x": 115, "y": 47, "z": 5 } },
        { "type": "Dummy", "position": { "x": 80, "y": 67, "z": -45 } },

        { "type": "Dummy", "position": { "x": 50, "y": 12, "z": 110 } },
        { "type": "Dummy", "position": { "x": -60, "y": 20, "z": 50 } },
        { "type": "Dummy", "position": { "x": -55, "y": 2, "z": 100 } },
        { "type": "Dummy", "position": { "x": 120, "y": 2, "z": -110 } },
        { "type": "Dummy", "position": { "x": 20, "y": 2, "z": -100 } },
        { "type": "Dummy", "position": { "x": -25, "y": 2, "z": -50 } }
    ]
}
--------------------------------------------------
=== END OF FILE: levels/level-mangled-grove.json ===


=== FILE: levels/level-tutorial.json ===
--------------------------------------------------
{
  "name": "Custom Level",
  "spawnPoint": {
    "x": -44.98801551832607,
    "y": 8.984053355471769,
    "z": -10.625467485890029
  },
  "deathSpawnPoint": {
    "x": -43.27678684780668,
    "y": 7.839747674467933,
    "z": -9.13641267191703
  },
  "settings": {
    "backgroundColor": "0x1d2938",
    "fogColor": "0x1d2938",
    "fogNear": 20,
    "fogFar": 150,
    "ambientLight": {
      "color": "0x607080",
      "intensity": 0.7
    },
    "directionalLights": [
      {
        "color": "0xffffff",
        "intensity": 1.5,
        "position": {
          "x": -0.19662520049809018,
          "y": 100,
          "z": 94.33960641496519
        },
        "targetPosition": {
          "x": 0,
          "y": 0,
          "z": 0
        }
      },
      {
        "color": "0xffffff",
        "intensity": 1,
        "position": {
          "x": 46.55881067839958,
          "y": 24.444200793879673,
          "z": -110.47408034961622
        },
        "targetPosition": {
          "x": 0,
          "y": 0,
          "z": 0
        }
      }
    ]
  },
  "objects": [
    {
      "type": "Box",
      "name": "Box_1751135685281",
      "size": [
        -14.337207994854166,
        -1.5326680171484088,
        12.768471033444994
      ],
      "position": {
        "x": -43.01285565350706,
        "y": 5.086083636995656,
        "z": -8.96661336105313
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy",
      "size": [
        -4.208012957269948,
        -1.5326680171484088,
        12.768471033444994
      ],
      "position": {
        "x": -44.04379244343043,
        "y": 5.066219354772365,
        "z": 3.4946403812872124
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -46.26813359798705,
        "y": 7.4800669261192,
        "z": 22.107000844728145
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -48.395409662170735,
        "y": 10.719786450366831,
        "z": 36.41924432447844
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -54.1932531582041,
        "y": 13.18059556107957,
        "z": 52.03503159851534
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -54.958576548032475,
        "y": 18.13906161427649,
        "z": 64.32780639821098
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -57.6867224841606,
        "y": 23.69989632801674,
        "z": 77.74885396702486
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -1.5326680171484088,
        11.51789748887716
      ],
      "position": {
        "x": -57.63703431691122,
        "y": 25.12654970639061,
        "z": 103.13826819776716
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -9.35459125727115,
        -65.88732605570398,
        11.51789748887716
      ],
      "position": {
        "x": -65.2440753666263,
        "y": 31.422054024356967,
        "z": 139.4397373046035
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -7.11666436362174,
        -1.5326680171484088,
        21.664703872845354
      ],
      "position": {
        "x": -73.56319029136195,
        "y": 35.59654472372804,
        "z": 137.033754853079
      },
      "rotation": {
        "x": -22.22829831302085,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -7.11666436362174,
        -1.5326680171484088,
        21.664703872845354
      ],
      "position": {
        "x": -64.24971574707698,
        "y": 28.892288912765864,
        "z": 128.1662870532819
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -7.11666436362174,
        -1.5326680171484088,
        21.664703872845354
      ],
      "position": {
        "x": -60.15226726030613,
        "y": 50.25184706471693,
        "z": 148.97630285734766
      },
      "rotation": {
        "x": 0,
        "y": -90.5023004568972,
        "z": -25.66448381482514
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -12.960599066159523,
        -1.1702203770092008,
        7.572954931487935
      ],
      "position": {
        "x": -59.34608228287116,
        "y": 56.18227848289526,
        "z": 138.2289013476706
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -44.02552743283555,
        -1.1702203770092008,
        7.572954931487935
      ],
      "position": {
        "x": -25.03575772836654,
        "y": 35.02651861542267,
        "z": 138.37481365113624
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -7.11666436362174,
        -1.5326680171484088,
        21.664703872845354
      ],
      "position": {
        "x": -64.59184036678384,
        "y": 43.170755441366694,
        "z": 156.88305744479786
      },
      "rotation": {
        "x": -1.5902773407317584e-15,
        "y": -90.30782362623437,
        "z": 25.906205379506094
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Bridge_To_Arena_copy",
      "size": [
        30,
        2,
        8
      ],
      "position": {
        "x": 23.33779959175221,
        "y": 17,
        "z": 137.69647229309595
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Bridge_To_Arena_copy_copy",
      "size": [
        92.6458948939345,
        2,
        8
      ],
      "position": {
        "x": 34.36963647964132,
        "y": 17,
        "z": 180.20924912186356
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": -89.99999999999999,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Bridge_To_Arena_copy_copy_copy",
      "size": [
        100,
        2,
        100
      ],
      "position": {
        "x": 33.73613975602902,
        "y": 17,
        "z": 263.93965210569985
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 180,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy",
      "size": [
        2,
        21,
        8
      ],
      "position": {
        "x": 40.51169022811546,
        "y": 28.712489526136228,
        "z": 217.87657709750556
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy",
      "size": [
        2,
        21,
        8
      ],
      "position": {
        "x": 26.79775531958377,
        "y": 28.220483586753517,
        "z": 218.05237318816356
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy",
      "size": [
        2,
        21,
        42
      ],
      "position": {
        "x": 5,
        "y": 28,
        "z": 220
      },
      "rotation": {
        "x": 0,
        "y": 89.99999999999999,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy",
      "size": [
        2,
        20.90087054992844,
        42
      ],
      "position": {
        "x": 62.80109807243026,
        "y": 28,
        "z": 220
      },
      "rotation": {
        "x": 0,
        "y": 89.99999999999999,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy",
      "size": [
        2,
        21,
        30.43040483634169
      ],
      "position": {
        "x": 27.098884959275335,
        "y": 28.161745844124074,
        "z": 236.75043391546055
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy",
      "size": [
        2,
        21,
        38.253271744653574
      ],
      "position": {
        "x": 40.51,
        "y": 28.71,
        "z": 240.34479669916487
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy",
      "size": [
        2,
        21,
        30.43040483634169
      ],
      "position": {
        "x": 27.10740709271728,
        "y": 28.295899468955504,
        "z": 264.89569689574125
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy_copy",
      "size": [
        2,
        21,
        30.43040483634169
      ],
      "position": {
        "x": 40.62314385706276,
        "y": 28.77916185870848,
        "z": 272.3821485082806
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751188368534",
      "size": [
        5,
        1.2147638168423514,
        21.410547156871157
      ],
      "position": {
        "x": 28.618151953528375,
        "y": 32.01046566752841,
        "z": 290.7677370378025
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751188368534_copy",
      "size": [
        5,
        1.2147638168423514,
        5.9795431960832435
      ],
      "position": {
        "x": 39.0276816535211,
        "y": 21.5737853494403,
        "z": 266.5165795708593
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751188368534_copy_copy",
      "size": [
        5,
        1.2147638168423514,
        5.9795431960832435
      ],
      "position": {
        "x": 38.93453261207418,
        "y": 27.32767221473951,
        "z": 277.4627085616325
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy_copy_copy",
      "size": [
        2,
        21,
        18.02086332300729
      ],
      "position": {
        "x": 35.220742244897274,
        "y": 28.720025301744933,
        "z": 288.6444856241913
      },
      "rotation": {
        "x": 0,
        "y": 89.99999999999999,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy_copy",
      "size": [
        2,
        14.749420843674784,
        11.811989803925266
      ],
      "position": {
        "x": 27.159091822501022,
        "y": 23.95641160076355,
        "z": 282.65911374150534
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        2,
        21,
        80.76019405558864
      ],
      "position": {
        "x": 35.02179249171756,
        "y": 28.702243663384706,
        "z": 288.63741505981824
      },
      "rotation": {
        "x": 0,
        "y": 89.99999999999999,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        2,
        21,
        67.73951804536438
      ],
      "position": {
        "x": -15.187593194183867,
        "y": 28.724469244999142,
        "z": 253.68169009909604
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        2,
        21,
        67.73951804536438
      ],
      "position": {
        "x": -15.337970860966319,
        "y": 28.686729554749007,
        "z": 321.31986403266734
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Bridge_To_Arena_copy_copy_copy_copy",
      "size": [
        100,
        2,
        100
      ],
      "position": {
        "x": 19.115844563028965,
        "y": 17.089844823782187,
        "z": 341.8173037010886
      },
      "physics": {
        "mass": 0
      },
      "rotation": {
        "x": 0,
        "y": 180,
        "z": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        2,
        21,
        67.73951804536438
      ],
      "position": {
        "x": 19.161555963069226,
        "y": 28.7212519381462,
        "z": 332.9763058959693
      },
      "rotation": {
        "x": 0,
        "y": 89.99999999999999,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        2,
        21,
        70.63290423242627
      ],
      "position": {
        "x": 68.05817206096688,
        "y": 28.25803717150999,
        "z": 297.1353537831629
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751185412489_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        2,
        21,
        19.259313785509278
      ],
      "position": {
        "x": 62.107728984628636,
        "y": 28.79925613263817,
        "z": 333.00591342200784
      },
      "rotation": {
        "x": 0,
        "y": 89.99999999999999,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751189540507",
      "size": [
        5,
        25,
        5
      ],
      "position": {
        "x": 22.64984414454856,
        "y": 27.73367465196428,
        "z": 320.476719378943
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751189540507_copy",
      "size": [
        5,
        25,
        5
      ],
      "position": {
        "x": 6.431761615160653,
        "y": 26.143146680203376,
        "z": 302.86551412184036
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751189540507_copy_copy",
      "size": [
        5,
        25,
        5
      ],
      "position": {
        "x": 50.107659018712376,
        "y": 16.169746544805204,
        "z": 299.36335939978414
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751189540507_copy_copy_copy",
      "size": [
        5,
        8.436992494585535,
        5
      ],
      "position": {
        "x": 38.95952107314219,
        "y": 19.014829220756837,
        "z": 308.90970895954536
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751188368534_copy",
      "size": [
        5,
        1.2147638168423514,
        6.849803759880959
      ],
      "position": {
        "x": 24.293863031792892,
        "y": 33.303255944309875,
        "z": 310.05424474411103
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751135685281_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy",
      "size": [
        -12.960599066159523,
        -1.1702203770092008,
        7.572954931487935
      ],
      "position": {
        "x": -66.76667918411331,
        "y": 60.60448127535637,
        "z": 132.01784035049542
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Box_1751188368534_copy",
      "size": [
        5,
        1.2147638168423514,
        5.168579630942036
      ],
      "position": {
        "x": 39.664726299169736,
        "y": 31.845085950633848,
        "z": 290.10534651298383
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0xff7300"
      },
      "physics": {
        "mass": 0
      }
    }
  ],
  "enemies": [
    {
      "type": "Dummy",
      "position": {
        "x": 35.000228077174626,
        "y": 18.799919941731627,
        "z": 243.95776047717976
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Dummy",
      "position": {
        "x": 0,
        "y": 18.799919941731627,
        "z": 230.18962744580983
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "name": "Dummy_copy"
    },
    {
      "type": "Dummy",
      "position": {
        "x": 18.476473589188785,
        "y": 18.799919941731627,
        "z": 225.77828841029188
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "name": "Dummy_copy_copy"
    },
    {
      "type": "Dummy",
      "position": {
        "x": 42.73719317280715,
        "y": 18.889764765513814,
        "z": 314.0599099286152
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "name": "Dummy_copy"
    },
    {
      "type": "Dummy",
      "position": {
        "x": 55.19862555717065,
        "y": 18.889764765513814,
        "z": 296.439123284842
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "name": "Dummy_copy_copy"
    },
    {
      "type": "Dummy",
      "position": {
        "x": 21.19258131465478,
        "y": 18.889764765513814,
        "z": 297.7708301405303
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "name": "Dummy_copy_copy_copy"
    }
  ],
  "triggers": [
    {
      "type": "Trigger",
      "name": "Welcome",
      "position": {
        "x": -41.75934763757055,
        "y": 5.7614447295826245,
        "z": -9.313608708592323
      },
      "size": [
        16,
        8,
        10.876547004065293
      ],
      "message": "Use your MOUSE to look and W, A, S, D to move.",
      "duration": 8,
      "color": "0x2ed573"
    },
    {
      "type": "Trigger",
      "name": "Jump",
      "position": {
        "x": -44.13153928946884,
        "y": 9.672358004866954,
        "z": 8.012847526714085
      },
      "size": [
        4.9135478529606775,
        8,
        4
      ],
      "message": "Press SPACE to jump across the platforms.",
      "duration": 5,
      "color": "0x2ed573"
    },
    {
      "type": "Trigger",
      "name": "DoubleJump",
      "position": {
        "x": -54.34750758720173,
        "y": 16.07210572584555,
        "z": 54.761976264200435
      },
      "size": [
        9.020993927863413,
        8,
        4
      ],
      "message": "This gap is too high. Press SPACE again in mid-air to Double Jump.",
      "duration": 8,
      "color": "0xffa502"
    },
    {
      "type": "Trigger",
      "name": "DoubleJump_Cooldown",
      "position": {
        "x": -54.96415065519877,
        "y": 21.442005253000485,
        "z": 66.81477044689034
      },
      "size": [
        7.1143018362574075,
        6.015156160833573,
        4
      ],
      "message": "Notice the JUMP bar (bottom-left) goes on cooldown after a double jump.",
      "duration": 8,
      "color": "0xffa502"
    },
    {
      "type": "Trigger",
      "name": "Dash",
      "position": {
        "x": -57.938917187698486,
        "y": 27.1298445053377,
        "z": 81.26106201212208
      },
      "size": [
        10.164616862428192,
        8,
        4
      ],
      "message": "Double-tap a movement key to Dash across the gap. The DASH bar shows its cooldown.",
      "duration": 8,
      "color": "0xffa502"
    },
    {
      "type": "Trigger",
      "name": "Slam",
      "position": {
        "x": -57.60454343060415,
        "y": 28.17041333083598,
        "z": 107.49762430104798
      },
      "size": [
        8,
        7.231729781960025,
        8
      ],
      "message": "Climb this tower, then hold SHIFT in the air to Ground Slam onto the bridge.",
      "duration": 10,
      "color": "0xffa502"
    },
    {
      "type": "Trigger",
      "name": "Combat_Intro",
      "position": {
        "x": 17.244894302181223,
        "y": 22.80133576899718,
        "z": 137.78605307420787
      },
      "size": [
        15,
        8,
        10
      ],
      "message": "Welcome to the combat arena. Destroy all the dummies to complete the tutorial.",
      "duration": 8,
      "color": "0x1e90ff"
    },
    {
      "type": "Trigger",
      "name": "Melee_Intro",
      "position": {
        "x": 33.713461326627545,
        "y": 20.40600635806252,
        "z": 218.68734854023458
      },
      "size": [
        11.74524056614409,
        8,
        10
      ],
      "message": "LEFT CLICK to use your Katana. Get close to the dummy and strike.",
      "duration": 8,
      "color": "0xff4757",
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Trigger",
      "name": "Ability_Intro",
      "position": {
        "x": 33.70840575425143,
        "y": 22.12451878403729,
        "z": 252.9547921460112
      },
      "size": [
        13.878106820007062,
        8,
        4.043653764435819
      ],
      "message": "RIGHT CLICK casts abilities. They cost ENERGY and have COOLDOWNS.",
      "duration": 8,
      "color": "0xff4757",
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Trigger",
      "name": "Fireball_Intro",
      "position": {
        "x": 26.41930770244788,
        "y": 34.7840465692085,
        "z": 284.43229434591416
      },
      "size": [
        3.1849251368792157,
        6.368137594503896,
        8.625950920043731
      ],
      "message": "Press 1 to select Fireball. Aim and cast it on the dummy.",
      "duration": 8,
      "color": "0xff4757",
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Trigger",
      "name": "Fireflies_Intro",
      "position": {
        "x": -9.32984969763514,
        "y": 21.415761089703913,
        "z": 289.4060833549364
      },
      "size": [
        10.916189740697234,
        7.405774126009966,
        3.815512880455527
      ],
      "message": "Press 2 for Fireflies. These homing shots seek out your locked-on target - ",
      "duration": 8,
      "color": "0xff4757",
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    {
      "type": "Trigger",
      "name": "MessageTrigger_1751189714433",
      "size": [
        4.789923093665238,
        5,
        4.181499598810611
      ],
      "position": {
        "x": 22.485884509976458,
        "y": 43.722955096133695,
        "z": 320.27474856297374
      },
      "message": "This is a test message.",
      "duration": 5,
      "color": "0x00ff00",
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    }
  ],
  "deathTriggers": []
}
--------------------------------------------------
=== END OF FILE: levels/level-tutorial.json ===


=== FILE: levels/manifest.json ===
--------------------------------------------------
[
    {
        "name": "Tutorial",
        "path": "./levels/level-tutorial.json"
    },
    {
        "name": "Mangled Grove",
        "path": "./levels/level-mangled-grove.json"
    }
]
--------------------------------------------------
=== END OF FILE: levels/manifest.json ===


=== FILE: src/editor_main.js ===
--------------------------------------------------
import { EditorApp } from './editor/EditorApp.js';

// Create a new instance of our editor application
const editorApp = new EditorApp();

// Initialize and start the editor loop
editorApp.init();
--------------------------------------------------
=== END OF FILE: src/editor_main.js ===


=== FILE: src/main.js ===
--------------------------------------------------
import { Game } from './game/Game.js';

// Create a new instance of our game
const game = new Game();

// Initialize and start the game loop
game.init();
--------------------------------------------------
=== END OF FILE: src/main.js ===


=== FILE: src/common/CollisionGroups.js ===
--------------------------------------------------
export const COLLISION_GROUPS = {
    WORLD: 1,
    PLAYER: 2,
    PROJECTILE: 4,
    ENEMY: 8,
};
--------------------------------------------------
=== END OF FILE: src/common/CollisionGroups.js ===


=== FILE: src/editor/EditorActions.js ===
--------------------------------------------------
import * as THREE from 'three';
import { StateChangeCommand } from './UndoManager.js';

export class EditorActions {
    constructor(editor) {
        this.editor = editor;
        this.app = editor.app;
        this.camera = editor.camera;
    }

    _createAndExecuteCreationCommand(entity, list) {
        list.push(entity);
        
        const beforeState = null; // No state before creation
        const afterState = entity.definition;
        
        const command = {
            entity: entity,
            execute: () => {
                if (!list.includes(entity)) list.push(entity);
                this.app.scene.add(entity.mesh);
                if (entity.body) this.app.physics.world.addBody(entity.body);
                this.editor.select(entity);
            },
            undo: () => {
                const index = list.indexOf(entity);
                if (index > -1) list.splice(index, 1);
                this.app.scene.remove(entity.mesh);
                if (entity.body) this.app.physics.queueForRemoval(entity.body);
                this.editor.deselect();
            }
        };
        this.editor.undoManager.execute(command);
    }

    addBox() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
        const boxData = {
            type: "Box", name: `Box_${Date.now()}`, size: [2, 2, 2],
            position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
            rotation: { x: 0, y: 0, z: 0 },
            material: { color: "0xcccccc" }, physics: { mass: 0 }
        };
        const newObj = this.app.levelLoader.createObject(boxData);
        this._createAndExecuteCreationCommand(newObj, this.app.levelObjects);
    }
    
    addEnemy() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
        const enemyData = { type: "Dummy", position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z } };
        const newEnemy = this.app.levelLoader.createEnemy(enemyData);
        this._createAndExecuteCreationCommand(newEnemy, this.app.enemies);
    }

    addMessageTrigger() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
        const triggerData = {
            type: "Trigger", name: `MessageTrigger_${Date.now()}`, size: [5, 5, 5],
            position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
            message: "This is a test message.",
            duration: 5,
            color: "0x00ff00"
        };
        const newTrigger = this.app.createTrigger(triggerData);
        this._createAndExecuteCreationCommand(newTrigger, this.app.triggers);
    }

    addDeathTrigger() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
        const triggerData = {
            type: "DeathTrigger", name: `DeathZone_${Date.now()}`, size: [10, 2, 10],
            position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z }
        };
        const newTrigger = this.app.createDeathTrigger(triggerData);
        this._createAndExecuteCreationCommand(newTrigger, this.app.deathTriggers);
    }

    deleteSelected() {
        if (!this.editor.selectedObject) return;
        const entity = this.editor.selectedObject;
        const entityType = entity.userData.gameEntity.type;
        
        if (['SpawnPoint', 'DeathSpawnPoint'].includes(entityType)) return;

        let list;
        switch (entityType) {
            case 'Trigger':       list = this.app.triggers; break;
            case 'DeathTrigger':  list = this.app.deathTriggers; break;
            case 'DirectionalLight': 
                this.app.removeDirectionalLight(entity);
                this.editor.deselect();
                // TODO: Add undo/redo for light creation/deletion
                return;
            case 'Enemy':         list = this.app.enemies; break;
            default:              list = this.app.levelObjects; break;
        }

        const command = {
            entity: entity,
            execute: () => {
                const index = list.indexOf(entity);
                if (index > -1) list.splice(index, 1);
                this.app.scene.remove(entity.mesh);
                if (entity.body) this.app.physics.queueForRemoval(entity.body);
                this.editor.deselect();
            },
            undo: () => {
                if (!list.includes(entity)) list.push(entity);
                this.app.scene.add(entity.mesh);
                if (entity.body) this.app.physics.world.addBody(entity.body);
                this.editor.select(entity);
            }
        };
        this.editor.undoManager.execute(command);
    }
    
    _bakeScaleIntoDefinition(entity) {
        if (entity && entity.mesh && entity.definition?.size) {
            const scale = entity.mesh.scale;
            if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
                entity.definition.size[0] *= scale.x;
                entity.definition.size[1] *= scale.y;
                entity.definition.size[2] *= scale.z;
                scale.set(1, 1, 1);
                this.editor.applyDefinition(entity);
            }
        }
    }
    
    copySelected() {
        if (!this.editor.selectedObject) return;
        
        const entity = this.editor.selectedObject;
        const entityType = entity.userData?.gameEntity?.type;

        if (['Object', 'Enemy', 'Trigger', 'DeathTrigger'].includes(entityType)) {
            // Apply scale before syncing other transforms to ensure correct data is copied
            this._bakeScaleIntoDefinition(entity);
            this.editor.syncObjectTransforms(); 

            if (entityType === 'Object') {
                const rot = new THREE.Euler().setFromQuaternion(entity.mesh.quaternion, 'YXZ');
                entity.definition.rotation = {x: THREE.MathUtils.radToDeg(rot.x), y: THREE.MathUtils.radToDeg(rot.y), z: THREE.MathUtils.radToDeg(rot.z)};
            }
            this.editor.clipboard = JSON.parse(JSON.stringify(entity.definition));
            if (!this.editor.clipboard.type) this.editor.clipboard.type = entityType;
        } else {
            this.editor.clipboard = null;
        }
    }

    pasteFromClipboard() {
        if (!this.editor.clipboard) return;

        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(15));
        
        const newDef = JSON.parse(JSON.stringify(this.editor.clipboard));
        newDef.position = { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z };
        newDef.name = `${newDef.name || newDef.type}_copy`;

        let newEntity;
        let list;

        switch(newDef.type) {
            case 'Dummy':         
                newEntity = this.app.levelLoader.createEnemy(newDef); 
                list = this.app.enemies;
                break;
            case 'Trigger':       
                newEntity = this.app.createTrigger(newDef);
                list = this.app.triggers;
                break;
            case 'DeathTrigger':  
                newEntity = this.app.createDeathTrigger(newDef);
                list = this.app.deathTriggers;
                break;
            default:              
                newEntity = this.app.levelLoader.createObject(newDef);
                list = this.app.levelObjects;
                break;
        }
        
        if (newEntity) this._createAndExecuteCreationCommand(newEntity, list);
    }

    loadFile(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try { this.app.loadLevel(JSON.parse(e.target.result)); } 
            catch (err) { alert("Invalid level file."); }
        };
        reader.readAsText(file);
    }

    saveFile() {
        // --- PRE-SAVE SYNC ---
        // Ensure all entities have their definitions updated from their editor state.
        
        // Bake scale for any scaled objects first.
        this.app.levelObjects.forEach(obj => this._bakeScaleIntoDefinition(obj));

        // Sync standard mesh-based entities (Objects, Enemies, Triggers)
        [...this.app.levelObjects, ...this.app.enemies, ...this.app.triggers, ...this.app.deathTriggers].forEach(obj => {
            if (!obj.definition) return;
            obj.definition.position = { x: obj.mesh.position.x, y: obj.mesh.position.y, z: obj.mesh.position.z };
            if (obj.definition.rotation) {
                const rot = new THREE.Euler().setFromQuaternion(obj.mesh.quaternion, 'YXZ');
                obj.definition.rotation = { x: THREE.MathUtils.radToDeg(rot.x), y: THREE.MathUtils.radToDeg(rot.y), z: THREE.MathUtils.radToDeg(rot.z) };
            }
        });

        // Sync directional lights
        this.app.directionalLights.forEach(lightObj => {
            lightObj.definition.position = { x: lightObj.light.position.x, y: lightObj.light.position.y, z: lightObj.light.position.z };
            lightObj.definition.targetPosition = { x: lightObj.light.target.position.x, y: lightObj.light.target.position.y, z: lightObj.light.target.position.z };
        });

        // --- SERIALIZATION ---
        const levelData = {
            name: "Custom Level",
            spawnPoint: { x: this.app.spawnPointHelper.position.x, y: this.app.spawnPointHelper.position.y, z: this.app.spawnPointHelper.position.z },
            deathSpawnPoint: { x: this.app.deathSpawnPointHelper.position.x, y: this.app.deathSpawnPointHelper.position.y, z: this.app.deathSpawnPointHelper.position.z },
            settings: this.app.settings,
            objects: this.app.levelObjects.map(obj => obj.definition),
            enemies: this.app.enemies.map(enemy => enemy.definition),
            triggers: this.app.triggers.map(t => t.definition),
            deathTriggers: this.app.deathTriggers.map(t => t.definition)
        };
        
        const blob = new Blob([JSON.stringify(levelData, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'custom-level.json';
        a.click();
        URL.revokeObjectURL(a.href);
    }
    
    updateSkyboxColor(color) {
        this.app.scene.background = new THREE.Color(color);
        this.app.settings.backgroundColor = color.replace('#', '0x');
    }
    
    updateAmbientLight(prop, value) {
        const light = this.app.ambientLight;
        const setting = this.app.settings.ambientLight;
        if (prop === 'color') { light.color.set(value); setting.color = value.replace('#', '0x'); }
        if (prop === 'intensity') { light.intensity = parseFloat(value); setting.intensity = parseFloat(value); }
    }
    
    setSpawnPointToCamera() { this.camera.getWorldPosition(this.app.spawnPointHelper.position); this.editor.syncObjectTransforms(); }
    setDeathSpawnPointToCamera() { this.camera.getWorldPosition(this.app.deathSpawnPointHelper.position); this.editor.syncObjectTransforms(); }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorActions.js ===


=== FILE: src/editor/EditorApp.js ===
--------------------------------------------------
import * as THREE from 'three';
import { Renderer } from '../engine/Renderer.js';
import { Physics } from '../engine/Physics.js';
import { InputManager } from '../engine/InputManager.js';
import { LevelLoader } from '../world/LevelLoader.js';
import { LevelEditor } from './LevelEditor.js';

export class EditorApp {
    constructor() {
        this.clock = new THREE.Clock();
        this.renderer = new Renderer();
        this.physics = new Physics();
        this.input = new InputManager();

        this.scene = this.renderer.scene;
        this.camera = this.renderer.camera;

        this.updatables = [];
        this.levelObjects = [];
        this.enemies = [];
        this.triggers = [];
        this.deathTriggers = [];
        
        this.spawnPoint = { x: 0, y: 5, z: 10 };
        this.spawnPointHelper = null;
        this.deathSpawnPoint = { x: 0, y: 5, z: 12 };
        this.deathSpawnPointHelper = null;

        this.settings = {};
        this.ambientLight = null;
        this.directionalLights = []; // Now stores { light, helper, picker, definition }
    }

    async init() {
        this.levelLoader = new LevelLoader(this);
        const levelData = await this.levelLoader.load('./levels/level-tutorial.json');

        this.editor = new LevelEditor(this);
        this.loadLevel(levelData);

        window.editorApp = this;
        this.renderer.renderer.setAnimationLoop(() => this.animate());
    }

    loadLevel(levelData) {
        this.clearLevel();
        const { levelObjects, enemies, ambientLight, directionalLights, triggers, deathTriggers } = this.levelLoader.build(levelData);
        
        this.levelObjects = levelObjects;
        this.enemies = enemies;
        this.triggers = (triggers || []).map(triggerData => this.createTrigger(triggerData));
        this.deathTriggers = (deathTriggers || []).map(triggerData => this.createDeathTrigger(triggerData));
        this.spawnPoint = { ...levelData.spawnPoint };
        this.deathSpawnPoint = { ...(levelData.deathSpawnPoint || levelData.spawnPoint) };
        this.settings = levelData.settings;
        this.ambientLight = ambientLight;
        this.directionalLights = directionalLights.map(light => this.createDirectionalLightWithHelper(light));

        this.createSpawnPointHelper();
        this.createDeathSpawnPointHelper();
        this.editor.setLevelData(this.levelObjects, this.enemies, this.triggers, this.deathTriggers);
    }

    createTrigger(triggerData) {
        const geometry = new THREE.BoxGeometry(...triggerData.size);
        const material = new THREE.MeshBasicMaterial({
            color: parseInt(triggerData.color || "0x00ff00", 16),
            transparent: true,
            opacity: 0.35,
            wireframe: true,
            depthWrite: false
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(triggerData.position.x, triggerData.position.y, triggerData.position.z);
        
        const triggerObject = {
            mesh,
            definition: triggerData
        };

        triggerObject.userData = { gameEntity: { type: 'Trigger', entity: triggerObject } };
        mesh.userData.gameEntity = triggerObject.userData.gameEntity;

        this.scene.add(mesh);
        return triggerObject;
    }

    createDeathTrigger(triggerData) {
        const geometry = new THREE.BoxGeometry(...triggerData.size);
        const material = new THREE.MeshBasicMaterial({
            color: 0xff0000, // Red for death
            transparent: true,
            opacity: 0.35,
            wireframe: true,
            depthWrite: false
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(triggerData.position.x, triggerData.position.y, triggerData.position.z);
        
        const triggerObject = {
            mesh,
            definition: triggerData
        };

        triggerObject.userData = { gameEntity: { type: 'DeathTrigger', entity: triggerObject } };
        mesh.userData.gameEntity = triggerObject.userData.gameEntity;

        this.scene.add(mesh);
        return triggerObject;
    }

    createDirectionalLightWithHelper(light) {
        const helper = new THREE.DirectionalLightHelper(light, 5, 0xffffff);
        if (helper.lightPlane && helper.lightPlane.material) {
            helper.lightPlane.material.depthTest = false;
        }
        this.scene.add(helper);

        const picker = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        picker.position.copy(light.position);
        this.scene.add(picker);
        
        const lightObject = { light, helper, picker, definition: light.userData.definition };
        lightObject.userData = { gameEntity: { type: 'DirectionalLight', entity: lightObject } };
        picker.userData.gameEntity = lightObject.userData.gameEntity;

        return lightObject;
    }
    
    addDirectionalLight() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(20));

        const lightData = {
            color: "0xffffff",
            intensity: 1,
            position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
            targetPosition: { x: 0, y: 0, z: 0 }
        };

        if (!this.settings.directionalLights) this.settings.directionalLights = [];
        this.settings.directionalLights.push(lightData);
        
        const newLight = this.levelLoader.createDirectionalLight(lightData);
        const newLightObject = this.createDirectionalLightWithHelper(newLight);
        this.directionalLights.push(newLightObject);

        this.editor.select(newLightObject);
    }
    
    removeDirectionalLight(lightObjectToRemove) {
        if (!lightObjectToRemove) return;
        const index = this.directionalLights.indexOf(lightObjectToRemove);
        if (index > -1) {
            this.scene.remove(lightObjectToRemove.light.target);
            this.scene.remove(lightObjectToRemove.light);
            this.scene.remove(lightObjectToRemove.helper);
            this.scene.remove(lightObjectToRemove.picker);

            lightObjectToRemove.helper.dispose();
            lightObjectToRemove.picker.geometry.dispose();
            lightObjectToRemove.picker.material.dispose();
            
            const defIndex = this.settings.directionalLights.indexOf(lightObjectToRemove.definition);
            if (defIndex > -1) this.settings.directionalLights.splice(defIndex, 1);

            this.directionalLights.splice(index, 1);
        }
    }

    createSpawnPointHelper() {
        if (this.spawnPointHelper) this.scene.remove(this.spawnPointHelper);
        
        const helper = new THREE.AxesHelper(2);
        helper.material.depthTest = false;
        helper.position.set(this.spawnPoint.x, this.spawnPoint.y, this.spawnPoint.z);

        const pickerBox = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.5, 0.5), 
            new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 })
        );
        helper.add(pickerBox);
        
        helper.userData.gameEntity = { type: 'SpawnPoint', entity: helper };
        pickerBox.userData.gameEntity = helper.userData.gameEntity;
        
        this.spawnPointHelper = helper;
        this.scene.add(this.spawnPointHelper);
    }

    createDeathSpawnPointHelper() {
        if (this.deathSpawnPointHelper) this.scene.remove(this.deathSpawnPointHelper);
        
        const helper = new THREE.AxesHelper(2);
        helper.material.depthTest = false;
        helper.position.set(this.deathSpawnPoint.x, this.deathSpawnPoint.y, this.deathSpawnPoint.z);
    
        const pickerBox = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.5, 0.5), 
            new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.6 }) // Red color
        );
        helper.add(pickerBox);
        
        helper.userData.gameEntity = { type: 'DeathSpawnPoint', entity: helper };
        pickerBox.userData.gameEntity = helper.userData.gameEntity;
        
        this.deathSpawnPointHelper = helper;
        this.scene.add(this.deathSpawnPointHelper);
    }

    clearLevel() {
        [...this.levelObjects, ...this.enemies, ...this.triggers, ...this.deathTriggers].forEach(obj => {
            if (obj.mesh) this.scene.remove(obj.mesh);
            if (obj.body) this.physics.queueForRemoval(obj.body);
        });
        this.levelObjects = [];
        this.enemies = [];
        this.triggers = [];
        this.deathTriggers = [];

        if (this.spawnPointHelper) this.scene.remove(this.spawnPointHelper);
        this.spawnPointHelper = null;
        
        if (this.deathSpawnPointHelper) this.scene.remove(this.deathSpawnPointHelper);
        this.deathSpawnPointHelper = null;

        this.directionalLights.forEach(lightObj => this.removeDirectionalLight(lightObj));
        this.directionalLights = [];
        
        if (this.ambientLight) this.scene.remove(this.ambientLight);
        this.ambientLight = null;
    }

    animate() {
        const deltaTime = this.clock.getDelta();
        this.physics.update(deltaTime);

        // Update entities like enemies to sync their mesh positions
        for (const updatable of this.updatables) {
            updatable.update(deltaTime);
        }

        this.editor.update(deltaTime);
        this.renderer.render();
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorApp.js ===


=== FILE: src/editor/EditorCamera.js ===
--------------------------------------------------
import * as THREE from 'three';

export class EditorCamera {
    constructor(editor) {
        this.editor = editor;
        this.camera = editor.camera;
        this.input = editor.input;
    }

    update(deltaTime) {
        // Prevent camera movement while transform controls are active or if input is disabled
        if (this.editor.controls.transformControls.dragging || !this.input.enabled) {
            this.input.update();
            return;
        }

        const moveSpeed = 50 * deltaTime;
        const forward = new THREE.Vector3();
        this.camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(this.camera.up, forward).negate();
        
        if (this.input.keys['KeyW']) this.camera.position.addScaledVector(forward, moveSpeed);
        if (this.input.keys['KeyS']) this.camera.position.addScaledVector(forward, -moveSpeed);
        if (this.input.keys['KeyA']) this.camera.position.addScaledVector(right, -moveSpeed);
        if (this.input.keys['KeyD']) this.camera.position.addScaledVector(right, moveSpeed);
        if (this.input.keys['Space']) this.camera.position.y += moveSpeed;
        if (this.input.keys['ShiftLeft']) this.camera.position.y -= moveSpeed;
        
        // Right-click look
        if (this.input.mouse.rightClick && !this.input.isClickOnUI(this.input.mouse.screenX, this.input.mouse.screenY)) {
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            euler.setFromQuaternion(this.camera.quaternion);
            euler.y -= this.input.mouse.movementX * 0.002;
            euler.x -= this.input.mouse.movementY * 0.002;
            euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
            this.camera.quaternion.setFromEuler(euler);
        }

        this.input.update();
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorCamera.js ===


=== FILE: src/editor/EditorControls.js ===
--------------------------------------------------
import * as THREE from 'three';
import { TransformControls } from 'three/addons/controls/TransformControls.js';
import { StateChangeCommand } from './UndoManager.js';

export class EditorControls {
    constructor(editor) {
        this.editor = editor;
        this.app = editor.app;
        this.scene = editor.scene;
        this.camera = editor.camera;
        this.renderer = editor.renderer;
        this.input = editor.input;

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        
        this.onMouseDownHandler = this.onMouseDown.bind(this);
        this.onContextMenuHandler = (e) => e.preventDefault();
        
        this._initialDragState = null; // For Undo/Redo

        this.init();
    }
    
    init() {
        this.transformControls = new TransformControls(this.camera, this.renderer.domElement);
        this.transformControls.addEventListener('dragging-changed', (event) => this.onDraggingChanged(event));
        this.transformControls.addEventListener('objectChange', () => this.onObjectChange());
        this.scene.add(this.transformControls);

        this.selectionBox = new THREE.BoxHelper();
        this.selectionBox.material.depthTest = false;
        this.selectionBox.material.transparent = true;
        this.selectionBox.visible = false;
        this.scene.add(this.selectionBox);
        
        this.renderer.domElement.addEventListener('mousedown', this.onMouseDownHandler, false);
        this.renderer.domElement.addEventListener('contextmenu', this.onContextMenuHandler, false);
    }

    dispose() {
        this.renderer.domElement.removeEventListener('mousedown', this.onMouseDownHandler, false);
        this.renderer.domElement.removeEventListener('contextmenu', this.onContextMenuHandler, false);
        this.transformControls.dispose();
        this.scene.remove(this.transformControls);
        this.scene.remove(this.selectionBox);
        this.selectionBox.geometry.dispose();
        this.selectionBox.material.dispose();
    }

    onDraggingChanged(event) {
        this.input.enabled = !event.value;
        const entity = this.editor.selectedObject;
        if (!entity) return;

        if (event.value) { // Drag started
            this._initialDragState = {
                definition: JSON.parse(JSON.stringify(entity.definition)), // Deep copy
                position: entity.mesh.position.clone(),
                quaternion: entity.mesh.quaternion.clone(),
                scale: entity.mesh.scale.clone()
            };

            if (entity.userData.gameEntity.type === 'DirectionalLight' && this.transformControls.mode === 'rotate') {
                this.editor._initialLightPos = entity.light.position.clone();
                this.editor._initialPickerQuat = entity.picker.quaternion.clone();
            }
        } else { // Drag ended
            const beforeState = this._initialDragState.definition;
            
            // The "after" state is the object's definition after applying the gizmo changes
            const afterState = JSON.parse(JSON.stringify(entity.definition));
            afterState.position = { x: entity.mesh.position.x, y: entity.mesh.position.y, z: entity.mesh.position.z };
            const euler = new THREE.Euler().setFromQuaternion(entity.mesh.quaternion, 'YXZ');
            afterState.rotation = { x: THREE.MathUtils.radToDeg(euler.x), y: THREE.MathUtils.radToDeg(euler.y), z: THREE.MathUtils.radToDeg(euler.z) };
            
            // For scaling, calculate final size but keep position centered.
            if (this.transformControls.mode === 'scale' && afterState.size) {
                 const initialSize = new THREE.Vector3().fromArray(this._initialDragState.definition.size);
                 const newSize = initialSize.clone().multiply(entity.mesh.scale);
                 
                 afterState.size = newSize.toArray();
                 // By not changing afterState.position here, we respect the object's center
                 // position which was captured from the mesh's transform before this block.

                 // Reset the mesh scale as it's now baked into the definition
                 entity.mesh.scale.set(1, 1, 1);
            }
            
            const command = new StateChangeCommand(this.editor, entity, beforeState, afterState);
            this.editor.undoManager.execute(command);

            this._initialDragState = null;
            this.editor._initialLightPos = null;
            this.editor._initialPickerQuat = null;
        }
    }

    onObjectChange() {
        if (this.editor.selectedObject && !this.transformControls.dragging) {
            this.editor.syncObjectTransforms();
            this.editor.ui.updatePropertiesPanel();
        }
    }

    onMouseDown(event) {
        if (event.button !== 0 || this.transformControls.dragging || this.input.isClickOnUI(event.clientX, event.clientY)) return;
        
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        this.raycaster.setFromCamera(this.mouse, this.camera);

        const pickableMeshes = this.app.levelObjects.map(o => o.mesh)
            .concat(this.app.enemies.map(e => e.mesh))
            .concat(this.app.directionalLights.map(l => l.picker))
            .concat(this.app.triggers.map(t => t.mesh))
            .concat(this.app.deathTriggers.map(t => t.mesh))
            .concat(this.app.spawnPointHelper ? [this.app.spawnPointHelper] : [])
            .concat(this.app.deathSpawnPointHelper ? [this.app.deathSpawnPointHelper] : []);
            
        const intersects = this.raycaster.intersectObjects(pickableMeshes.filter(m => m.visible), true);
        const validIntersects = intersects.filter(i => i.object.userData.gameEntity?.entity);
        
        if (validIntersects.length > 0) {
            const entity = validIntersects[0].object.userData.gameEntity.entity;
            if (entity.definition?.editorSelectable === false) {
                 this.editor.deselect();
            } else {
                 this.editor.select(entity);
            }
        } else {
            this.editor.deselect();
        }
    }

    setTransformMode(mode) {
        if (this.transformControls.object) {
            this.transformControls.setMode(mode);
            this.editor.ui.updateTransformModeButtons(mode);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorControls.js ===


=== FILE: src/editor/EditorUI.js ===
--------------------------------------------------
import * as THREE from 'three';

export class EditorUI {
    constructor(editor) {
        this.editor = editor;
        this.app = editor.app;
        this.init();
    }

    init() {
        // Toolbar
        document.getElementById('editor-load-btn').onclick = () => document.getElementById('editor-file-input').click();
        document.getElementById('editor-file-input').onchange = (e) => this.editor.actions.loadFile(e);
        document.getElementById('editor-save-btn').onclick = () => this.editor.actions.saveFile();
        document.getElementById('editor-info-btn').onclick = () => this.showInfoModal();
        document.getElementById('editor-mode-translate').onclick = () => this.editor.controls.setTransformMode('translate');
        document.getElementById('editor-mode-rotate').onclick = () => this.editor.controls.setTransformMode('rotate');
        document.getElementById('editor-mode-scale').onclick = () => this.editor.controls.setTransformMode('scale');

        // Scene Accordion
        document.getElementById('skybox-color-input').oninput = (e) => this.editor.actions.updateSkyboxColor(e.target.value);
        document.getElementById('ambient-color-input').oninput = (e) => this.editor.actions.updateAmbientLight('color', e.target.value);
        document.getElementById('ambient-intensity-input').oninput = (e) => this.editor.actions.updateAmbientLight('intensity', e.target.value);

        // Create Accordion
        document.getElementById('editor-add-box').onclick = () => this.editor.actions.addBox();
        document.getElementById('editor-add-enemy').onclick = () => this.editor.actions.addEnemy();
        document.getElementById('add-dirlight-btn').onclick = () => this.app.addDirectionalLight();
        document.getElementById('editor-add-msg-trigger').onclick = () => this.editor.actions.addMessageTrigger();
        document.getElementById('editor-add-death-trigger').onclick = () => this.editor.actions.addDeathTrigger();
        document.getElementById('editor-set-spawn').onclick = () => this.editor.actions.setSpawnPointToCamera();
        document.getElementById('editor-set-death-spawn').onclick = () => this.editor.actions.setDeathSpawnPointToCamera();

        // View Options Accordion
        document.getElementById('view-toggle-msg-triggers').onchange = (e) => this.setHelpersVisibility('msgTriggers', e.target.checked);
        document.getElementById('view-toggle-death-triggers').onchange = (e) => this.setHelpersVisibility('deathTriggers', e.target.checked);
        document.getElementById('view-toggle-light-helpers').onchange = (e) => this.setHelpersVisibility('lightHelpers', e.target.checked);
        document.getElementById('view-toggle-spawn-helpers').onchange = (e) => this.setHelpersVisibility('spawnHelpers', e.target.checked);

        // Outliner
        this.outlinerList = document.getElementById('outliner-list');
        this.outlinerList.onclick = (e) => {
            const item = e.target.closest('.outliner-item');
            if (item) this.editor.selectByUUID(item.dataset.uuid);
        };

        // Properties Panel
        this.propertiesAccordion = document.getElementById('properties-accordion');
        this.propertiesContent = document.getElementById('properties-content');
        document.getElementById('editor-delete-btn').onclick = () => this.editor.actions.deleteSelected();
        
        // Modal Events
        document.querySelector('#editor-info-modal .modal-close-btn').onclick = () => {
            document.getElementById('editor-info-modal').style.display = 'none';
        };
        document.getElementById('editor-info-modal').onclick = (e) => {
            if(e.target === e.currentTarget) e.currentTarget.style.display = 'none';
        };
    }

    showInfoModal() {
        // --- Player & Physics Parameters (from Player.js and Physics.js) ---
        const playerRadius = 0.8;
        const speed = 8;
        const jumpVy = 8;
        const dashMultiplier = 4;
        const dashDuration = 0.2;
        const gravity = 9.82; // Absolute value

        // --- Calculations ---
        const playerHeight = playerRadius * 2;
        const dashSpeed = speed * dashMultiplier;
        const groundDashDist = dashSpeed * dashDuration;

        // Single Jump
        const timeToPeak1 = jumpVy / gravity;
        const height1 = (jumpVy * jumpVy) / (2 * gravity);
        const airTime1 = 2 * timeToPeak1;
        const distance1 = speed * airTime1;

        // Double Jump (Max Height: jump at peak of first)
        const height2 = height1 + height1; // Second jump from peak (v=0) gains same height
        const timeToFallFromH2 = Math.sqrt((2 * height2) / gravity);
        const airTime2_height = timeToPeak1 + timeToFallFromH2;
        const distance2_height = speed * airTime2_height;
        
        // Jump + Dash (Max Distance: dash at peak)
        const horizontalDistToPeak = speed * timeToPeak1;
        const timeToFallFromH1 = timeToPeak1; // Symmetry
        const horizontalDistAfterDash = speed * timeToFallFromH1;
        const jumpDashDist = horizontalDistToPeak + groundDashDist + horizontalDistAfterDash;

        const infoText = `
[Base Parameters]
Player Collider Height: ${playerHeight.toFixed(2)}m
Ground Speed          : ${speed.toFixed(2)} m/s
Dash Speed            : ${dashSpeed.toFixed(2)} m/s
Gravity               : ${gravity.toFixed(2)} m/s²

[Ground Movement]
Dash Distance         : ${groundDashDist.toFixed(2)}m

[Single Jump]
Max Height            : ${height1.toFixed(2)}m (Gap clearance: ${(height1 + playerHeight).toFixed(2)}m)
Max Distance          : ${distance1.toFixed(2)}m
Air Time              : ${airTime1.toFixed(2)}s

[Double Jump (for max height)]
Max Height            : ${height2.toFixed(2)}m (Gap clearance: ${(height2 + playerHeight).toFixed(2)}m)
Horizontal Distance   : ${distance2_height.toFixed(2)}m
Air Time              : ${airTime2_height.toFixed(2)}s

[Jump + Dash (for max distance)]
Max Distance          : ${jumpDashDist.toFixed(2)}m

NOTE: Distances are ideal, assuming flat ground. "Gap clearance" is max height + player height.
        `.trim();

        document.getElementById('info-modal-text').textContent = infoText;
        document.getElementById('editor-info-modal').style.display = 'flex';
    }


    updateTransformModeButtons(mode) {
        ['translate', 'rotate', 'scale'].forEach(m => {
            document.getElementById(`editor-mode-${m}`).classList.toggle('active', m === mode);
        });
    }

    updateOutliner() {
        this.outlinerList.innerHTML = '';
        const createItem = (entity, name, uuid, prefix = '') => {
            const item = document.createElement('div');
            item.className = 'outliner-item';
            item.textContent = `${prefix} ${name}`;
            item.dataset.uuid = uuid;
            if (entity === this.editor.selectedObject) item.classList.add('selected');
            this.outlinerList.appendChild(item);
        };

        if (this.app.spawnPointHelper) createItem(this.app.spawnPointHelper, 'Initial Spawn', this.app.spawnPointHelper.uuid, '[P]');
        if (this.app.deathSpawnPointHelper) createItem(this.app.deathSpawnPointHelper, 'Death Spawn', this.app.deathSpawnPointHelper.uuid, '[P]');
        this.app.directionalLights.forEach((l, i) => createItem(l, `Directional Light ${i+1}`, l.picker.uuid, '[L]'));
        this.app.levelObjects.forEach(o => createItem(o, o.definition.name || 'Object', o.mesh.uuid, '[G]'));
        this.app.enemies.forEach(e => createItem(e, e.name || 'Enemy', e.mesh.uuid, '[E]'));
        this.app.triggers.forEach((t, i) => createItem(t, t.definition.name || `Trigger ${i+1}`, t.mesh.uuid, '[T]'));
        this.app.deathTriggers.forEach((t, i) => createItem(t, t.definition.name || `Death Zone ${i+1}`, t.mesh.uuid, '[D]'));
    }

    updatePropertiesPanel() {
        if (!this.editor.selectedObject) {
            this.propertiesAccordion.style.display = 'none';
            return;
        }
        this.propertiesContent.innerHTML = '';
        const entity = this.editor.selectedObject;
        const entityType = entity.userData?.gameEntity?.type;
        
        if (!entityType) return;
        
        this.propertiesAccordion.style.display = 'block';
        this.propertiesAccordion.open = true;
        const fragment = document.createDocumentFragment();

        const handleEnterKey = (e, updateFn) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                updateFn(e.target.value);
                e.target.blur();
            }
        };

        const createVec3Inputs = (label, vector, callback) => {
            fragment.appendChild(document.createElement('label')).textContent = label;
            const group = fragment.appendChild(document.createElement('div'));
            group.className = 'prop-group';
            ['x', 'y', 'z'].forEach(axis => {
                const input = document.createElement('input');
                input.type = 'number';
                input.step = label.toLowerCase().includes('rot') ? 1 : 0.1;
                input.value = vector[axis].toFixed(2);
                const updateValue = (val) => callback(axis, parseFloat(val));
                input.onchange = (e) => updateValue(e.target.value);
                input.onkeydown = (e) => handleEnterKey(e, updateValue);
                group.appendChild(input);
            });
        };
        
        const createSizeInputs = (label, sizeArr, callback) => {
             fragment.appendChild(document.createElement('label')).textContent = label;
             const group = fragment.appendChild(document.createElement('div'));
             group.className = 'prop-group';
             sizeArr.forEach((val, index) => {
                 const input = document.createElement('input');
                 input.type = 'number';
                 input.step = 0.1;
                 input.value = val.toFixed(2);
                 const updateValue = (val) => callback(index, parseFloat(val));
                 input.onchange = (e) => updateValue(e.target.value);
                 input.onkeydown = (e) => handleEnterKey(e, updateValue);
                 group.appendChild(input);
             });
        };
        
        const createColorInput = (label, color, callback) => {
            fragment.appendChild(document.createElement('label')).textContent = label;
            const input = fragment.appendChild(document.createElement('input'));
            input.type = 'color';
            input.value = '#' + color.getHexString();
            input.oninput = (e) => callback(e.target.value);
        };
        
        const createTextInput = (label, value, callback) => {
            fragment.appendChild(document.createElement('label')).textContent = label;
            const input = fragment.appendChild(document.createElement('input'));
            input.type = 'text';
            input.value = value;
            const updateValue = (val) => callback(val);
            input.onchange = (e) => updateValue(e.target.value);
            input.onkeydown = (e) => handleEnterKey(e, updateValue);
        };
        
        const createNumberInput = (label, value, min, max, step, callback) => {
            fragment.appendChild(document.createElement('label')).textContent = label;
            const input = fragment.appendChild(document.createElement('input'));
            input.type = 'number';
            if (min !== undefined) input.min = min;
            if (max !== undefined) input.max = max;
            input.step = step || 1;
            input.value = value;
            const updateValue = (val) => callback(parseFloat(val));
            input.onchange = (e) => updateValue(e.target.value);
            input.onkeydown = (e) => handleEnterKey(e, updateValue);
        };
        
        if (entityType === 'Trigger' || entityType === 'DeathTrigger') {
            const def = entity.definition;
            const mesh = entity.mesh;

            createTextInput('Name', def.name || '', val => this.editor.updateSelectedProp('name', null, val));
            createVec3Inputs('Position', mesh.position, (axis, val) => this.editor.updateSelectedProp('position', axis, val));
            createSizeInputs('Size', def.size, (index, val) => this.editor.updateSelectedProp('size', index, val));
            
            if (entityType === 'Trigger') {
                fragment.appendChild(document.createElement('hr'));
                createTextInput('Message', def.message || '', val => this.editor.updateSelectedProp('message', null, val));
                createNumberInput('Duration (s)', def.duration || 5, 0.1, 100, 0.1, val => this.editor.updateSelectedProp('duration', null, val));
                const initialColor = def.color ? parseInt(def.color, 16) : 0x00ff00;
                createColorInput('Helper Color', new THREE.Color(initialColor), val => this.editor.updateSelectedProp('color', null, val));
            }
        } else if (entityType === 'SpawnPoint' || entityType === 'DeathSpawnPoint') {
             createVec3Inputs('Position', entity.position, (axis, val) => {
                entity.position[axis] = val;
                this.editor.syncObjectTransforms();
             });
        } else if (entityType === 'DirectionalLight') {
             createColorInput('Color', entity.light.color, val => this.editor.updateSelectedProp('color', null, val));
             createNumberInput('Intensity', entity.light.intensity, 0, 20, 0.1, val => this.editor.updateSelectedProp('intensity', null, val));
             createVec3Inputs('Position', entity.light.position, (axis, val) => {
                 entity.picker.position[axis] = val; // Move the picker
                 this.editor.syncObjectTransforms(); // Sync picker to light
                 this.updatePropertiesPanel(); // Redraw panel with new values
             });
             // NEW: Inputs for Target Position
             createVec3Inputs('Target Position', entity.light.target.position, (axis, val) => {
                 this.editor.updateSelectedProp('targetPosition', axis, val);
             });
        } else { // Generic Object or Enemy
            const def = entity.definition;
            const mesh = entity.mesh;
            fragment.appendChild(document.createElement('label')).textContent = `Name: ${def.name || def.type}`;
            createVec3Inputs('Position', mesh.position, (axis, val) => this.editor.updateSelectedProp('position', axis, val));
            if (entity.isDead === undefined && def.type !== 'Plane') {
                 const eulerRot = new THREE.Euler().setFromQuaternion(mesh.quaternion, 'YXZ');
                 const degRot = { x: THREE.MathUtils.radToDeg(eulerRot.x), y: THREE.MathUtils.radToDeg(eulerRot.y), z: THREE.MathUtils.radToDeg(eulerRot.z) };
                 createVec3Inputs('Rotation', degRot, (axis, val) => this.editor.updateSelectedProp('rotation', axis, val));
            }
            if (def.size) createSizeInputs('Size', def.size, (index, val) => this.editor.updateSelectedProp('size', index, val));

            if (def.material) {
                fragment.appendChild(document.createElement('hr'));
                const initialColor = def.material.color ? parseInt(def.material.color, 16) : 0xcccccc;
                createColorInput('Material Color', new THREE.Color(initialColor), val => {
                    this.editor.updateSelectedProp('material.color', null, val);
                });
            }
        }
        this.propertiesContent.appendChild(fragment);
    }
    
    setInitialSceneSettings(settings) {
        if (!settings) return;
        document.getElementById('skybox-color-input').value = '#' + new THREE.Color(parseInt(settings.backgroundColor || "0x000000", 16)).getHexString();
        document.getElementById('ambient-color-input').value = '#' + new THREE.Color(parseInt(settings.ambientLight.color, 16)).getHexString();
        document.getElementById('ambient-intensity-input').value = settings.ambientLight.intensity;
    }

    setHelpersVisibility(type, isVisible) {
        this.editor.helperVisibility[type] = isVisible;
        switch (type) {
            case 'msgTriggers':   this.app.triggers.forEach(t => t.mesh.visible = isVisible); break;
            case 'deathTriggers': this.app.deathTriggers.forEach(t => t.mesh.visible = isVisible); break;
            case 'lightHelpers':  this.app.directionalLights.forEach(l => l.helper.visible = isVisible); break;
            case 'spawnHelpers':
                if (this.app.spawnPointHelper) this.app.spawnPointHelper.visible = isVisible;
                if (this.app.deathSpawnPointHelper) this.app.deathSpawnPointHelper.visible = isVisible;
                break;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorUI.js ===


=== FILE: src/editor/LevelEditor.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { EditorControls } from './EditorControls.js';
import { EditorUI } from './EditorUI.js';
import { EditorActions } from './EditorActions.js';
import { EditorCamera } from './EditorCamera.js';
import { UndoManager, StateChangeCommand } from './UndoManager.js';

export class LevelEditor {
    constructor(app) {
        this.app = app;
        this.scene = app.scene;
        this.camera = app.camera;
        this.renderer = app.renderer.renderer;
        this.physics = app.physics;
        this.input = app.input;

        // Core State
        this.selectedObject = null;
        this.clipboard = null;
        this.helperVisibility = {
            msgTriggers: true,
            deathTriggers: true,
            lightHelpers: true,
            spawnHelpers: true,
        };

        // Internal state for rotation logic
        this._initialLightPos = null;
        this._initialPickerQuat = null;

        // Modules
        this.undoManager = new UndoManager(this);
        this.ui = new EditorUI(this);
        this.controls = new EditorControls(this);
        this.actions = new EditorActions(this);
        this.cameraController = new EditorCamera(this);
        
        this.onKeyDownHandler = this.onKeyDown.bind(this);
        document.addEventListener('keydown', this.onKeyDownHandler);
    }

    dispose() {
        document.removeEventListener('keydown', this.onKeyDownHandler);
        this.controls.dispose();
    }

    onKeyDown(event) {
        if (event.target.tagName === 'INPUT' || this.controls.transformControls.dragging) return;

        if (event.ctrlKey) {
            switch (event.code) {
                case 'KeyC': event.preventDefault(); this.actions.copySelected(); break;
                case 'KeyV': event.preventDefault(); this.actions.pasteFromClipboard(); break;
                case 'KeyZ': event.preventDefault(); this.undoManager.undo(); break;
                case 'KeyY': event.preventDefault(); this.undoManager.redo(); break;
            }
        } else {
            switch (event.code) {
                case 'KeyT': this.controls.setTransformMode('translate'); break;
                case 'KeyR': this.controls.setTransformMode('rotate'); break;
                case 'KeyS': this.controls.setTransformMode('scale'); break;
                case 'Delete':
                case 'Backspace': this.actions.deleteSelected(); break;
            }
        }
    }

    // --- State & Selection Management ---

    select(entity) {
        if (!entity || this.selectedObject === entity) return;
        this.deselect();
        
        this.selectedObject = entity;
        const entityType = entity.userData?.gameEntity?.type;
        let objectToAttach = entity.mesh || entity.picker || entity;

        if (entityType === 'DirectionalLight') entity.picker.material.visible = true;

        this.controls.transformControls.attach(objectToAttach);
        this.controls.selectionBox.setFromObject(objectToAttach);
        this.controls.selectionBox.visible = true;
        
        this.ui.propertiesAccordion.style.display = 'block';
        this.ui.propertiesAccordion.open = true;
        
        this.ui.updatePropertiesPanel();
        this.ui.updateOutliner();
        
        const isEnemy = entity.isDead !== undefined;
        const isTrigger = entityType === 'Trigger' || entityType === 'DeathTrigger';
        const canRotate = !(entityType === 'SpawnPoint' || entityType === 'DeathSpawnPoint' || isTrigger);
        const canScale = !(entityType === 'SpawnPoint' || entityType === 'DeathSpawnPoint' || entityType === 'DirectionalLight' || isEnemy || isTrigger);
        
        document.getElementById('editor-mode-rotate').disabled = !canRotate;
        document.getElementById('editor-mode-scale').disabled = !canScale;

        if (!canRotate && this.controls.transformControls.getMode() === 'rotate') this.controls.setTransformMode('translate');
        if (!canScale && this.controls.transformControls.getMode() === 'scale') this.controls.setTransformMode('translate');
    }

    deselect() {
        if (!this.selectedObject) return;
        
        if (this.selectedObject.userData?.gameEntity?.type === 'DirectionalLight') {
            this.selectedObject.picker.material.visible = false;
        }

        this.selectedObject = null;
        this.controls.transformControls.detach();
        this.controls.selectionBox.visible = false;
        this.ui.propertiesAccordion.style.display = 'none';
        this.ui.updateOutliner();
        
        document.getElementById('editor-mode-rotate').disabled = false;
        document.getElementById('editor-mode-scale').disabled = false;
    }

    selectByUUID(uuid) {
        const allEntities = [
            ...this.app.levelObjects, ...this.app.enemies, ...this.app.directionalLights,
            ...this.app.triggers, ...this.app.deathTriggers,
            this.app.spawnPointHelper, this.app.deathSpawnPointHelper,
        ].filter(Boolean);

        const entityToSelect = allEntities.find(e => (e.mesh || e.picker || e).uuid === uuid);
        if (entityToSelect) this.select(entityToSelect);
    }
    
    // --- Data & Property Manipulation ---

    updateSelectedProp(prop, key, value) {
        if (!this.selectedObject) return;
        const entity = this.selectedObject;
        const entityType = entity.userData?.gameEntity?.type;
        
        const beforeState = entity.definition;
        const afterState = JSON.parse(JSON.stringify(beforeState)); // Create a working copy
        let target = afterState;

        // Navigate to the correct property in the copied state
        const path = prop.split('.');
        for(let i = 0; i < path.length - 1; i++) {
            if(!target[path[i]]) target[path[i]] = {};
            target = target[path[i]];
        }
        const finalKey = path[path.length - 1];
        
        // Update the value in the copied state
        if (key !== null) { // For vectors
            if(!target[finalKey]) target[finalKey] = {};
            target[finalKey][key] = value;
        } else { // For direct properties
            target[finalKey] = value.toString().startsWith('#') ? value.replace('#', '0x') : value;
        }

        const command = new StateChangeCommand(this, entity, beforeState, afterState);
        this.undoManager.execute(command);
    }
    
    applyDefinition(obj) {
        const type = obj.userData?.gameEntity?.type;
        const def = obj.definition;
        const mesh = obj.mesh;
        const body = obj.body;

        if (type === 'SpawnPoint' || type === 'DeathSpawnPoint') {
            this.controls.selectionBox.setFromObject(obj);
            return;
        }

        if (type === 'DirectionalLight') {
            const light = obj.light;
            light.color.set(parseInt(def.color, 16));
            light.intensity = def.intensity;
            light.position.set(def.position.x, def.position.y, def.position.z);
            if (def.targetPosition) {
                light.target.position.set(def.targetPosition.x, def.targetPosition.y, def.targetPosition.z);
            }
            obj.picker.position.copy(light.position);
            light.target.updateMatrixWorld(true);
            obj.helper.update();
            this.controls.selectionBox.setFromObject(obj.picker);
            return;
        }
        
        // Position
        mesh.position.set(def.position.x, def.position.y, def.position.z);
        
        // Rotation
        if (def.rotation && obj.isDead === undefined) {
             mesh.rotation.set(
                THREE.MathUtils.degToRad(def.rotation.x || 0),
                THREE.MathUtils.degToRad(def.rotation.y || 0),
                THREE.MathUtils.degToRad(def.rotation.z || 0)
            );
        }

        // Material Color
        if (type !== 'Trigger' && def.material && def.material.color && mesh.material) {
            mesh.material.color.set(parseInt(def.material.color, 16));
        }

        // Size & Geometry
        if((type === 'Trigger' || type === 'DeathTrigger') && def.size) {
            mesh.geometry.dispose();
            mesh.geometry = new THREE.BoxGeometry(...def.size);
            if(type === 'Trigger' && def.color) { // Handle trigger color
                mesh.material.color.set(parseInt(def.color, 16));
            }
        } else if(def.size && def.type === 'Box' && body?.shapes[0]) {
            const halfExtents = new CANNON.Vec3(def.size[0]/2, def.size[1]/2, def.size[2]/2);
            body.shapes[0].halfExtents.copy(halfExtents);
            body.shapes[0].updateConvexPolyhedronRepresentation();
            body.updateBoundingRadius();
            mesh.geometry.dispose();
            mesh.geometry = new THREE.BoxGeometry(...def.size);
        }
        
        this.syncObjectTransforms();
        this.controls.selectionBox.setFromObject(mesh);
    }
    
    syncObjectTransforms() {
        if (!this.selectedObject) return;
        
        const entity = this.selectedObject;
        const entityType = entity.userData?.gameEntity?.type;
        
        if (entityType === 'Trigger' || entityType === 'DeathTrigger') {
            entity.definition.position = { x: entity.mesh.position.x, y: entity.mesh.position.y, z: entity.mesh.position.z };
        } else if (entityType === 'SpawnPoint') {
            this.app.spawnPoint.x = entity.position.x;
            this.app.spawnPoint.y = entity.position.y;
            this.app.spawnPoint.z = entity.position.z;
        } else if (entityType === 'DeathSpawnPoint') {
            this.app.deathSpawnPoint.x = entity.position.x;
            this.app.deathSpawnPoint.y = entity.position.y;
            this.app.deathSpawnPoint.z = entity.position.z;
        } else if (entityType === 'DirectionalLight') {
            const picker = entity.picker;
            const light = entity.light;

            if (this.controls.transformControls.mode === 'rotate' && this.controls.transformControls.dragging && this._initialLightPos) {
                const deltaQuat = picker.quaternion.clone().multiply(this._initialPickerQuat.clone().invert());
                light.position.copy(this._initialLightPos).applyQuaternion(deltaQuat);
                picker.position.copy(light.position);
            } else {
                light.position.copy(picker.position);
            }
            
            // light.target.position is now managed by its definition and the UI
            entity.helper.update();

            if (this.selectedObject === entity) this.controls.selectionBox.setFromObject(picker);
        } else {
            if (entity.body) {
                entity.body.position.copy(entity.mesh.position);
                entity.body.quaternion.copy(entity.mesh.quaternion);
            }
        }
    }
    
    setLevelData() {
        this.deselect();
        this.ui.updateOutliner();
        this.ui.setInitialSceneSettings(this.app.settings);

        // Apply initial visibility from UI checkboxes
        this.ui.setHelpersVisibility('msgTriggers', document.getElementById('view-toggle-msg-triggers').checked);
        this.ui.setHelpersVisibility('deathTriggers', document.getElementById('view-toggle-death-triggers').checked);
        this.ui.setHelpersVisibility('lightHelpers', document.getElementById('view-toggle-light-helpers').checked);
        this.ui.setHelpersVisibility('spawnHelpers', document.getElementById('view-toggle-spawn-helpers').checked);
    }
    
    update(deltaTime) {
        this.cameraController.update(deltaTime);
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/LevelEditor.js ===


=== FILE: src/editor/UndoManager.js ===
--------------------------------------------------
export class StateChangeCommand {
    constructor(editor, entity, beforeState, afterState) {
        this.editor = editor;
        this.entity = entity;
        this.beforeState = JSON.parse(JSON.stringify(beforeState)); // Deep copy
        this.afterState = JSON.parse(JSON.stringify(afterState)); // Deep copy
    }

    execute() {
        this.entity.definition = JSON.parse(JSON.stringify(this.afterState));
        this.editor.applyDefinition(this.entity);
        this.editor.select(this.entity); // Reselect to update UI
    }

    undo() {
        this.entity.definition = JSON.parse(JSON.stringify(this.beforeState));
        this.editor.applyDefinition(this.entity);
        this.editor.select(this.entity); // Reselect to update UI
    }
}


export class UndoManager {
    constructor(editor) {
        this.editor = editor;
        this.undoStack = [];
        this.redoStack = [];
        this.maxHistory = 50;
    }

    execute(command) {
        this.undoStack.push(command);
        if (this.undoStack.length > this.maxHistory) {
            this.undoStack.shift(); // Keep history size manageable
        }
        this.redoStack = []; // Clear redo stack on new action
        command.execute();
        console.log("Action executed. Undo stack size:", this.undoStack.length);
    }

    undo() {
        if (this.undoStack.length === 0) return;
        const command = this.undoStack.pop();
        this.redoStack.push(command);
        command.undo();
        console.log("Action undone. Undo stack size:", this.undoStack.length);
    }

    redo() {
        if (this.redoStack.length === 0) return;
        const command = this.redoStack.pop();
        this.undoStack.push(command);
        command.execute();
        console.log("Action redone. Undo stack size:", this.undoStack.length);
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/UndoManager.js ===


=== FILE: src/engine/InputManager.js ===
--------------------------------------------------
export class InputManager {
    constructor() {
        this.keys = {};
        this.mouse = {
            movementX: 0,
            movementY: 0,
            leftClick: false,
            rightClick: false,
            screenX: 0,
            screenY: 0,
        };
        this.enabled = true;

        document.addEventListener('keydown', (e) => this.keys[e.code] = true);
        document.addEventListener('keyup', (e) => this.keys[e.code] = false);

        document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        document.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
    }

    handleMouseMove(event) {
        this.mouse.screenX = event.clientX;
        this.mouse.screenY = event.clientY;
        // Always update movement properties. The consumer (game/editor) will decide how to use them.
        // The game uses them when pointer is locked. The editor will use them when a mouse button is held.
        this.mouse.movementX = event.movementX;
        this.mouse.movementY = event.movementY;
    }

    handleMouseDown(event) {
        if (event.button === 0) this.mouse.leftClick = true;
        if (event.button === 2) this.mouse.rightClick = true;
    }
    
    handleMouseUp(event) {
        if (event.button === 0) this.mouse.leftClick = false;
        if (event.button === 2) this.mouse.rightClick = false;
    }
    
    isClickOnUI(x, y) {
        const editorUI = document.getElementById('editor-ui');
        if (!editorUI) return false;

        const rect = editorUI.getBoundingClientRect();
        return (
            x >= rect.left &&
            x <= rect.right &&
            y >= rect.top &&
            y <= rect.bottom
        );
    }

    update() {
        this.mouse.movementX = 0;
        this.mouse.movementY = 0;
    }
}
--------------------------------------------------
=== END OF FILE: src/engine/InputManager.js ===


=== FILE: src/engine/Physics.js ===
--------------------------------------------------
import * as CANNON from 'cannon-es';

export class Physics {
    constructor() {
        this.world = new CANNON.World({
            gravity: new CANNON.Vec3(0, -9.82, 0)
        });

        // A queue for bodies to be safely removed after the physics step.
        this.bodiesToRemove = [];
    }

    /**
     * Safely queues a physics body for removal from the world.
     * The body will be removed after the next physics step.
     * @param {CANNON.Body} body The body to remove.
     */
    queueForRemoval(body) {
        // Avoid adding the same body multiple times.
        if (body && !this.bodiesToRemove.includes(body)) {
            this.bodiesToRemove.push(body);
        }
    }

    update(deltaTime) {
        // Run the simulation step first.
        this.world.step(1 / 60, deltaTime, 3);

        // AFTER the simulation, safely remove any bodies from the queue.
        if (this.bodiesToRemove.length > 0) {
            for (const body of this.bodiesToRemove) {
                this.world.removeBody(body);
            }
            // Clear the queue for the next frame.
            this.bodiesToRemove = [];
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/engine/Physics.js ===


=== FILE: src/engine/Renderer.js ===
--------------------------------------------------
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

export class Renderer {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);

        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            canvas: document.getElementById('game-canvas')
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        
        // --- PERFORMANCE: Shadow Map Configuration ---
        // Enabling shadows is expensive. Configuring them properly is key.
        this.renderer.shadowMap.enabled = true;
        // PCFSoftShadowMap gives softer, more realistic shadows than the default.
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        
        this.bloomPass = null; // Will be initialized in setupPostProcessing

        window.addEventListener('resize', () => this.onWindowResize());
    }

    setupPostProcessing(scene, camera, viewModelScene) {
        this.composer = new EffectComposer(this.renderer);
        this.composer.addPass(new RenderPass(scene, camera));

        // Add a separate render pass for the view model (e.g., player hands)
        // This ensures they render on top of the main scene without clipping.
        if (viewModelScene) {
            const viewModelPass = new RenderPass(viewModelScene, camera);
            viewModelPass.clear = false; // Don't clear the color buffer
            viewModelPass.clearDepth = true; // DO clear the depth buffer
            this.composer.addPass(viewModelPass);
        }
        
        // MODIFIED: Tuned bloom pass to be less aggressive.
        this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        this.bloomPass.threshold = 0.9;
        this.bloomPass.strength = 0.7;
        this.bloomPass.radius = 0.5;
        this.composer.addPass(this.bloomPass);
    }
    
    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        if (this.composer) {
            this.composer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    render() {
        if (this.composer) {
            this.composer.render();
        } else {
            this.renderer.render(this.scene, this.camera);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/engine/Renderer.js ===


=== FILE: src/game/Game.js ===
--------------------------------------------------
import * as THREE from 'three';
import { Renderer } from '../engine/Renderer.js';
import { Physics } from '../engine/Physics.js';
import { InputManager } from '../engine/InputManager.js';
import { LevelLoader } from '../world/LevelLoader.js';
import { Player } from './entities/Player.js';
import { HUD } from './ui/HUD.js';
import { TutorialManager } from './ui/TutorialManager.js';

export class Game {
    constructor() {
        this.clock = new THREE.Clock();
        this.renderer = new Renderer();
        this.physics = new Physics();
        this.input = new InputManager();

        this.viewModelScene = new THREE.Scene();

        this.updatables = []; 
        this.activeEffects = [];
        this.levelObjects = [];
        this.enemies = [];

        // --- Game State & UI ---
        this.gameState = 'MENU'; // MENU, LOADING, PLAYING, PAUSED, DEAD
        this.respawnTimer = 0;
        this.RESPAWN_COOLDOWN = 5.0;

        this.ui = {
            main: document.getElementById('main-menu'),
            levelSelect: document.getElementById('level-select-menu'),
            pause: document.getElementById('pause-menu'),
            death: document.getElementById('death-screen'),
            levelList: document.getElementById('level-list'),
            respawnTimerText: document.getElementById('respawn-timer-text'),
            playBtn: document.getElementById('play-btn'),
            tutorialBtn: document.getElementById('tutorial-btn'),
            resumeBtn: document.getElementById('resume-btn'),
            pauseQuitBtn: document.getElementById('pause-quit-btn'),
            deathQuitBtn: document.getElementById('death-quit-btn'),
        };

        this.currentLevelUrl = null;
    }

    async init() {
        this.levelLoader = new LevelLoader(this);
        
        this.renderer.setupPostProcessing(this.renderer.scene, this.renderer.camera, this.viewModelScene);
        
        this.player = new Player(this.renderer.camera, this.physics.world, this.input, this.viewModelScene, this);
        this.player.isDead = true;

        this.hud = new HUD(this.player, this);
        this.updatables.push(this.hud);
        
        this.tutorialManager = new TutorialManager(this);

        await this.populateLevelList();
        this.setupEventListeners();
        this.returnToMenu(); // Start in the main menu

        this._warmupShaders();
        this.renderer.renderer.setAnimationLoop(() => this.animate());
    }

    setupEventListeners() {
        this.ui.playBtn.onclick = () => this.showScreen(this.ui.levelSelect);
        this.ui.tutorialBtn.onclick = () => this.startGame('./levels/level-tutorial.json');

        document.querySelectorAll('.back-button').forEach(btn => 
            btn.onclick = () => this.showScreen(document.getElementById(btn.dataset.target))
        );

        // For unpausing, we just request the lock. The 'pointerlockchange' event handles the rest.
        this.ui.resumeBtn.onclick = () => document.body.requestPointerLock();
        
        this.ui.pauseQuitBtn.onclick = () => this.returnToMenu();
        this.ui.deathQuitBtn.onclick = () => this.returnToMenu();

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                if (this.gameState === 'PAUSED') {
                    // Just request the lock. The 'pointerlockchange' event will handle the rest.
                    document.body.requestPointerLock();
                }
                // If 'PLAYING', the browser's default ESC action will release the lock,
                // which is caught by our 'pointerlockchange' listener to pause the game.
            }
        });

        // This is the definitive source of truth for the pointer lock state.
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === document.body) {
                // We just GAINED pointer lock.
                if (this.gameState === 'PAUSED') {
                    this.gameState = 'PLAYING';
                    this.ui.pause.style.display = 'none';
                    document.body.classList.add('game-active');
                }
            } else {
                // We just LOST pointer lock.
                if (this.gameState === 'PLAYING') {
                    this.gameState = 'PAUSED';
                    this.showScreen(this.ui.pause);
                    document.body.classList.remove('game-active');
                }
            }
        }, false);
    }

    async populateLevelList() {
        try {
            const response = await fetch('./levels/manifest.json');
            const levels = await response.json();
            this.ui.levelList.innerHTML = '';
            for (const level of levels) {
                // Don't show the tutorial in the regular level list
                if (level.name.toLowerCase() === 'tutorial') continue;
                
                const btn = document.createElement('button');
                btn.textContent = level.name;
                btn.onclick = () => this.startGame(level.path);
                this.ui.levelList.appendChild(btn);
            }
        } catch (error) {
            console.error("Could not load level manifest:", error);
            this.ui.levelList.innerHTML = '<p style="color: #ff4757;">Could not load levels.</p>';
        }
    }

    showScreen(screenToShow) {
        Object.values(this.ui).forEach(element => {
            if (element instanceof HTMLElement && element.classList.contains('menu-screen')) {
                element.style.display = 'none';
            }
        });
        screenToShow.style.display = 'flex';
    }

    async startGame(levelUrl) {
        this.gameState = 'LOADING';
        this.currentLevelUrl = levelUrl;
        
        document.body.requestPointerLock();

        this.showScreen(this.ui.main);
        this.ui.main.innerHTML = '<h2>Loading...</h2>';

        await this.loadLevel(levelUrl);

        if (document.pointerLockElement !== document.body) {
            this.returnToMenu();
            return;
        }
        
        this.player.spawn(this.levelLoader.getSpawnPoint());
        this.gameState = 'PLAYING';
        
        Object.values(this.ui).forEach(element => {
            if (element instanceof HTMLElement && element.classList.contains('menu-screen')) {
                 element.style.display = 'none';
            }
        });

        document.body.classList.add('game-active');
    }
    
    handlePlayerDeath() {
        if (this.gameState === 'DEAD') return;
        this.gameState = 'DEAD';
        this.respawnTimer = this.RESPAWN_COOLDOWN;
        this.showScreen(this.ui.death);
        document.body.classList.remove('game-active');
        if (document.pointerLockElement) document.exitPointerLock();
    }
    
    async respawnPlayer() {
        this.gameState = 'LOADING';
        this.ui.death.innerHTML = '<h2>Loading...</h2>';
        
        await this.loadLevel(this.currentLevelUrl);
        
        this.ui.death.innerHTML = `
            <h2>YOU DIED</h2>
            <p id="respawn-timer-text">Respawning in 5...</p>
            <div class="menu-options">
                <button id="death-quit-btn">Return to Menu</button>
            </div>`;
        this.ui.respawnTimerText = document.getElementById('respawn-timer-text');
        this.ui.deathQuitBtn = document.getElementById('death-quit-btn');
        this.ui.deathQuitBtn.onclick = () => this.returnToMenu();
        
        const respawnPos = this.levelLoader.getDeathSpawnPoint() || this.levelLoader.getSpawnPoint();
        this.player.spawn(respawnPos);
        this.gameState = 'PLAYING';
        this.ui.death.style.display = 'none';

        document.body.classList.add('game-active');
        document.body.requestPointerLock();
    }

    returnToMenu() {
        this.gameState = 'MENU';
        this.player.isDead = true;
        this.clearLevel();
        this.showScreen(this.ui.main);
         this.ui.main.innerHTML = `
            <h1>ELEMENTALS</h1>
            <div class="menu-options">
                <button id="play-btn">Play</button>
                <button id="tutorial-btn">How to Play</button>
            </div>`;
        this.ui.playBtn = document.getElementById('play-btn');
        this.ui.tutorialBtn = document.getElementById('tutorial-btn');
        this.ui.playBtn.onclick = () => this.showScreen(this.ui.levelSelect);
        this.ui.tutorialBtn.onclick = () => this.startGame('./levels/level-tutorial.json');
        document.body.classList.remove('game-active');
        if (document.pointerLockElement) document.exitPointerLock();
    }

    async loadLevel(levelUrl) {
        this.clearLevel();
        const levelData = await this.levelLoader.load(levelUrl);
        const { levelObjects, enemies } = this.levelLoader.build(levelData);
        this.levelObjects = levelObjects;
        this.enemies = enemies;
        this.tutorialManager.loadTriggers(levelData.triggers || []);
    }

    clearLevel() {
        this.tutorialManager.clearTriggers();
        for (const obj of this.levelObjects) {
            this.renderer.scene.remove(obj.mesh);
            obj.mesh.geometry.dispose();
            obj.mesh.material.dispose();
            if(obj.body) this.physics.queueForRemoval(obj.body);
        }
        [...this.enemies].forEach(enemy => enemy.die(true));
        this.levelObjects = [];
        this.enemies = [];
    }

    animate() {
        const deltaTime = this.clock.getDelta();
        
        if (this.gameState === 'PLAYING' || this.gameState === 'PAUSED') {
            this.physics.update(deltaTime);
        }
        
        if (this.gameState === 'PLAYING') {
            for (let i = this.updatables.length - 1; i >= 0; i--) {
                this.updatables[i]?.update(deltaTime);
            }
            this.player.update(deltaTime);
        } else if (this.gameState === 'DEAD') {
            this.respawnTimer -= deltaTime;
            this.ui.respawnTimerText.textContent = `Respawning in ${Math.ceil(this.respawnTimer)}...`;
            if (this.respawnTimer <= 0) {
                this.respawnPlayer();
            }
            this.hud.update(); // Update HUD to show empty bars
        } else if (this.gameState === 'PAUSED') {
             this.hud.update();
        }
        
        this.renderer.render();
    }
    
    _warmupShaders() {
        console.log("Warming up shaders...");
        const scene = this.renderer.scene;
        const offscreenPos = new THREE.Vector3(10000, 10000, 10000);
    
        // Materials to pre-compile
        const materials = [
            // Fireball Material
            new THREE.MeshStandardMaterial({ color: 0xff8800, emissive: 0xff4400, emissiveIntensity: 5 }),
            // ParticleExplosion Material
            new THREE.PointsMaterial({ color: 0xff8800, size: 0.1, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }),
            // Enemy Projectile Material
            new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 10 }),
        ];
    
        const dummyGeometry = new THREE.PlaneGeometry(0.01, 0.01);
        const dummyObjects = materials.map(material => {
            const mesh = material.isPointsMaterial 
                ? new THREE.Points(dummyGeometry, material) 
                : new THREE.Mesh(dummyGeometry, material);
            mesh.position.copy(offscreenPos);
            mesh.visible = false;
            scene.add(mesh);
            return { mesh, material };
        });
    
        // Render a single frame to force shader compilation
        this.renderer.render();
    
        // Clean up dummy objects and materials
        dummyObjects.forEach(({ mesh, material }) => {
            scene.remove(mesh);
            material.dispose();
        });
        dummyGeometry.dispose();
    
        console.log("Shaders warmed up.");
    }
}
--------------------------------------------------
=== END OF FILE: src/game/Game.js ===


=== FILE: src/game/abilities/Ability.js ===
--------------------------------------------------
export class Ability {
    constructor(caster, { name, icon, cooldown, energyCost }) {
        this.caster = caster;
        this.name = name || 'Unnamed Ability';
        this.icon = icon || '?';
        this.cooldown = cooldown || 0;
        this.energyCost = energyCost || 0;

        this.cooldownTimer = this.cooldown; // Start ready to cast
    }

    /**
     * Checks if the ability can be cast based on cooldown and energy.
     * @returns {boolean}
     */
    canCast() {
        const isReady = this.cooldownTimer >= this.cooldown;
        const hasEnergy = this.caster.currentEnergy >= this.energyCost;
        return isReady && hasEnergy;
    }

    /**
     * Executes the ability's logic. MUST be overridden by subclasses.
     * @returns {boolean} True if the cast was successful, false otherwise.
     */
    cast() {
        throw new Error("Ability.cast() must be implemented by subclasses.");
    }

    /**
     * Resets the cooldown timer after casting.
     */
    triggerCooldown() {
        this.cooldownTimer = 0;
    }

    /**
     * Gets the current cooldown progress as a value from 0.0 to 1.0.
     * @returns {number}
     */
    getCooldownProgress() {
        if (this.cooldown === 0) return 1.0;
        return Math.min(this.cooldownTimer / this.cooldown, 1.0);
    }
    
    /**
     * Updates the cooldown timer.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    update(deltaTime) {
        if (this.cooldownTimer < this.cooldown) {
            this.cooldownTimer += deltaTime;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/Ability.js ===


=== FILE: src/game/abilities/EnemyProjectile.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../../common/CollisionGroups.js';

/**
 * A projectile fired by an enemy entity. It is given an initial velocity and is affected by gravity.
 */
export class EnemyProjectile {
    constructor({caster, initialVelocity}) {
        this.game = caster.game;
        this.scene = caster.scene;
        this.world = caster.world;
        
        // --- Configuration ---
        this.damage = 100;
        this.lifetime = 3.0;
        this.isDead = false;

        // --- Visuals ---
        const geometry = new THREE.SphereGeometry(0.2, 16, 16);
        const material = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 10 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;
        this.light = new THREE.PointLight(0x00ffff, 200, 20, 2);
        this.mesh.add(this.light);

        // --- Physics ---
        const shape = new CANNON.Sphere(0.2);
        this.body = new CANNON.Body({
            mass: 0.1,
            shape,
            collisionFilterGroup: COLLISION_GROUPS.PROJECTILE,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.PLAYER,
            type: CANNON.Body.DYNAMIC,
            linearDamping: 0,
            angularDamping: 0,
        });

        // --- Trajectory ---
        // Spawn slightly in front of the caster.
        const spawnDirection = new CANNON.Vec3().copy(initialVelocity);
        spawnDirection.normalize(); // This modifies the vector in-place. Do not chain it.
        
        const spawnPos = new CANNON.Vec3().copy(caster.body.position);
        
        // Create the offset vector and add it to the spawn position.
        const offset = spawnDirection.scale(2);
        spawnPos.vadd(offset, spawnPos);
        
        this.body.position.copy(spawnPos);
        
        // Use the pre-calculated velocity from the enemy AI.
        this.body.velocity.copy(initialVelocity);
        
        this.body.addEventListener('collide', (event) => this.onCollide(event));

        // --- Finalize ---
        this.scene.add(this.mesh);
        this.world.addBody(this.body);
        this.game.updatables.push(this);
    }

    onCollide(event) {
        if (event.body === this.game.player.body) {
            this.game.player.takeDamage(this.damage);
        }
        this.cleanup();
    }

    update(deltaTime) {
        if (this.isDead) return;

        this.lifetime -= deltaTime;
        if (this.lifetime <= 0) {
            this.cleanup();
            return;
        }
        this.mesh.position.copy(this.body.position);
    }
    
    cleanup() {
        if (this.isDead) return;
        this.isDead = true;
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.game.physics.queueForRemoval(this.body);
        const updatableIndex = this.game.updatables.indexOf(this);
        if (updatableIndex > -1) {
            this.game.updatables.splice(updatableIndex, 1);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/EnemyProjectile.js ===


=== FILE: src/game/abilities/Fireball.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { ParticleExplosion } from './ParticleExplosion.js';
import { COLLISION_GROUPS } from '../../common/CollisionGroups.js';

export class Fireball {
    constructor(caster) {
        this.caster = caster;
        this.scene = caster.game.renderer.scene; // Use the main game scene
        this.game = caster.game;
        this.physics = caster.game.physics;
        this.world = this.physics.world;

        this.MAX_TRAVEL_DISTANCE = 70;
        this.SPEED = 35;
        this.LIFETIME = this.MAX_TRAVEL_DISTANCE / this.SPEED;
        this.RADIUS = 0.3;
        this.GROW_DURATION = 0.2;
        this.LINGER_DURATION = 3.0;
        this.SHRINK_DURATION = 0.5;
        this.FINAL_SCALE = 40;
        this.DAMAGE_PER_SECOND = 75;
        
        this.state = 'TRAVELING';
        this.stateTimer = 0;
        this.isDead = false;
        this.body = null;
        this.preStepHandler = this.applyAntiGravity.bind(this);

        // --- PERFORMANCE: Reusable objects for AOE checks ---
        this._aoeExplosionCenter = new THREE.Vector3();
        this._aoePlayerPosition = new THREE.Vector3();
        this._aoeEnemyPosition = new THREE.Vector3();

        const geometry = new THREE.SphereGeometry(this.RADIUS, 32, 32);
        const material = new THREE.MeshStandardMaterial({
            color: 0xff8800, emissive: 0xff4400, emissiveIntensity: 5,
            roughness: 0.6, metalness: 0.2,
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.receiveShadow = false;
        this.mesh.castShadow = false;
        
        const camera = this.caster.camera;
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);

        const startPosition = new THREE.Vector3();
        camera.getWorldPosition(startPosition).add(cameraDirection.clone().multiplyScalar(1.5));
        
        // --- Physics Body ---
        const shape = new CANNON.Sphere(this.RADIUS);
        this.body = new CANNON.Body({
            mass: 0.5,
            shape,
            collisionFilterGroup: COLLISION_GROUPS.PROJECTILE,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY,
            type: CANNON.Body.DYNAMIC,
            linearDamping: 0,
            angularDamping: 0,
        });

        this.body.position.copy(startPosition);
        this.body.velocity.copy(cameraDirection.multiplyScalar(this.SPEED));
        
        this.body.addEventListener('collide', (event) => {
            // Prevent explosion center from being inside a wall.
            // We find the contact normal and nudge the detonation point slightly away from the surface.
            const contactNormal = new CANNON.Vec3();
            
            // The contact normal (ni) points from the second body (bj) to the first (bi).
            // We need a normal that consistently points away from the surface we hit.
            if (event.contact.bi.id === this.body.id) {
                // If we are body 'i', the normal already points away from the other object.
                contactNormal.copy(event.contact.ni);
            } else {
                // If we are body 'j', we need to flip the normal.
                event.contact.ni.negate(contactNormal);
            }

            const hitPoint = new CANNON.Vec3().copy(this.body.position);
            // Nudge the explosion center 10cm away from the wall to ensure it's in open space.
            hitPoint.vadd(contactNormal.scale(0.1), hitPoint);

            this.detonate(hitPoint);
        });

        this.mesh.position.copy(this.body.position);

        this.light = new THREE.PointLight(0xffaa33, 500, 100, 2);
        this.light.castShadow = true;
        this.scene.add(this.mesh);
        this.scene.add(this.light);
        this.world.addBody(this.body);
        this.world.addEventListener('preStep', this.preStepHandler);
        this.game.updatables.push(this);
    }

    applyAntiGravity() {
        if (!this.body || this.isDead || this.state !== 'TRAVELING') return;
        const antiGravity = new CANNON.Vec3(0, -this.world.gravity.y, 0).scale(this.body.mass);
        this.body.applyForce(antiGravity, this.body.position);
    }

    get explosionRadius() {
        if (this.state === 'GROWING' || this.state === 'LINGERING' || this.state === 'SHRINKING') {
            return this.mesh.scale.x * this.RADIUS;
        }
        return 0;
    }

    detonate(hitPoint) {
        if (this.state !== 'TRAVELING') return;
        
        this.state = 'GROWING';
        this.stateTimer = 0;
        
        this.mesh.position.copy(hitPoint);
        
        if (this.body) {
            this.physics.queueForRemoval(this.body);
            this.body = null;
        }
        
        this.game.activeEffects.push(this);
        new ParticleExplosion(this.scene, this.mesh.position, this.game.updatables);
    }

    update(deltaTime) {
        if (this.isDead) return;
        this.stateTimer += deltaTime;

        this.light.position.copy(this.mesh.position);

        switch (this.state) {
            case 'TRAVELING':
                if (this.stateTimer > this.LIFETIME) {
                    this.detonate(this.body.position);
                    break;
                }
                this.mesh.position.copy(this.body.position);
                break;
            case 'GROWING':
                this.handleGrowing();
                this.updateAoeDamage(deltaTime);
                break;
            case 'LINGERING':
                this.handleLingering();
                this.updateAoeDamage(deltaTime);
                break;
            case 'SHRINKING':
                this.handleShrinking();
                break;
        }
    }
    
    handleGrowing() {
        let progress = Math.min(this.stateTimer / this.GROW_DURATION, 1.0);
        const scale = THREE.MathUtils.lerp(1, this.FINAL_SCALE, progress);
        this.mesh.scale.set(scale, scale, scale);
        this.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(5, 10, progress);
        this.light.intensity = THREE.MathUtils.lerp(500, 1000, progress);

        if (progress >= 1.0) {
            this.mesh.scale.set(this.FINAL_SCALE, this.FINAL_SCALE, this.FINAL_SCALE);
            this.state = 'LINGERING';
            this.stateTimer = 0;
        }
    }

    updateAoeDamage(deltaTime) {
        const explosionRadius = this.explosionRadius;
        if (explosionRadius <= 0) return;

        this._aoeExplosionCenter.copy(this.mesh.position);
        const damage = this.DAMAGE_PER_SECOND * deltaTime;

        const player = this.game.player;
        if (player && player.body) {
            this._aoePlayerPosition.copy(player.body.position);
            const playerRadius = player.body.shapes[0].radius;
            if (this._aoePlayerPosition.distanceTo(this._aoeExplosionCenter) < explosionRadius + playerRadius) {
                player.takeDamage(damage);
            }
        }

        for (const enemy of this.game.enemies) {
            if (enemy && enemy.body && !enemy.isDead) {
                this._aoeEnemyPosition.copy(enemy.body.position);
                const enemyRadius = enemy.body.shapes[0].radius;
                if (this._aoeEnemyPosition.distanceTo(this._aoeExplosionCenter) < explosionRadius + enemyRadius) {
                    enemy.takeDamage(damage);
                }
            }
        }
    }
    
    handleLingering() {
        const pulse = Math.sin(this.stateTimer * Math.PI * 2) * 0.5 + 0.5;
        this.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(8, 12, pulse);
        this.light.intensity = THREE.MathUtils.lerp(20000, 25000, pulse);
        
        if (this.stateTimer >= this.LINGER_DURATION) {
            this.state = 'SHRINKING';
            this.stateTimer = 0;
        }
    }
    
    handleShrinking() {
        let progress = Math.min(this.stateTimer / this.SHRINK_DURATION, 1.0);
        const scale = THREE.MathUtils.lerp(this.FINAL_SCALE, 0, progress);
        this.mesh.scale.set(scale, scale, scale);
        
        this.light.intensity = THREE.MathUtils.lerp(1500, 0, progress);
        this.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(12, 0, progress);
        if (progress >= 1.0) this.cleanup();
    }

    cleanup() {
        if (this.isDead) return;
        this.isDead = true;
        
        this.world.removeEventListener('preStep', this.preStepHandler);

        this.scene.remove(this.mesh);
        this.scene.remove(this.light);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        
        if(this.body) this.physics.queueForRemoval(this.body);

        const effectIndex = this.game.activeEffects.indexOf(this);
        if (effectIndex > -1) this.game.activeEffects.splice(effectIndex, 1);
        const updatableIndex = this.game.updatables.indexOf(this);
        if (updatableIndex > -1) this.game.updatables.splice(updatableIndex, 1);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/Fireball.js ===


=== FILE: src/game/abilities/FireballAbility.js ===
--------------------------------------------------
import { Ability } from './Ability.js';
import { Fireball } from './Fireball.js';

export class FireballAbility extends Ability {
    constructor(caster) {
        super(caster, {
            name: 'Fireball',
            icon: 'FB',
            cooldown: 0.5,
            energyCost: 100,
        });
    }

    /**
     * @override
     */
    cast() {
        if (this.canCast()) {
            new Fireball(this.caster); // Creates the projectile
            this.caster.currentEnergy -= this.energyCost;
            this.caster.lastAbilityTime = this.caster.world.time; // For energy regen delay
            this.triggerCooldown();
            
            console.log(`Casted ${this.name}. Energy: ${this.caster.currentEnergy}/${this.caster.maxEnergy}`);
            return true;
        }
        return false;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FireballAbility.js ===


=== FILE: src/game/abilities/FirefliesAbility.js ===
--------------------------------------------------
import { Ability } from './Ability.js';
import { FireflyProjectile } from './FireflyProjectile.js';

export class FirefliesAbility extends Ability {
    constructor(caster) {
        super(caster, {
            name: 'Fireflies',
            icon: 'FF', // Icon for the HUD
            cooldown: 10.0, // 10-second cooldown
            energyCost: 300, // 300 energy points to cast
        });
        this.numProjectiles = 5; // Number of fireflies to shoot
    }

    /**
     * @override
     * Executes the Fireflies ability.
     * Launches multiple homing projectiles towards the enemy currently targeted by the player's crosshair.
     */
    cast() {
        if (this.canCast()) { // Check if ability is off cooldown and player has enough energy
            // Use the pre-determined target from player's crosshair logic
            const targetEnemy = this.caster.lockedTarget; 

            if (!targetEnemy || targetEnemy.isDead) {
                console.log("Fireflies: No valid enemy target found."); // Modified log message
                // If no target, don't consume resources or trigger cooldown
                return false; 
            }

            // Spawn the specified number of firefly projectiles, all targeting the same enemy
            for (let i = 0; i < this.numProjectiles; i++) {
                // Add a slight delay between projectiles for visual effect
                setTimeout(() => {
                    if (!this.caster.isDead) { // Ensure player is still alive before spawning
                        new FireflyProjectile({ caster: this.caster, target: targetEnemy });
                    }
                }, i * 75); // 75ms delay between each projectile
            }

            // Consume energy and trigger the ability's cooldown
            this.caster.currentEnergy -= this.energyCost;
            this.caster.lastAbilityTime = this.caster.world.time; // Update last ability time for energy regen delay
            this.triggerCooldown();
            
            console.log(`Casted ${this.name}. Energy: ${Math.floor(this.caster.currentEnergy)} / ${this.caster.maxEnergy}`);
            return true;
        }
        return false;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FirefliesAbility.js ===


=== FILE: src/game/abilities/FireflyProjectile.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../../common/CollisionGroups.js';
import { ParticleExplosion } from './ParticleExplosion.js';

export class FireflyProjectile {
    constructor({ caster, target }) {
        this.caster = caster;
        this.target = target;
        this.game = caster.game;
        this.scene = caster.game.renderer.scene; // Use the main game scene
        this.world = caster.world;

        // --- Configuration ---
        this.damage = 100;
        this.lifetime = 5.0;
        this.speed = 18;
        this.homingStrength = 2.5;
        this.isDead = false;
        this.state = 'HOMING'; // State machine: 'HOMING', 'EXPLODING'
        this.preStepHandler = this.applyAntiGravity.bind(this);

        // --- Explosion parameters ---
        this.explosionRadius = 2.5;
        this.explosionDamageRadius = 3.5;
        this.explosionDuration = 0.5;
        this.explosionTimer = 0;
        
        // --- PERFORMANCE: Reusable objects for AOE and Homing ---
        this._aoeExplosionCenter = new THREE.Vector3();
        this._aoeEnemyPosition = new THREE.Vector3();
        this._homingTargetBasePos = new CANNON.Vec3();
        this._homingEffectiveTargetPos = new CANNON.Vec3();
        this._homingDirectionToTarget = new CANNON.Vec3();
        this._homingDesiredVelocity = new CANNON.Vec3();
        this._homingSteeringForce = new CANNON.Vec3();

        // --- Trajectory variation parameters ---
        this.wobblePhase = Math.random() * Math.PI * 2;
        this.wobbleAmplitude = 0.5;
        this.wobbleFrequency = 8;
        this.targetPointOffset = new CANNON.Vec3(
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 1,
            (Math.random() - 0.5) * 2
        ).scale(1.5);

        // --- Visuals (Three.js Mesh and Light) ---
        const geometry = new THREE.SphereGeometry(0.15, 8, 8);
        const material = new THREE.MeshStandardMaterial({
            color: 0xffa500,
            emissive: 0xffa500,
            emissiveIntensity: 5,
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = false;
        this.light = new THREE.PointLight(0xffa500, 150, 10, 2);
        this.mesh.add(this.light);

        // --- Physics (Cannon.js Body) ---
        const shape = new CANNON.Sphere(0.15);
        this.body = new CANNON.Body({
            mass: 0.05,
            shape,
            collisionFilterGroup: COLLISION_GROUPS.PROJECTILE,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY,
            type: CANNON.Body.DYNAMIC,
            linearDamping: 0,
            angularDamping: 0,
        });
        this.body.allowSleep = false;
        
        const playerCamera = this.caster.camera;
        const initialDirection = new THREE.Vector3();
        playerCamera.getWorldDirection(initialDirection);
        const coneSpreadAngle = THREE.MathUtils.degToRad(15);
        const randomAxis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
        const randomQuaternion = new THREE.Quaternion().setFromAxisAngle(randomAxis, (Math.random() - 0.5) * 2 * coneSpreadAngle);
        initialDirection.applyQuaternion(randomQuaternion);
        const initialPosition = new THREE.Vector3();
        playerCamera.getWorldPosition(initialPosition).add(initialDirection.clone().multiplyScalar(0.7));
        this.body.position.copy(initialPosition);
        
        const initialVelocity = new CANNON.Vec3().copy(initialDirection).scale(this.speed);
        this.body.velocity.copy(initialVelocity);

        this.body.addEventListener('collide', (event) => this.onCollide(event));

        this.scene.add(this.mesh);
        this.world.addBody(this.body);
        this.world.addEventListener('preStep', this.preStepHandler);
        this.game.updatables.push(this);
    }

    applyAntiGravity() {
        if (!this.body || this.isDead || this.state !== 'HOMING') return;
        const antiGravity = new CANNON.Vec3(0, -this.world.gravity.y, 0).scale(this.body.mass);
        this.body.applyForce(antiGravity, this.body.position);
    }

    onCollide(event) {
        if (this.state !== 'HOMING') return;
        this.detonate();
    }

    update(deltaTime) {
        if (this.isDead) return;

        switch (this.state) {
            case 'HOMING':
                this.lifetime -= deltaTime;
                if (this.lifetime <= 0) {
                    this.detonate();
                    return;
                }
                this.wobblePhase += deltaTime * this.wobbleFrequency;
                if (this.target && this.target.body && !this.target.isDead) {
                    this._homingTargetBasePos.copy(this.target.body.position);
                    this._homingTargetBasePos.vadd(this.targetPointOffset, this._homingEffectiveTargetPos);

                    const currentWobbleX = Math.sin(this.wobblePhase) * this.wobbleAmplitude;
                    const currentWobbleZ = Math.cos(this.wobblePhase) * this.wobbleAmplitude;
                    this._homingEffectiveTargetPos.x += currentWobbleX;
                    this._homingEffectiveTargetPos.z += currentWobbleZ;

                    const distanceToEffectiveTarget = this.body.position.distanceTo(this._homingEffectiveTargetPos);
                    if (distanceToEffectiveTarget <= this.explosionRadius) {
                        this.detonate();
                        return;
                    }
                    
                    this._homingEffectiveTargetPos.vsub(this.body.position, this._homingDirectionToTarget);
                    this._homingDirectionToTarget.normalize();
                    this._homingDirectionToTarget.scale(this.speed, this._homingDesiredVelocity);

                    this._homingDesiredVelocity.vsub(this.body.velocity, this._homingSteeringForce);
                    this._homingSteeringForce.scale(this.homingStrength * deltaTime, this._homingSteeringForce);
                    this.body.velocity.vadd(this._homingSteeringForce, this.body.velocity);

                    if (this.body.velocity.length() > this.speed) {
                        this.body.velocity.normalize();
                        this.body.velocity.scale(this.speed, this.body.velocity);
                    }
                }
                this.mesh.position.copy(this.body.position);
                this.mesh.quaternion.copy(this.body.quaternion);
                break;

            case 'EXPLODING':
                this.explosionTimer += deltaTime;
                this.light.intensity = THREE.MathUtils.lerp(150, 0, this.explosionTimer / this.explosionDuration);
                if (this.explosionTimer >= this.explosionDuration) {
                    this.cleanup();
                }
                break;
        }
    }

    detonate() {
        if (this.state !== 'HOMING') return;
        
        this.state = 'EXPLODING';
        this.explosionTimer = 0;

        this.game.physics.queueForRemoval(this.body);
        new ParticleExplosion(this.scene, this.mesh.position, this.game.updatables);
        this.applyAoEDamage(this.mesh.position, this.explosionDamageRadius, this.damage);
        this.mesh.visible = false;
    }

    applyAoEDamage(explosionCenter, radius, damageAmount) {
        this._aoeExplosionCenter.copy(explosionCenter);
        for (const enemy of [...this.game.enemies]) { 
            if (enemy && enemy.body && !enemy.isDead) {
                this._aoeEnemyPosition.copy(enemy.body.position);
                const enemyRadius = enemy.body.shapes[0].radius;
                if (this._aoeEnemyPosition.distanceTo(this._aoeExplosionCenter) < radius + enemyRadius) {
                    enemy.takeDamage(damageAmount);
                }
            }
        }
    }

    cleanup() {
        if (this.isDead) return;
        this.isDead = true;

        this.world.removeEventListener('preStep', this.preStepHandler);

        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();

        const updatableIndex = this.game.updatables.indexOf(this);
        if (updatableIndex > -1) {
            this.game.updatables.splice(updatableIndex, 1);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FireflyProjectile.js ===


=== FILE: src/game/abilities/ParticleExplosion.js ===
--------------------------------------------------
import * as THREE from 'three';

export class ParticleExplosion {
    constructor(scene, position, updatables) {
        this.scene = scene;
        this.updatables = updatables; // The central array of objects to update

        this.LIFESPAN = 1.2; // How long the particles last
        this.elapsedTime = 0;
        
        const particleCount = 200;
        const positions = new Float32Array(particleCount * 3);
        this.velocities = [];

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            // All particles start at the center of the explosion
            positions[i3] = 0;
            positions[i3 + 1] = 0;
            positions[i3 + 2] = 0;

            // Create a random direction vector
            const vec = new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
            );
            vec.normalize();
            // Give it a random speed
            vec.multiplyScalar(Math.random() * 15 + 5); 
            this.velocities.push(vec);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
            color: 0xff8800,
            size: 0.2,
            transparent: true,
            blending: THREE.AdditiveBlending, // Makes colors add up for a fiery look
            depthWrite: false, // Prevents particles from occluding each other weirdly
        });

        this.points = new THREE.Points(geometry, material);
        this.points.position.copy(position);
        this.scene.add(this.points);

        // Add this particle system to the central update loop
        this.updatables.push(this);
    }

    update(deltaTime) {
        this.elapsedTime += deltaTime;
        const progress = this.elapsedTime / this.LIFESPAN;

        if (progress >= 1) {
            this.cleanup();
            return;
        }

        // Animate particles outward
        const positions = this.points.geometry.attributes.position.array;
        for (let i = 0; i < this.velocities.length; i++) {
            const i3 = i * 3;
            positions[i3] += this.velocities[i].x * deltaTime;
            positions[i3 + 1] += this.velocities[i].y * deltaTime;
            positions[i3 + 2] += this.velocities[i].z * deltaTime;
        }
        this.points.geometry.attributes.position.needsUpdate = true;
        
        // Fade out the particles over their lifespan
        this.points.material.opacity = 1.0 - progress;
    }

    cleanup() {
        // Remove from scene and free memory
        this.scene.remove(this.points);
        this.points.geometry.dispose();
        this.points.material.dispose();

        // Remove self from the central update loop
        const index = this.updatables.indexOf(this);
        if (index > -1) {
            this.updatables.splice(index, 1);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/ParticleExplosion.js ===


=== FILE: src/game/entities/Enemy.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { HealthBar } from '../ui/HealthBar.js';
import { COLLISION_GROUPS } from '../../common/CollisionGroups.js';
import { EnemyProjectile } from '../abilities/EnemyProjectile.js';
import { DamageNumber } from '../ui/DamageNumber.js';

export class Enemy {
    constructor({ game, name = 'Dummy' }) {
        this.game = game;
        this.scene = game.renderer.scene;
        this.world = game.physics.world;
        this.name = name;
        
        // --- Core Parameters ---
        this.maxHealth = 500;
        this.currentHealth = this.maxHealth;
        this.speed = 8;
        this.isDead = false;

        // --- Hit Feedback ---
        this.flashDuration = 0.15;
        this.flashTimer = 0;
        this.originalEmissive = null; // Will be set after mesh creation

        // --- AI State & Parameters ---
        this.state = 'IDLE'; // IDLE, SEARCHING, COMBAT
        this.lastKnownPlayerPosition = new THREE.Vector3();
        this.perception = {
            detectionRange: 40,
            loseSightRange: 50,
            attackRange: 30,
            optimalRange: 22,
            minimumRange: 10,
            hasLineOfSight: false,
            distanceToPlayer: Infinity,
        };
        
        // --- PERFORMANCE: AI Throttling ---
        // Stagger AI updates to prevent all enemies from running heavy logic on the same frame.
        this.AI_UPDATE_INTERVAL = 0.1; // Update AI logic 10 times per second
        this.aiUpdateTimer = Math.random() * this.AI_UPDATE_INTERVAL; // Random initial offset

        // --- PERFORMANCE: Reusable Objects to prevent GC churn ---
        this._perceptionRayFrom = new CANNON.Vec3();
        this._perceptionRayTo = new CANNON.Vec3();
        this._lookAtTarget = new THREE.Vector3();
        this._tempQuaternion = new CANNON.Quaternion();
        this._tempObject3D = new THREE.Object3D();

        // --- Combat & Movement Abilities ---
        this.strafeDirection = 1;
        this.strafeDirectionTimer = 0;
        this.turnSpeed = 0.1;
        this.jumpHeight = 8;
        this.jumpCooldown = 2.0;
        this.jumpTimer = this.jumpCooldown;

        this.dashSpeed = 32;
        this.dashDuration = 0.2;
        this.dashCooldown = 2.0;
        this.dashTimer = this.dashCooldown;
        this.isDashing = false;
        this.dashStateTimer = 0;
        this.dashDirection = new THREE.Vector3();
        
        this.attackCooldown = 1.5;
        this.attackTimer = this.attackCooldown;

        this.createMesh();
        this.createPhysicsBody();
        
        if (this.game.player) {
            this.healthBar = new HealthBar(this);
        } else {
            this.healthBar = null;
        }
        
        this.game.updatables.push(this);
    }
    
    createMesh() {
        const geometry = new THREE.CapsuleGeometry(0.7, 1.0, 4, 8);
        const material = new THREE.MeshStandardMaterial({ color: 0x990000, roughness: 0.4 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;
        this.scene.add(this.mesh);

        // Store original material state for hit flash
        this.originalEmissive = new THREE.Color(this.mesh.material.emissive.getHex());
    }

    createPhysicsBody() {
        const shape = new CANNON.Sphere(0.8);
        this.body = new CANNON.Body({
            mass: 80,
            shape,
            fixedRotation: true,
            collisionFilterGroup: COLLISION_GROUPS.ENEMY,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.PLAYER | COLLISION_GROUPS.ENEMY,
        });
        this.world.addBody(this.body);
    }

    spawn(position) {
        this.body.position.set(position.x, position.y, position.z);
        this.body.velocity.set(0, 0, 0);
        this.currentHealth = this.maxHealth;
        this.isDead = false;
        if (this.healthBar) {
            this.healthBar.updateHealth(this.currentHealth, this.maxHealth);
            this.healthBar.setVisible(true);
        }
        this.body.type = CANNON.Body.DYNAMIC;
        this.lastKnownPlayerPosition.copy(position);
    }

    takeDamage(amount) {
        if (this.isDead) return;
        this.currentHealth -= amount;

        // --- Hit Feedback ---
        // 1. Flash effect
        this.mesh.material.emissive.setHex(0xffffff);
        this.flashTimer = this.flashDuration;
        // 2. Floating damage number
        new DamageNumber({
            game: this.game,
            position: new THREE.Vector3().copy(this.body.position).add(new THREE.Vector3(0, 1.5, 0)),
            text: `${Math.floor(amount)}`
        });
        // --- End Hit Feedback ---

        if (this.healthBar) {
            this.healthBar.updateHealth(this.currentHealth, this.maxHealth);
        }
        if (this.currentHealth <= 0) {
            this.currentHealth = 0;
            this.die();
        }
    }

    die(isEditorClear = false) {
        if (this.isDead) return;
        this.isDead = true;

        if (this.healthBar) {
            this.healthBar.setVisible(false);
            this.healthBar.dispose();
        }
        
        if (this.body) this.game.physics.queueForRemoval(this.body);
        
        if (this.mesh) {
            this.scene.remove(this.mesh);
            this.mesh.geometry.dispose();
            this.mesh.material.dispose();
        }

        const enemyIndex = this.game.enemies.indexOf(this);
        if (enemyIndex > -1 && !isEditorClear) {
             this.game.enemies.splice(enemyIndex, 1);
        }
        
        const updatableIndex = this.game.updatables.indexOf(this);
        if (updatableIndex > -1) {
            this.game.updatables.splice(updatableIndex, 1);
        }
    }

    update(deltaTime) {
        if (this.isDead) return;

        // Handle hit flash
        if (this.flashTimer > 0) {
            this.flashTimer -= deltaTime;
            const flashProgress = 1 - Math.max(0, this.flashTimer / this.flashDuration);
            this.mesh.material.emissive.lerpColors(new THREE.Color(0xffffff), this.originalEmissive, flashProgress);
            if (this.flashTimer <= 0) {
                this.mesh.material.emissive.copy(this.originalEmissive);
            }
        }

        if (this.game.player) {
            this.updateTimers(deltaTime);
            
            // --- PERFORMANCE: AI Throttling ---
            this.aiUpdateTimer += deltaTime;
            if (this.aiUpdateTimer >= this.AI_UPDATE_INTERVAL) {
                this.runAI(deltaTime);
                this.aiUpdateTimer = 0;
            }
        }

        // Only update movement/physics every frame if not dashing
        if (!this.isDashing && this.state !== 'IDLE') {
             this.applyMovementBasedOnState();
        }
        
        if (this.body && this.mesh) {
            this.mesh.position.copy(this.body.position);
            this.mesh.quaternion.copy(this.body.quaternion);
        }
    }

    updateTimers(deltaTime) {
        this.jumpTimer += deltaTime;
        this.dashTimer += deltaTime;
        this.attackTimer += deltaTime;
        this.strafeDirectionTimer -= deltaTime;
        if(this.isDashing) this.dashStateTimer += deltaTime;
    }

    // This runs less frequently due to throttling
    runAI(deltaTime) {
        this.updatePerception();
        this.updateState();
        this.executeStateActions(deltaTime);
    }

    updatePerception() {
        const player = this.game.player;
        if (!player || !player.body) return;
        this.perception.distanceToPlayer = this.body.position.distanceTo(player.body.position);
        
        this._perceptionRayFrom.copy(this.body.position);
        this._perceptionRayTo.copy(player.body.position);
        this.perception.hasLineOfSight = !this.world.raycastClosest(
            this._perceptionRayFrom, this._perceptionRayTo, { collisionFilterMask: COLLISION_GROUPS.WORLD, skipBackfaces: true }
        );
        if (this.perception.hasLineOfSight) {
            this.lastKnownPlayerPosition.copy(player.body.position);
        }
    }

    updateState() {
        if (this.perception.hasLineOfSight && this.perception.distanceToPlayer < this.perception.detectionRange) {
            this.state = 'COMBAT';
        } else if (this.state === 'COMBAT' && this.perception.distanceToPlayer > this.perception.loseSightRange) {
            this.state = 'SEARCHING';
        } else if (this.state === 'SEARCHING' && this.body.position.distanceTo(this.lastKnownPlayerPosition) < 2) {
            this.state = 'IDLE';
        }
    }

    // This handles actions based on the current state. It's called by the throttled runAI.
    executeStateActions(deltaTime) {
        if (this.isDashing) {
            if (this.dashStateTimer >= this.dashDuration) this.isDashing = false;
            return;
        }

        this.faceTarget(this.lastKnownPlayerPosition);

        if (this.state === 'COMBAT') {
            this.handleCombatDecisions();
        }
    }
    
    // This is called every frame to apply velocity based on the AI's decided state.
    applyMovementBasedOnState() {
        this.body.wakeUp();

        switch (this.state) {
            case 'IDLE':
                this.body.velocity.x *= 0.9; this.body.velocity.z *= 0.9;
                break;
            case 'SEARCHING':
                const searchDir = new CANNON.Vec3().copy(this.lastKnownPlayerPosition).vsub(this.body.position);
                searchDir.y = 0;
                searchDir.normalize();
                this.body.velocity.x = searchDir.x * this.speed;
                this.body.velocity.z = searchDir.z * this.speed;
                break;
            case 'COMBAT':
                this.repositionDuringCombat();
                break;
        }
    }
    
    handleCombatDecisions() {
        const { distanceToPlayer, hasLineOfSight, attackRange } = this.perception;
        const canShoot = hasLineOfSight && this.attackTimer >= this.attackCooldown;
        const toPlayerDir = new CANNON.Vec3().copy(this.lastKnownPlayerPosition).vsub(this.body.position);
        toPlayerDir.y = 0;

        if (canShoot && distanceToPlayer <= attackRange) {
            this.shoot();
        }

        this.navigateObstacles();
        if (this.dashTimer >= this.dashCooldown && Math.random() < 0.2) { // Increased chance due to less frequent checks
            const right = new THREE.Vector3().crossVectors(toPlayerDir, new THREE.Vector3(0,1,0)).normalize();
            right.multiplyScalar(Math.random() > 0.5 ? 1 : -1);
            this.dash(right);
        }
    }

    repositionDuringCombat() {
        const { distanceToPlayer, optimalRange, minimumRange } = this.perception;
        const toPlayerDir = new CANNON.Vec3().copy(this.lastKnownPlayerPosition).vsub(this.body.position);
        toPlayerDir.y = 0;
        if (toPlayerDir.lengthSquared() > 0) toPlayerDir.normalize();

        if (this.attackTimer < this.attackCooldown / 2) { // Pause briefly after shooting
             this.body.velocity.x *= 0.8;
             this.body.velocity.z *= 0.8;
             return;
        }

        if (distanceToPlayer > optimalRange) {
            this.body.velocity.x = toPlayerDir.x * this.speed;
            this.body.velocity.z = toPlayerDir.z * this.speed;
        } else if (distanceToPlayer < minimumRange) {
            this.body.velocity.x = -toPlayerDir.x * this.speed * 0.8;
            this.body.velocity.z = -toPlayerDir.z * this.speed * 0.8;
        } else {
            if (this.strafeDirectionTimer <= 0) {
                this.strafeDirection = Math.random() > 0.5 ? 1 : -1;
                this.strafeDirectionTimer = Math.random() * 2 + 1.5;
            }
            const rightDir = new CANNON.Vec3(toPlayerDir.z, 0, -toPlayerDir.x);
            this.body.velocity.x = rightDir.x * this.speed * 0.7 * this.strafeDirection;
            this.body.velocity.z = rightDir.z * this.speed * 0.7 * this.strafeDirection;
        }
    }

    faceTarget(targetPosition) {
        this._lookAtTarget.copy(targetPosition);
        this._lookAtTarget.y = this.body.position.y;
        this._tempObject3D.position.copy(this.body.position);
        this._tempObject3D.lookAt(this._lookAtTarget);
        this._tempQuaternion.copy(this._tempObject3D.quaternion);
        this.body.quaternion.slerp(this._tempQuaternion, this.turnSpeed, this.body.quaternion);
    }
    
    navigateObstacles() {
        if (this.body.velocity.lengthSquared() < 0.1) return;

        const moveDirection = new CANNON.Vec3().copy(this.body.velocity);
        moveDirection.normalize();

        const rayFrom = new CANNON.Vec3().copy(this.body.position);
        const rayTo = rayFrom.clone().vadd(moveDirection.scale(2));
        
        if (this.world.raycastClosest(rayFrom, rayTo, { collisionFilterMask: COLLISION_GROUPS.WORLD }, new CANNON.RaycastResult())) {
            if (this.jumpTimer >= this.jumpCooldown) this.jump();
        }
    }
    
    jump() {
        const rayFrom = new CANNON.Vec3().copy(this.body.position);
        const rayTo = rayFrom.clone().vadd(new CANNON.Vec3(0, -1.1, 0));
        if (this.world.raycastClosest(rayFrom, rayTo, {collisionFilterMask: COLLISION_GROUPS.WORLD}, new CANNON.RaycastResult())) {
             this.body.velocity.y = this.jumpHeight;
             this.jumpTimer = 0;
        }
    }

    dash(direction) {
        this.isDashing = true;
        this.dashTimer = 0;
        this.dashStateTimer = 0;
        this.dashDirection.copy(direction).normalize();
        this.dashDirection.y = 0;
        this.dashDirection.normalize();
        this.body.velocity.x = this.dashDirection.x * this.dashSpeed;
        this.body.velocity.y = 0;
        this.body.velocity.z = this.dashDirection.z * this.dashSpeed;
    }

    calculateBallisticLaunchVelocity(startPos, targetPos, projectileSpeed, gravity) {
        const delta = new THREE.Vector3().subVectors(targetPos, startPos);
        const deltaXZ = new THREE.Vector2(delta.x, delta.z);
        const distXZ = deltaXZ.length();
        const v = projectileSpeed, g = gravity, y = delta.y, x = distXZ;
        const discriminant = v**4 - g * (g * x**2 + 2 * y * v**2);
        if (discriminant < 0) return null;
        const angle = Math.atan2(v**2 - Math.sqrt(discriminant), g * x);
        const Vy = v * Math.sin(angle);
        const Vxz = v * Math.cos(angle);
        const dirXZ = deltaXZ.normalize();
        return new THREE.Vector3(dirXZ.x * Vxz, Vy, dirXZ.y * Vxz);
    }

    shoot() {
        this.attackTimer = 0;
        const projectileSpeed = 40;
        const timeToTarget = this.perception.distanceToPlayer / projectileSpeed;
        const playerVelocity = new CANNON.Vec3().copy(this.game.player.body.velocity);
        const predictionTime = Math.min(timeToTarget, 1.0);
        const predictedPosition = new THREE.Vector3().copy(this.lastKnownPlayerPosition).add(
            new THREE.Vector3().copy(playerVelocity).multiplyScalar(predictionTime)
        );
        predictedPosition.y += 0.5;

        const casterPosition = new THREE.Vector3().copy(this.body.position);
        const gravityMagnitude = Math.abs(this.world.gravity.y);
        let launchVelocity = this.calculateBallisticLaunchVelocity(
            casterPosition, predictedPosition, projectileSpeed, gravityMagnitude
        );
        
        if (!launchVelocity) {
            launchVelocity = new THREE.Vector3().subVectors(predictedPosition, casterPosition).normalize().multiplyScalar(projectileSpeed);
        }

        new EnemyProjectile({ caster: this, initialVelocity: launchVelocity });
    }
}
--------------------------------------------------
=== END OF FILE: src/game/entities/Enemy.js ===


=== FILE: src/game/entities/Player.js ===
--------------------------------------------------
// src/game/entities/Player.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { FireballAbility } from '../abilities/FireballAbility.js';
import { FirefliesAbility } from '../abilities/FirefliesAbility.js';
import { COLLISION_GROUPS } from '../../common/CollisionGroups.js';
import { Katana } from '../weapons/Katana.js';

export class Player {
    constructor(camera, world, inputManager, scene, game) {
        this.camera = camera;
        this.world = world;
        this.input = inputManager;
        this.scene = scene; // This is the viewModelScene
        this.game = game;

        // --- Core Parameters ---
        this.speed = 8;
        this.jumpHeight = 8;
        this.maxJumps = 2;
        this.spawnPoint = { x: 0, y: 10, z: 0 }; 

        // --- Health & Energy ---
        this.maxHealth = 1000;
        this.currentHealth = this.maxHealth;
        this.maxEnergy = 1000;
        this.currentEnergy = this.maxEnergy;
        this.energyRegenRate = 25;
        this.energyRegenDelay = 5;

        // --- Internal State ---
        this.isDead = false;
        this.jumpsRemaining = 0;
        this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
        this.PI_2 = Math.PI / 2;
        this.isDashing = false;
        this.isSlamming = false;
        this.lastAbilityTime = -this.energyRegenDelay;
        
        // --- Targeting System ---
        this.lockedTarget = null;
        this.maxTargetingRange = 100;
        this.maxAngularDeviation = Math.tan(THREE.MathUtils.degToRad(15)); 

        // --- VFX ---
        this.originalFov = camera.fov;
        this.targetFov = this.originalFov;
        this.vfx = {
            damage: document.getElementById('screen-overlay'),
            dashForward: document.getElementById('vfx-dash-forward'),
            dashSideways: document.getElementById('vfx-dash-sideways'),
            jump: document.getElementById('vfx-jump-wind'),
            slam: document.getElementById('vfx-ground-slam'),
        };

        // --- PERFORMANCE: Reusable Objects ---
        this._targetRayOrigin = new THREE.Vector3();
        this._targetRayDirection = new THREE.Vector3();
        this._enemyPos = new THREE.Vector3();
        this._oToP = new THREE.Vector3();
        this._losRayFrom = new CANNON.Vec3();
        this._losRayTo = new CANNON.Vec3();
        this._forward = new THREE.Vector3();
        this._right = new THREE.Vector3();

        // --- Weapon & Ability Systems ---
        this.weapon = new Katana(this);
        this.abilities = [null, null, null, null];
        this.selectedAbilityIndex = 0;
        this.abilities[0] = new FireballAbility(this);
        this.abilities[1] = new FirefliesAbility(this);

        // --- Movement Mechanics ---
        this.DOUBLE_JUMP_COOLDOWN = 1.5;
        this.doubleJumpOnCooldown = false;
        this.doubleJumpCooldownTimer = this.DOUBLE_JUMP_COOLDOWN;
        this.DASH_SPEED_MULTIPLIER = 4;
        this.DASH_DURATION = 0.2;
        this.DASH_COOLDOWN = 2.0;
        this.DOUBLE_TAP_WINDOW = 300;
        this.dashOnCooldown = false;
        this.dashCooldownTimer = this.DASH_COOLDOWN;
        this.dashTimer = 0;
        this.dashDirection = new THREE.Vector3();
        this.keyLastPress = {};
        this.keyPreviousState = {};

        // --- View Model ---
        this.camera.add(this.weapon.mesh);
        this.scene.add(this.camera);

        // ADDED: Lighting for the view model scene
        this.viewModelAmbientLight = new THREE.AmbientLight(0xffffff, 1.0); // Soft white light
        this.scene.add(this.viewModelAmbientLight);

        this.viewModelDirectionalLight = new THREE.DirectionalLight(0xffffff, 2.0); // Key light
        this.viewModelDirectionalLight.position.set(0.5, 0.8, -0.2).normalize(); // Points slightly from top-right-front
        this.scene.add(this.viewModelDirectionalLight);

        this.createPhysicsBody();
        this.setupEventListeners();
        this.setupVFXListeners();
    }
    
    createPhysicsBody() {
        const playerShape = new CANNON.Sphere(0.8);
        // Define a player material with zero friction from the start.
        const playerMaterial = new CANNON.Material({ name: "playerMaterial", friction: 0.0 });
        
        this.body = new CANNON.Body({
            mass: 70,
            shape: playerShape,
            material: playerMaterial,
            fixedRotation: true,
            collisionFilterGroup: COLLISION_GROUPS.PLAYER,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY | COLLISION_GROUPS.PROJECTILE,
        });

        const worldMaterial = this.world.defaultMaterial;
        
        // Create a contact material with high stiffness and no friction or bounce.
        // This makes the interaction between the player and the world rigid and slippery.
        const playerWorldContactMaterial = new CANNON.ContactMaterial(
            worldMaterial,
            playerMaterial,
            {
                friction: 0.0,
                restitution: 0.0,
                contactEquationStiffness: 1e8,
                contactEquationRelaxation: 3,
                frictionEquationStiffness: 1e8,
            }
        );

        this.world.addContactMaterial(playerWorldContactMaterial);
        this.world.addBody(this.body);
    }

    setupVFXListeners() {
        Object.values(this.vfx).forEach(element => {
            if (element) {
                element.addEventListener('animationend', () => {
                    element.classList.remove('active', 'right-to-left', 'left-to-right');
                });
            }
        });
    }

    triggerVFX(element, ...classes) {
        if (!element) return;
        // This pattern reliably restarts a CSS animation
        element.classList.remove('active', 'right-to-left', 'left-to-right');
        void element.offsetWidth; // Force reflow
        element.classList.add('active', ...classes);
    }
    
    setupEventListeners() {
        this.world.addEventListener('postStep', () => {
            if (!this.isDead) {
                this.camera.position.copy(this.body.position);
            }
        });

        this.body.addEventListener('collide', (event) => {
            const contactNormal = new CANNON.Vec3();
            if (event.contact.bi.id === this.body.id) {
                event.contact.ni.negate(contactNormal);
            } else {
                contactNormal.copy(event.contact.ni);
            }

            const isGroundContact = contactNormal.dot(CANNON.Vec3.UNIT_Y) > 0.5;

            if (isGroundContact) {
                if (this.isSlamming) {
                    this.triggerVFX(this.vfx.slam);
                    this.isSlamming = false;
                }
                this.jumpsRemaining = this.maxJumps;
                if (!this.doubleJumpOnCooldown) {
                    this.doubleJumpCooldownTimer = this.DOUBLE_JUMP_COOLDOWN;
                }
            }
        });
        
        this.game.renderer.renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
        document.addEventListener('mousedown', (event) => {
            if (document.pointerLockElement) {
                if (event.button === 0) { this.weapon.attack(); } 
                else if (event.button === 2) { this.handleAbilities(true); }
            }
        });
    }
    
    spawn(position) {
        this.isDead = false;
        this.spawnPoint = { ...position };
        this.body.position.set(position.x, position.y, position.z);
        this.body.velocity.set(0, 0, 0);
        this.body.wakeUp();
        this.currentHealth = this.maxHealth;
        this.currentEnergy = this.maxEnergy;
        this.jumpsRemaining = 0;
        this.lastAbilityTime = this.world.time - this.energyRegenDelay;
    }

    takeDamage(amount) {
        if (this.isDead) return;
        this.currentHealth -= amount;
        this.triggerVFX(this.vfx.damage);
        if (this.currentHealth <= 0) {
            this.currentHealth = 0;
            this.die();
        }
    }

    die(isEditorClear = false) {
        if (this.isDead || isEditorClear) return;
        this.isDead = true;
        this.game.handlePlayerDeath();
    }

    updateLook() {
        this.euler.y -= this.input.mouse.movementX * 0.002;
        this.euler.x -= this.input.mouse.movementY * 0.002;
        this.euler.x = Math.max(-this.PI_2, Math.min(this.PI_2, this.euler.x));
        this.camera.quaternion.setFromEuler(this.euler);
        this.input.update();
    }
    
    handleMovementCooldowns(deltaTime) {
        if (this.doubleJumpOnCooldown) {
            this.doubleJumpCooldownTimer += deltaTime;
            if (this.doubleJumpCooldownTimer >= this.DOUBLE_JUMP_COOLDOWN) {
                this.doubleJumpOnCooldown = false;
            }
        }
        if (this.dashOnCooldown) {
            this.dashCooldownTimer += deltaTime;
            if (this.dashCooldownTimer >= this.DASH_COOLDOWN) {
                this.dashOnCooldown = false;
            }
        }
    }

    handleAbilities(shouldCast) {
        if (shouldCast) {
            const selectedAbility = this.abilities[this.selectedAbilityIndex];
            if (selectedAbility) { selectedAbility.cast(); }
        }
    }

    handleEnergyRegen(deltaTime) {
        if (this.world.time - this.lastAbilityTime > this.energyRegenDelay) {
            if (this.currentEnergy < this.maxEnergy) {
                this.currentEnergy = Math.min(this.maxEnergy, this.currentEnergy + this.energyRegenRate * deltaTime);
            }
        }
    }

    handleDash() {
        // Get camera basis vectors
        this.camera.getWorldDirection(this._forward);
        this._forward.y = 0;
        this._forward.normalize();
        this._right.crossVectors(this._forward, new THREE.Vector3(0, 1, 0)).normalize();

        // Project dash direction onto basis vectors
        const dotForward = this.dashDirection.dot(this._forward);
        const dotRight = this.dashDirection.dot(this._right);
        
        // Determine primary dash direction
        if (Math.abs(dotForward) > Math.abs(dotRight)) { // Forward or backward
            this.triggerVFX(this.vfx.dashForward);
            if (dotForward > 0) { // Forward
                this.targetFov = this.originalFov + 15;
            } else { // Backward
                this.targetFov = this.originalFov - 10;
            }
        } else { // Sideways
            if (dotRight > 0) { // Right
                this.triggerVFX(this.vfx.dashSideways, 'right-to-left');
            } else { // Left
                this.triggerVFX(this.vfx.dashSideways, 'left-to-right');
            }
        }
    }
    
    handleMovement(deltaTime) {
        const xInput = (this.input.keys['KeyD'] ? 1 : 0) - (this.input.keys['KeyA'] ? 1 : 0);
        const zInput = (this.input.keys['KeyW'] ? 1 : 0) - (this.input.keys['KeyS'] ? 1 : 0);

        this.camera.getWorldDirection(this._forward);
        this._forward.y = 0;
        this._forward.normalize();
        this._right.crossVectors(this._forward, new THREE.Vector3(0, 1, 0)).normalize();

        const moveDirection = new THREE.Vector3();
        if (zInput) { moveDirection.add(this._forward.clone().multiplyScalar(zInput)); }
        if (xInput) { moveDirection.add(this._right.clone().multiplyScalar(xInput)); }
        
        if (moveDirection.lengthSq() > 0) { moveDirection.normalize(); }

        const now = performance.now();
        ['KeyW', 'KeyA', 'KeyS', 'KeyD'].forEach(key => {
            const isPressed = this.input.keys[key];
            if (isPressed && !this.keyPreviousState[key]) {
                if (now - (this.keyLastPress[key] || 0) < this.DOUBLE_TAP_WINDOW) {
                    if (!this.dashOnCooldown && !this.isDashing) {
                        this.isDashing = true;
                        this.dashOnCooldown = true;
                        this.dashTimer = 0;
                        this.dashCooldownTimer = 0;
                        this.dashDirection.copy(moveDirection).normalize();
                        this.handleDash();
                    }
                }
                this.keyLastPress[key] = now;
            }
            this.keyPreviousState[key] = isPressed;
        });

        if (this.isDashing) {
            this.dashTimer += deltaTime;
            const dashSpeed = this.speed * this.DASH_SPEED_MULTIPLIER;
            this.body.velocity.x = this.dashDirection.x * dashSpeed;
            this.body.velocity.z = this.dashDirection.z * dashSpeed;
            if (this.dashTimer >= this.DASH_DURATION) {
                this.isDashing = false;
            }
        } else {
            this.body.velocity.x = moveDirection.x * this.speed;
            this.body.velocity.z = moveDirection.z * this.speed;
        }

        if (this.input.keys['Space']) {
            if (this.jumpsRemaining > 0) {
                const performJump = () => {
                    this.body.velocity.y = this.jumpHeight;
                    this.jumpsRemaining--;
                    this.triggerVFX(this.vfx.jump);
                };
                if (this.jumpsRemaining === 1 && this.maxJumps === 2) {
                    if (!this.doubleJumpOnCooldown) {
                        this.doubleJumpOnCooldown = true;
                        this.doubleJumpCooldownTimer = 0;
                        performJump();
                    }
                } else {
                    performJump();
                }
            }
            this.input.keys['Space'] = false;
        }

        if (this.input.keys['ShiftLeft']) {
            if (this.jumpsRemaining < this.maxJumps && !this.isSlamming) {
                this.isSlamming = true;
                this.body.velocity.y = -25;
            }
        }
    }

    updateTargetingLogic() {
        this.camera.getWorldPosition(this._targetRayOrigin);
        this.camera.getWorldDirection(this._targetRayDirection);

        let bestEnemy = null;
        let minScore = Infinity;

        for (const enemy of this.game.enemies) { 
            if (enemy.isDead || !enemy.body || !enemy.mesh) continue;
            this._enemyPos.copy(enemy.body.position);
            const enemyHeight = enemy.mesh.geometry?.parameters?.height || 2;
            this._enemyPos.y += enemyHeight / 2;
            const distanceToEnemy = this._targetRayOrigin.distanceTo(this._enemyPos);
            if (distanceToEnemy > this.maxTargetingRange) continue;
            this._oToP.subVectors(this._enemyPos, this._targetRayOrigin).normalize();
            const dotProduct = this._oToP.dot(this._targetRayDirection);
            const angle = Math.acos(Math.min(1, Math.max(-1, dotProduct)));
            const angularDeviation = Math.tan(angle);
            if (angularDeviation < this.maxAngularDeviation) {
                this._losRayFrom.copy(this._targetRayOrigin);
                this._losRayTo.copy(this._enemyPos);
                const hasLineOfSight = !this.world.raycastClosest(
                    this._losRayFrom, this._losRayTo, { collisionFilterMask: COLLISION_GROUPS.WORLD, skipBackfaces: true }
                );
                if (hasLineOfSight) {
                    const score = (angularDeviation * angularDeviation * 100) + distanceToEnemy; 
                    if (score < minScore) {
                        minScore = score;
                        bestEnemy = enemy;
                    }
                }
            }
        }
        this.lockedTarget = bestEnemy;
    }
    
    updateVFX(deltaTime) {
        // FOV Lerping
        if (Math.abs(this.camera.fov - this.targetFov) > 0.01) {
            this.camera.fov = THREE.MathUtils.lerp(this.camera.fov, this.targetFov, deltaTime * 10);
            this.camera.updateProjectionMatrix();
        }
        
        // Return to normal FOV after a dash
        if (!this.isDashing && this.targetFov !== this.originalFov) {
            this.targetFov = this.originalFov;
        }
    }

    update(deltaTime) {
        if (this.isDead) return;

        if (document.pointerLockElement) { this.updateLook(); }

        this.handleMovementCooldowns(deltaTime);
        this.handleEnergyRegen(deltaTime);
        this.handleMovement(deltaTime);
        this.updateTargetingLogic();
        this.weapon.update(deltaTime);
        this.updateVFX(deltaTime);

        for (let i = 0; i < this.abilities.length; i++) {
            const ability = this.abilities[i];
            if (ability) { ability.update(deltaTime); }
            // ADDED: Update ability slot appearance based on selection
            if (this.game.hud) { // Ensure HUD is initialized
                const slotUI = this.game.hud.abilitySlots[i];
                if (slotUI) {
                    if (i === this.selectedAbilityIndex) {
                        slotUI.element.classList.add('selected');
                    } else {
                        slotUI.element.classList.remove('selected');
                    }
                }
            }
        }

        for (let i = 1; i <= 4; i++) {
            if (this.input.keys[`Digit${i}`]) {
                this.selectedAbilityIndex = i - 1;
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/entities/Player.js ===


=== FILE: src/game/ui/DamageNumber.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Creates a floating text sprite that displays damage dealt, moves upwards, and fades out.
 */
export class DamageNumber {
    constructor({ game, position, text }) {
        this.game = game;
        this.scene = game.renderer.scene;
        this.camera = game.renderer.camera;

        this.lifetime = 1.0;
        this.elapsedTime = 0;
        this.upwardSpeed = 2.0;

        const canvas = this.createCanvas(text);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;

        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
        this.sprite = new THREE.Sprite(material);
        this.sprite.renderOrder = 1000; // Render on top of most things
        this.sprite.scale.set(canvas.width / 100, canvas.height / 100, 1.0);
        this.sprite.position.copy(position);
        
        // Add some random horizontal offset to prevent perfect stacking
        this.sprite.position.x += (Math.random() - 0.5) * 0.5;

        this.scene.add(this.sprite);
        this.game.updatables.push(this);
    }

    /**
     * Creates a canvas element with the styled damage text.
     * @param {string} text - The text to draw.
     * @returns {HTMLCanvasElement}
     */
    createCanvas(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const fontSize = 48;
        context.font = `bold ${fontSize}px Arial`;
        
        const textMetrics = context.measureText(text);
        canvas.width = textMetrics.width + 10;
        canvas.height = fontSize + 10;

        // Canvas context is reset on resize, so re-apply font and styles
        context.font = `bold ${fontSize}px Arial`;
        context.fillStyle = 'rgba(255, 255, 100, 1)'; // Yellowish color for damage
        context.strokeStyle = 'rgba(0, 0, 0, 1)';
        context.lineWidth = 5;
        context.textAlign = 'center';
        
        const x = canvas.width / 2;
        const y = canvas.height / 2 + fontSize / 3;

        context.strokeText(text, x, y);
        context.fillText(text, x, y);

        return canvas;
    }

    update(deltaTime) {
        this.elapsedTime += deltaTime;
        if (this.elapsedTime >= this.lifetime) {
            this.cleanup();
            return;
        }

        // Move upwards
        this.sprite.position.y += this.upwardSpeed * deltaTime;

        // Fade out
        const progress = this.elapsedTime / this.lifetime;
        this.sprite.material.opacity = 1.0 - progress;
    }

    cleanup() {
        this.scene.remove(this.sprite);
        this.sprite.material.map.dispose();
        this.sprite.material.dispose();

        const index = this.game.updatables.indexOf(this);
        if (index > -1) {
            this.game.updatables.splice(index, 1);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/ui/DamageNumber.js ===


=== FILE: src/game/ui/HealthBar.js ===
--------------------------------------------------
import * as THREE from 'three';

export class HealthBar {
    constructor(entity) {
        this.entity = entity;
        this.scene = entity.scene;

        const healthBarGroup = new THREE.Group();

        // Background
        const bgMaterial = new THREE.SpriteMaterial({ color: 0x550000 });
        const bgSprite = new THREE.Sprite(bgMaterial);
        bgSprite.scale.set(1.0, 0.1, 1.0);
        healthBarGroup.add(bgSprite);

        // Foreground
        const fgMaterial = new THREE.SpriteMaterial({ color: 0x00ff00 });
        this.fgSprite = new THREE.Sprite(fgMaterial);
        this.fgSprite.scale.set(1.0, 0.1, 1.0);
        this.fgSprite.position.z = 0.1; // Render on top of background
        healthBarGroup.add(this.fgSprite);

        this.group = healthBarGroup;
        this.group.position.y = 1.5; // Offset above the entity's center
        this.entity.mesh.add(this.group);
    }

    updateHealth(currentHealth, maxHealth) {
        const percent = Math.max(0, currentHealth / maxHealth);
        this.fgSprite.scale.x = percent;
        // The sprite is centered, so we need to shift its position as it scales down.
        this.fgSprite.position.x = -0.5 * (1 - percent);

        if (percent < 0.3) {
            this.fgSprite.material.color.setHex(0xff0000); // Red
        } else if (percent < 0.6) {
            this.fgSprite.material.color.setHex(0xffff00); // Yellow
        } else {
            this.fgSprite.material.color.setHex(0x00ff00); // Green
        }
    }

    setVisible(visible) {
        this.group.visible = visible;
    }

    dispose() {
        this.entity.mesh.remove(this.group);
        this.fgSprite.material.dispose();
        this.group.children[0].material.dispose(); // bg material
    }
}
--------------------------------------------------
=== END OF FILE: src/game/ui/HealthBar.js ===


=== FILE: src/game/ui/HUD.js ===
--------------------------------------------------
import * as THREE from 'three';

export class HUD {
    constructor(player, game) {
        this.player = player;
        this.game = game;
        this.overlayElement = document.getElementById('screen-overlay');

        // Resource Bars
        this.healthBarElement = document.getElementById('health-bar');
        this.healthTextElement = document.getElementById('health-text');
        this.energyBarElement = document.getElementById('energy-bar');
        this.energyTextElement = document.getElementById('energy-text');

        // Movement Cooldowns
        this.doubleJumpBarElement = document.getElementById('double-jump-bar');
        this.dashBarElement = document.getElementById('dash-bar');
        
        // Ability Slots
        this.abilitySlots = [];
        for (let i = 0; i < 4; i++) {
            const slot = document.getElementById(`ability-${i}`);
            this.abilitySlots.push({
                element: slot,
                icon: slot.querySelector('.ability-icon'),
                cooldownOverlay: slot.querySelector('.ability-cooldown-overlay'),
            });
        }

        // Target Info Elements
        this.targetInfoElement = document.getElementById('target-info');
        this.targetNameElement = document.getElementById('target-name');
        this.targetHealthBarContainer = document.getElementById('target-health-bar-container');
        this.targetHealthBarElement = document.getElementById('target-health-bar');
        this.targetHealthTextElement = document.getElementById('target-health-text');
        
        // 2D Target Frame Element
        this.targetFrameElement = document.getElementById('target-frame');
        this.targetVector = new THREE.Vector3(); // Re-use vector to avoid GC churn

        // Tutorial Text Elements
        this.tutorialTextContainer = document.getElementById('tutorial-text-container');
        this.tutorialTextElement = document.getElementById('tutorial-text');
        this.tutorialTimer = null;

        if (!this.healthBarElement || !this.energyBarElement || !this.abilitySlots[3].element || !this.targetInfoElement || !this.targetFrameElement || !this.tutorialTextContainer) {
            console.error("Required HUD elements not found in the DOM!");
        }
    }

    update() {
        if (!this.player) return;
        this.updateResourceBars();
        this.updateMovementCooldowns();
        this.updateAbilitySlots();
        this.updateTargetInfo();
    }

    showTutorialText(message, duration) {
        if (this.tutorialTimer) clearTimeout(this.tutorialTimer);

        this.tutorialTextElement.innerHTML = message; // Use innerHTML to support kbd tags if needed
        this.tutorialTextContainer.style.opacity = '1';
        this.tutorialTextContainer.style.display = 'block';
        
        this.tutorialTimer = setTimeout(() => {
            this.hideTutorialText();
        }, duration * 1000);
    }

    hideTutorialText() {
        this.tutorialTextContainer.style.opacity = '0';
        // Use a timeout to hide the element after the transition ends
        setTimeout(() => {
            this.tutorialTextContainer.style.display = 'none';
        }, 500); // Must match the CSS transition duration
    }

    updateResourceBars() {
        // Health
        const healthPercent = (this.player.currentHealth / this.player.maxHealth) * 100;
        this.healthBarElement.style.width = `${healthPercent}%`;
        this.healthTextElement.textContent = `${Math.ceil(this.player.currentHealth)} / ${this.player.maxHealth}`;

        // Energy
        const energyPercent = (this.player.currentEnergy / this.player.maxEnergy) * 100;
        this.energyBarElement.style.width = `${energyPercent}%`;
        this.energyTextElement.textContent = `${Math.floor(this.player.currentEnergy)} / ${this.player.maxEnergy}`;
        
        if (energyPercent < 25) this.energyBarElement.style.backgroundColor = '#ff4757';
        else if (energyPercent < 50) this.energyBarElement.style.backgroundColor = '#ffa502';
        else this.energyBarElement.style.backgroundColor = '#2ed573';
    }

    updateMovementCooldowns() {
        const djReady = !this.player.doubleJumpOnCooldown;
        this.doubleJumpBarElement.style.width = djReady ? '100%' : `${(this.player.doubleJumpCooldownTimer / this.player.DOUBLE_JUMP_COOLDOWN) * 100}%`;
        djReady && this.player.jumpsRemaining > 0 ? this.doubleJumpBarElement.classList.remove('on-cooldown') : this.doubleJumpBarElement.classList.add('on-cooldown');
        
        const dashReady = !this.player.dashOnCooldown;
        this.dashBarElement.style.width = dashReady ? '100%' : `${(this.player.dashCooldownTimer / this.player.DASH_COOLDOWN) * 100}%`;
        dashReady ? this.dashBarElement.classList.remove('on-cooldown') : this.dashBarElement.classList.add('on-cooldown');
    }

    updateAbilitySlots() {
        for (let i = 0; i < this.abilitySlots.length; i++) {
            const slotUI = this.abilitySlots[i];
            const ability = this.player.abilities[i];

            if (ability) {
                slotUI.icon.textContent = ability.icon;
                const cooldownProgress = ability.getCooldownProgress();
                slotUI.cooldownOverlay.style.height = `${(1 - cooldownProgress) * 100}%`;
            } else {
                slotUI.icon.textContent = '';
                slotUI.cooldownOverlay.style.height = '0%';
            }

            if (i === this.player.selectedAbilityIndex) {
                slotUI.element.classList.add('selected');
            } else {
                slotUI.element.classList.remove('selected');
            }
        }
    }

    // REWORKED: Function to update target info panel and 2D frame
    updateTargetInfo() {
        const target = this.player.lockedTarget;

        if (target && !target.isDead) {
            // --- Update Target Info Panel ---
            this.targetInfoElement.style.display = 'flex';
            this.targetNameElement.textContent = target.name || 'Enemy';
            
            const healthPercent = (target.currentHealth / target.maxHealth) * 100;
            this.targetHealthBarElement.style.width = `${healthPercent}%`;
            this.targetHealthTextElement.textContent = `${Math.ceil(target.currentHealth)} / ${target.maxHealth}`;

            if (healthPercent < 30) {
                this.targetHealthBarElement.style.backgroundColor = '#ff4757'; // Red
            } else if (healthPercent < 60) {
                this.targetHealthBarElement.style.backgroundColor = '#ffa502'; // Orange
            } else {
                this.targetHealthBarElement.style.backgroundColor = '#2ed573'; // Green
            }

            // --- Update 2D Target Frame ---
            const targetPosition = this.targetVector.copy(target.body.position);
            // Aim for the center of the enemy's mesh
            const enemyHeight = target.mesh.geometry?.parameters?.height || 2;
            targetPosition.y += enemyHeight / 2;
            
            // Project 3D world space to 2D screen space
            targetPosition.project(this.game.renderer.camera);
            
            // Check if target is in front of the camera
            if (targetPosition.z < 1) {
                const x = (targetPosition.x * 0.5 + 0.5) * window.innerWidth;
                const y = (targetPosition.y * -0.5 + 0.5) * window.innerHeight;

                this.targetFrameElement.style.display = 'block';
                this.targetFrameElement.style.left = `${x}px`;
                this.targetFrameElement.style.top = `${y}px`;

                // Scale the frame based on distance from camera
                const distance = this.player.camera.position.distanceTo(target.body.position);
                const frameSize = Math.max(30, Math.min(150, 4000 / distance)); // Clamp size
                this.targetFrameElement.style.width = `${frameSize}px`;
                this.targetFrameElement.style.height = `${frameSize}px`;
            } else {
                this.targetFrameElement.style.display = 'none';
            }
        } else {
            // Hide all target info if no target or target is dead
            this.targetInfoElement.style.display = 'none';
            this.targetFrameElement.style.display = 'none';
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/ui/HUD.js ===


=== FILE: src/game/ui/TutorialManager.js ===
--------------------------------------------------
import * as CANNON from 'cannon-es';
import * as THREE from 'three';

export class TutorialManager {
    constructor(game) {
        this.game = game;
        this.world = game.physics.world;
        this.scene = game.renderer.scene;
        this.hud = game.hud;
        this.triggers = []; // Now stores {mesh, body}
        this.collisionHandler = this.onPlayerCollide.bind(this);
    }

    loadTriggers(triggersData) {
        this.clearTriggers();
        if (!triggersData || triggersData.length === 0) return;

        triggersData.forEach(data => {
            // --- Visual Mesh ---
            const geometry = new THREE.BoxGeometry(...data.size);
            const material = new THREE.MeshBasicMaterial({
                color: parseInt(data.color || "0xffffff", 16),
                transparent: true,
                opacity: 0.25,
                depthWrite: false, // Prevents weird rendering artifacts with other transparent objects
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(data.position.x, data.position.y, data.position.z);
            this.scene.add(mesh);
            
            // --- Physics Body ---
            const shape = new CANNON.Box(new CANNON.Vec3(data.size[0] / 2, data.size[1] / 2, data.size[2] / 2));
            const body = new CANNON.Body({
                type: CANNON.Body.STATIC,
                isTrigger: true // Player can pass through, but it still detects collision
            });
            body.addShape(shape);
            body.position.copy(mesh.position);
            
            // Attach our custom data to the physics body
            body.tutorialData = {
                message: data.message,
                duration: data.duration || 5,
                hasFired: false
            };
            
            this.world.addBody(body);
            this.triggers.push({ mesh, body });
        });
        
        // Listen for collisions on the player's body
        this.game.player.body.addEventListener('collide', this.collisionHandler);
    }

    onPlayerCollide(event) {
        const contactBody = event.body;
        const tutorialData = contactBody.tutorialData;

        if (tutorialData && !tutorialData.hasFired) {
            this.hud.showTutorialText(tutorialData.message, tutorialData.duration);
            tutorialData.hasFired = true; // Fire only once

            // Find the corresponding mesh and make it fade out
            const trigger = this.triggers.find(t => t.body === contactBody);
            if (trigger && trigger.mesh) {
                // Simple fade out effect
                let currentOpacity = trigger.mesh.material.opacity;
                const fadeInterval = setInterval(() => {
                    currentOpacity -= 0.05;
                    if (currentOpacity <= 0) {
                        trigger.mesh.visible = false;
                        clearInterval(fadeInterval);
                    } else {
                        trigger.mesh.material.opacity = currentOpacity;
                    }
                }, 20);
            }
        }
    }

    clearTriggers() {
        if (this.game.player?.body) {
            this.game.player.body.removeEventListener('collide', this.collisionHandler);
        }
        this.triggers.forEach(({ mesh, body }) => {
            this.scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
            this.world.removeBody(body)
        });
        this.triggers = [];
    }
}
--------------------------------------------------
=== END OF FILE: src/game/ui/TutorialManager.js ===


=== FILE: src/game/weapons/Katana.js ===
--------------------------------------------------
// src/game/weapons/Katana.js
import * as THREE from 'three';
import { Weapon } from './Weapon.js';

export class Katana extends Weapon {
    constructor(wielder) {
        super(wielder, {
            name: 'Katana',
            damage: 250,
            cooldown: 0.6,
        });

        // --- Melee Parameters ---
        this.swingRange = 4.0;
        
        // --- Animation Parameters ---
        this.isSwinging = false;
        this.swingProgress = 0;
        this.swingDuration = 0.45; // Slightly longer for a full vertical slice
        this.hitTiming = 120; // Damage applied as the blade swings down
        
        // --- PERFORMANCE & Animation State: Reusable objects ---
        this._hitCheckPos = new THREE.Vector3();
        this._enemyPos = new THREE.Vector3();
        this._forward = new THREE.Vector3();

        // --- REWORKED Keyframes for a TOP-DOWN Vertical Slice ---
        // (All positions relative to camera, rotations are local Euler angles then converted to Quaternion)

        // Idle pose (resting, held diagonally)
        this.idlePosition = new THREE.Vector3(0.4, -0.4, -0.8); 
        this.idleRotation = new THREE.Euler(
            THREE.MathUtils.degToRad(25),   // Pitch (up/down tip)
            THREE.MathUtils.degToRad(-20),  // Yaw (inward/outward)
            THREE.MathUtils.degToRad(15),   // Roll 
            'YXZ'
        );
        
        // Wind-up pose (raised high over the shoulder)
        this.windUpPosition = new THREE.Vector3(0.5, 0.4, -0.6); 
        this.windUpRotation = new THREE.Euler(
            THREE.MathUtils.degToRad(70),   // Blade points up
            THREE.MathUtils.degToRad(30),   // Pulled to the right
            THREE.MathUtils.degToRad(-20),  // Tilted back for the slice
            'YXZ'
        );

        // Follow-through pose (after the slice, low and to the left)
        this.followThroughPosition = new THREE.Vector3(-0.4, -0.5, -0.7); 
        this.followThroughRotation = new THREE.Euler(
            THREE.MathUtils.degToRad(-45),  // Blade points down
            THREE.MathUtils.degToRad(-40),  // Swung across to the left
            THREE.MathUtils.degToRad(45),   // Rolled over at the end of the swing
            'YXZ'
        );

        // Pre-calculate quaternions for smooth interpolation
        this.qIdle = new THREE.Quaternion().setFromEuler(this.idleRotation);
        this.qWindUp = new THREE.Quaternion().setFromEuler(this.windUpRotation);
        this.qFollowThrough = new THREE.Quaternion().setFromEuler(this.followThroughRotation);

        this.createMesh();
        // Set initial state
        this.mesh.position.copy(this.idlePosition);
        this.mesh.quaternion.copy(this.qIdle);
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Katana dimensions reference:
        // Blade length (Nagasa): ~70-80cm (let's use 0.7 units for the blade, hilt around 0.25-0.3)
        // Total length ~1 meter
        
        // Define common offset for the pivot point (where the player's hand holds the sword)
        // Let's assume the origin of the group is at the guard's center.
        // Hilt will extend down from here, blade will extend up.
        const bladeHeight = 0.7; // length of the blade
        const hiltHeight = 0.25; // length of the hilt
        const guardThickness = 0.02;

        // Blade material - metallic and slightly rough
        const bladeMat = new THREE.MeshStandardMaterial({ 
            color: 0xc0c0c0, // Light grey for steel
            metalness: 0.9, 
            roughness: 0.3 
        });
        const bladeGeom = new THREE.BoxGeometry(0.02, bladeHeight, 0.01); // Thinner, taller blade
        const blade = new THREE.Mesh(bladeGeom, bladeMat);
        blade.position.y = bladeHeight / 2 + guardThickness / 2; // Position above the guard
        blade.castShadow = true;
        blade.receiveShadow = true;

        // Guard (Tsuba) material - dark and less reflective
        const guardMat = new THREE.MeshStandardMaterial({ 
            color: 0x333333, // Dark grey
            metalness: 0.6, 
            roughness: 0.5 
        });
        const guardGeom = new THREE.BoxGeometry(0.06, guardThickness, 0.15); // Flat and wide
        const guard = new THREE.Mesh(guardGeom, guardMat);
        guard.position.y = 0; // At the group's pivot point
        guard.castShadow = true;
        guard.receiveShadow = true;

        // Hilt (Tsuka) material - dark and rough
        const hiltMat = new THREE.MeshStandardMaterial({ 
            color: 0x1a1a1a, // Very dark grey
            roughness: 0.8 
        });
        const hiltGeom = new THREE.CylinderGeometry(0.025, 0.02, hiltHeight, 8); // Thin cylinder for handle
        const hilt = new THREE.Mesh(hiltGeom, hiltMat);
        hilt.position.y = -hiltHeight / 2 - guardThickness / 2; // Below the guard
        hilt.castShadow = true;
        hilt.receiveShadow = true;
        
        this.mesh.add(blade, guard, hilt);
    }

    attack() {
        if (!this.canAttack() || this.isSwinging) return false;

        this.isSwinging = true;
        this.swingProgress = 0;
        this.triggerCooldown();

        // Damage calculation happens slightly after the start of the "slash" phase
        // This timing should align with the fastest part of the blade's movement.
        setTimeout(() => {
            if (this.isSwinging) { // Ensure swing hasn't finished already
                this.detectHit();
            }
        }, this.hitTiming);

        return true;
    }

    update(deltaTime) {
        super.update(deltaTime); // Update cooldown timer

        if (this.isSwinging) {
            this.swingProgress += deltaTime;
            const totalProgress = Math.min(this.swingProgress / this.swingDuration, 1.0);

            // Define timing for each animation phase (as percentages of totalDuration)
            const windUpPhaseEnd = 0.20; // 0% - 20% : Wind-up
            const slashPhaseEnd = 0.60;  // 20% - 60% : Main Slash (40% of duration)
            // const recoveryPhaseEnd = 1.0; // 60% - 100% : Recovery (40% of duration)

            let currentPosition = new THREE.Vector3();
            let currentQuaternion = new THREE.Quaternion();
            let phaseProgress;

            if (totalProgress < windUpPhaseEnd) {
                // Phase 1: Wind-up (Idle -> WindUp)
                phaseProgress = totalProgress / windUpPhaseEnd;
                // Use a cubic ease-out for a responsive wind-up
                const easedProgress = 1 - Math.pow(1 - phaseProgress, 3);
                currentPosition.lerpVectors(this.idlePosition, this.windUpPosition, easedProgress);
                currentQuaternion.copy(this.qIdle).slerp(this.qWindUp, easedProgress);

            } else if (totalProgress < slashPhaseEnd) {
                // Phase 2: Main Slash (WindUp -> FollowThrough)
                phaseProgress = (totalProgress - windUpPhaseEnd) / (slashPhaseEnd - windUpPhaseEnd);
                // Quartic ease-out for a very fast, powerful slash
                const easedProgress = 1 - Math.pow(1 - phaseProgress, 4);
                currentPosition.lerpVectors(this.windUpPosition, this.followThroughPosition, easedProgress);
                currentQuaternion.copy(this.qWindUp).slerp(this.qFollowThrough, easedProgress);

            } else {
                // Phase 3: Recovery (FollowThrough -> Idle)
                phaseProgress = (totalProgress - slashPhaseEnd) / (1.0 - slashPhaseEnd);
                // Quadratic ease-in-out for a smooth return to idle
                const easedProgress = phaseProgress < 0.5 
                    ? 2 * phaseProgress * phaseProgress 
                    : 1 - Math.pow(-2 * phaseProgress + 2, 2) / 2;
                currentPosition.lerpVectors(this.followThroughPosition, this.idlePosition, easedProgress);
                currentQuaternion.copy(this.qFollowThrough).slerp(this.qIdle, easedProgress);
            }

            this.mesh.position.copy(currentPosition);
            this.mesh.quaternion.copy(currentQuaternion);

            if (totalProgress >= 1.0) {
                this.isSwinging = false;
                this.mesh.position.copy(this.idlePosition);
                this.mesh.quaternion.copy(this.qIdle);
            }
        }
    }

    detectHit() {
        const camera = this.wielder.camera;
        camera.getWorldDirection(this._forward);
        
        const playerPos = this.wielder.body.position;

        for (const enemy of this.wielder.game.enemies) {
            if (enemy.isDead || !enemy.body) continue;

            this._enemyPos.copy(enemy.body.position);
            const distance = playerPos.distanceTo(this._enemyPos);

            if (distance < this.swingRange + enemy.body.shapes[0].radius) {
                const toEnemy = this._enemyPos.clone().sub(playerPos).normalize();
                const dot = this._forward.dot(toEnemy);
                
                // cos(50 degrees) ~= 0.64, a generous frontal cone for the swing
                if (dot > 0.64) { 
                    enemy.takeDamage(this.damage);
                    // The 'break;' statement was removed to allow hitting multiple enemies.
                }
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/Katana.js ===


=== FILE: src/game/weapons/Weapon.js ===
--------------------------------------------------
export class Weapon {
    constructor(wielder, { name, damage, cooldown }) {
        this.wielder = wielder;
        this.name = name || 'Unnamed Weapon';
        this.damage = damage || 10;
        this.cooldown = cooldown || 0.5;
        this.cooldownTimer = this.cooldown;
        this.mesh = null; // To be created by subclasses
    }

    canAttack() {
        return this.cooldownTimer >= this.cooldown;
    }

    attack() {
        throw new Error("Weapon.attack() must be implemented by subclasses.");
    }

    triggerCooldown() {
        this.cooldownTimer = 0;
    }

    update(deltaTime) {
        if (this.cooldownTimer < this.cooldown) {
            this.cooldownTimer += deltaTime;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/Weapon.js ===


=== FILE: src/world/LevelLoader.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../common/CollisionGroups.js';
import { Enemy } from '../game/entities/Enemy.js';

export class LevelLoader {
    constructor(game) {
        this.game = game;
        this.scene = game.renderer.scene;
        this.world = game.physics.world;
        this.spawnPoint = null;
        this.deathSpawnPoint = null;
    }

    async load(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Failed to load level: ${response.statusText}`);
        }
        const data = await response.json();
        this.spawnPoint = data.spawnPoint;
        this.deathSpawnPoint = data.deathSpawnPoint;
        return data;
    }

    getSpawnPoint() {
        return this.spawnPoint || { x: 0, y: 10, z: 0 };
    }

    getDeathSpawnPoint() {
        return this.deathSpawnPoint;
    }

    build(levelData) {
        // Skybox and Fog
        this.scene.background = new THREE.Color(parseInt(levelData.settings.backgroundColor || "0x000000", 16));
        this.scene.fog = new THREE.Fog(parseInt(levelData.settings.fogColor, 16), levelData.settings.fogNear, levelData.settings.fogFar);
        
        // Clean old lights
        this.scene.children.filter(c => c.isLight).forEach(l => this.scene.remove(l));
        
        // Ambient
        const ambientLight = new THREE.AmbientLight(parseInt(levelData.settings.ambientLight.color, 16), levelData.settings.ambientLight.intensity);
        this.scene.add(ambientLight);
        
        // Directional Lights
        const directionalLights = [];
        // Ensure directionalLights array exists on settings for new levels
        if (!levelData.settings.directionalLights) {
            levelData.settings.directionalLights = [];
        }
        const lightDefs = levelData.settings.directionalLights;

        // Backwards compatibility for old single-light format
        if (levelData.settings.directionalLight && lightDefs.length === 0) {
            lightDefs.push(levelData.settings.directionalLight);
        }

        lightDefs.forEach(lightData => {
            const light = this.createDirectionalLight(lightData);
            directionalLights.push(light);
        });

        const levelObjects = [];
        const enemies = [];

        levelData.objects.forEach(objData => {
            const obj = this.createObject(objData);
            levelObjects.push(obj);
        });

        if (levelData.enemies) {
            levelData.enemies.forEach(enemyData => {
                const enemy = this.createEnemy(enemyData);
                enemies.push(enemy);
            });
        }
        
        // Return triggers to be handled by the TutorialManager
        return { levelObjects, enemies, ambientLight, directionalLights, triggers: levelData.triggers, deathTriggers: levelData.deathTriggers };
    }

    createDirectionalLight(lightData) {
        const light = new THREE.DirectionalLight(parseInt(lightData.color, 16), lightData.intensity);
        light.position.set(lightData.position.x, lightData.position.y, lightData.position.z);
        
        if (lightData.targetPosition) {
            light.target.position.set(lightData.targetPosition.x, lightData.targetPosition.y, lightData.targetPosition.z);
        }
        this.scene.add(light.target); // Add target to scene for matrix updates
        
        light.castShadow = true;
        light.userData.definition = lightData; 
        this.scene.add(light);
        return light;
    }

    createObject(objData) {
        let mesh, body, shape;
        const mat = new THREE.MeshStandardMaterial({
            color: objData.material ? parseInt(objData.material.color, 16) : 0xcccccc,
            roughness: (objData.material && objData.material.roughness) || 0.8
        });

        const size = objData.size || [1, 1, 1];

        if (objData.type === 'Plane') {
            mesh = new THREE.Mesh(new THREE.PlaneGeometry(size[0], size[1]), mat);
            shape = new CANNON.Plane();
        } else { // Default to Box
            mesh = new THREE.Mesh(new THREE.BoxGeometry(...size), mat);
            const halfExtents = new CANNON.Vec3(size[0] / 2, size[1] / 2, size[2] / 2);
            shape = new CANNON.Box(halfExtents);
        }
        
        const mass = (objData.physics && objData.physics.mass) || 0;
        body = new CANNON.Body({
            type: mass > 0 ? CANNON.Body.DYNAMIC : CANNON.Body.STATIC,
            mass: mass,
            shape: shape,
            collisionFilterGroup: COLLISION_GROUPS.WORLD
        });
        
        const position = objData.position || {x:0, y:5, z:0};
        mesh.position.set(position.x, position.y, position.z);
        body.position.copy(mesh.position);
        
        if (objData.rotation) {
            mesh.rotation.set(
                THREE.MathUtils.degToRad(objData.rotation.x || 0),
                THREE.MathUtils.degToRad(objData.rotation.y || 0),
                THREE.MathUtils.degToRad(objData.rotation.z || 0)
            );
            body.quaternion.copy(mesh.quaternion);
        }
        
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        this.scene.add(mesh);
        this.world.addBody(body);

        const levelObject = { mesh, body, definition: objData };
        levelObject.userData = { gameEntity: { type: 'Object', entity: levelObject } };
        mesh.userData.gameEntity = levelObject.userData.gameEntity;
        
        return levelObject;
    }

    createEnemy(enemyData) {
        const enemy = new Enemy({ game: this.game, name: enemyData.name || 'Dummy' });
        enemy.spawn(enemyData.position);
        
        enemy.definition = enemyData; // Definition attached directly to the instance
        enemy.userData = { gameEntity: { type: 'Enemy', entity: enemy } };
        enemy.mesh.userData.gameEntity = enemy.userData.gameEntity;
        return enemy;
    }
}
--------------------------------------------------
=== END OF FILE: src/world/LevelLoader.js ===


================================================================================
Snapshot Complete.
