Flutter Project Snapshot (Python Script)
Project Root: C:\Users\levndays\Desktop\elementals\elementals
Snapshot created on: 2025-07-10T06:27:42.145538
================================================================================

=== FILE: asset-editor.html ===
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elementals - Asset Editor</title>
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/asset-editor.css">
    <link rel="icon" href="data:,">
</head>
<body>
    <div id="asset-editor-container">
        <!-- TOP MENU BAR -->
        <div id="editor-menu-bar">
            <details class="menu-dropdown">
                <summary>File</summary>
                <div class="menu-content">
                    <button id="menu-file-new-weapon">New Weapon</button>
                    <button id="menu-file-load-example">Load Example Pistol</button>
                    <hr>
                    <button id="menu-file-open">Open Asset...</button>
                    <input type="file" id="asset-file-input" accept=".json" style="display: none;">
                    <button id="menu-file-save">Save Asset</button>
                    <hr>
                    <button id="menu-file-test-viewmodel">Test in ViewModel</button>
                    <hr>
                    <button id="menu-file-exit">Exit to Main Menu</button>
                </div>
            </details>
            <details class="menu-dropdown">
                <summary>Edit</summary>
                <div class="menu-content">
                    <button id="menu-edit-undo" disabled>Undo (Ctrl+Z)</button>
                    <button id="menu-edit-redo" disabled>Redo (Ctrl+Y)</button>
                    <hr>
                    <button id="menu-edit-delete" disabled>Delete</button>
                </div>
            </details>
            <details class="menu-dropdown">
                <summary>View</summary>
                <div class="menu-content checkbox-menu">
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-grid" checked><label for="view-toggle-grid">Grid</label></div>
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-viewmodel-guide" checked><label for="view-toggle-viewmodel-guide">ViewModel Guide</label></div>
                </div>
            </details>
            <details class="menu-dropdown">
                <summary>Help</summary>
                <div class="menu-content">
                    <button id="menu-help-guide">Weapon Dev Guide</button>
                </div>
            </details>
        </div>

        <!-- TOOLBAR -->
        <div id="editor-toolbar">
             <div class="toolbar-group">
                <button id="tool-translate" class="active" title="Translate (T)">T</button>
                <button id="tool-rotate" title="Rotate (R)">R</button>
                <button id="tool-scale" title="Scale (S)">S</button>
            </div>
            <div class="separator"></div>
            <div class="toolbar-group snap-group">
                 <input type="checkbox" id="snap-toggle" title="Enable Snapping">
                 <label for="snap-toggle">Enable Snapping</label>
                 <input type="number" id="snap-translation-input" step="0.1" value="0.5" title="Grid Snap (m)">
                 <input type="number" id="snap-rotation-input" step="5" value="15" title="Angle Snap (°)">
            </div>
        </div>

        <!-- OUTLINER PANEL (Left) -->
        <div id="editor-outliner" class="side-panel">
            <div class="panel-header">HIERARCHY</div>
            <div class="panel-content" id="outliner-content">
                <div class="placeholder-text">Create a part to begin.</div>
            </div>
        </div>

        <!-- VIEWPORT (Center) -->
        <div id="editor-viewport">
            <canvas id="editor-canvas"></canvas>
            <div id="create-button-container">
                <button id="create-button" title="Create Part">+</button>
                <div id="create-context-menu" class="context-menu" style="display: none;">
                    <button data-action="addBox">Box</button>
                    <button data-action="addCylinder">Cylinder</button>
                    <button data-action="addSphere">Sphere</button>
                </div>
            </div>
            <div id="viewmodel-test-overlay" style="display: none;">
                <div id="viewmodel-crosshair">+</div>
                <div class="test-controls-info">
                    [LMB] to Fire | [R] to Reload | [WASD] to Move
                </div>
                <button id="exit-test-mode-btn">Exit Test Mode</button>
            </div>
        </div>

        <!-- INSPECTOR PANEL (Right) -->
        <div id="editor-inspector" class="side-panel">
            <div class="panel-header">INSPECTOR</div>
            <div class="panel-content" id="inspector-content">
                <div class="placeholder-text">Select a part to view its properties.</div>
            </div>
        </div>
        
        <!-- TIMELINE PANEL (Bottom) -->
        <div id="editor-timeline">
            <div class="timeline-controls">
                <select id="animation-clip-select">
                    <option>default_take</option>
                </select>
                <button id="anim-new-clip-btn">New</button>
                <button id="anim-play-btn">▶</button>
                <button id="anim-stop-btn">■</button>
                <span id="anim-time-display">0.00s</span>
                <button id="anim-add-keyframe-btn" title="Add Keyframe" disabled>+ Key</button>
            </div>
            <div class="timeline-track-area">
                <div class="timeline-scrubber"></div>
                <!-- Tracks will be dynamically added here -->
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <span class="modal-close-btn">×</span>
            <h3>Weapon Development Guide</h3>
            <div id="help-modal-content">
                <h4>1. Coordinate System & Scale</h4>
                <p>
                    The editor uses a right-handed coordinate system: <b>+Y is Up</b>, <b>+X is Right</b>, and <b>-Z is Forward</b>.
                </p>
                <p>
                    <b>Crucially, you should model your weapon pointing along the positive Z-axis (+Z).</b> The game's viewmodel will automatically handle rotating it to face away from the camera.
                </p>
                <p>
                    The scale is <b>1 unit = 1 meter</b>. A standard pistol might be 0.2-0.3 units long, while a rifle would be closer to 1.0 unit.
                </p>

                <h4>2. Hierarchy & Root Point</h4>
                <p>
                    All weapon parts must be children of the `AssetRoot` in the Outliner. The root point (origin) of your main weapon part should be where the player's hand would grip the weapon. When you test the asset, this is the point that gets attached to the viewmodel's hands.
                </p>
                
                <h4>3. Animation Clips (Coming Soon)</h4>
                <p>
                    The timeline will allow you to create and edit animation clips. The game engine looks for specific clip names to play automatically:
                </p>
                <ul>
                    <li><b><code>fire</code>:</b> Plays once when the player attacks.</li>
                    <li><b><code>reload</code>:</b> Plays when the player reloads.</li>
                    <li><b><code>inspect</code>:</b> Plays when the player inspects the weapon.</li>
                    <li><b><code>idle</code>:</b> (Optional) A looping idle animation.</li>
                </ul>
                <h4>4. Asset Properties & Attachment Points (Coming Soon)</h4>
                <p>
                    You will define asset-level properties in the Inspector when nothing is selected. This includes the asset's name and type. For weapons, you can specify attachment points by creating an empty part and giving it a special name:
                </p>
                 <ul>
                    <li><b><code>muzzle</code>:</b> An empty part positioned at the tip of the barrel. This is where muzzle flash and tracer effects will originate.</li>
                </ul>
            </div>
        </div>
    </div>


    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
            "three/addons/controls/TransformControls.js": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/controls/TransformControls.js"
        }
    }
    </script>
    
    <script type="module" src="src/asset-editor/asset_editor_main.js"></script>
</body>
</html>
--------------------------------------------------
=== END OF FILE: asset-editor.html ===


=== FILE: card-inspector.html ===
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELEMENTALS - Card Inspector</title>
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/card-inspector.css">
    <link rel="icon" href="data:,">
</head>
<body class="inspector-page">

    <div id="inspector-container">
        <header id="inspector-header">
            <h1 id="card-name-title">Card Inspector</h1>
            <button id="exit-btn" class="button-secondary">Back to Loadout</button>
        </header>

        <main id="inspector-main">
            <canvas id="inspector-canvas"></canvas>
            <div id="inspector-prompt">Loading Card...</div>
        </main>
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
        }
    }
    </script>
    <script type="module" src="src/client/ui/card_inspector_main.js"></script>

</body>
</html>
--------------------------------------------------
=== END OF FILE: card-inspector.html ===


=== FILE: editor.html ===
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elementals - Level Editor</title>
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/editor.css">
    <link rel="icon" href="data:,">
</head>
<body>
    <div id="editor-container">
        <!-- TOP MENU BAR -->
        <div id="editor-menu-bar">
            <details class="menu-dropdown">
                <summary>File</summary>
                <div class="menu-content">
                    <button id="menu-file-new">New Level</button>
                    <button id="menu-file-open">Open...</button>
                    <input type="file" id="editor-file-input" accept=".json" style="display: none;">
                    <button id="menu-file-save">Save</button>
                    <hr>
                    <button id="menu-file-play">Test Level in Game</button>
                    <hr>
                    <button id="menu-file-exit">Exit to Main Menu</button>
                </div>
            </details>
            <details class="menu-dropdown">
                <summary>Edit</summary>
                <div class="menu-content">
                    <button id="menu-edit-undo" disabled>Undo (Ctrl+Z)</button>
                    <button id="menu-edit-redo" disabled>Redo (Ctrl+Y)</button>
                    <hr>
                    <button id="menu-edit-copy" disabled>Copy (Ctrl+C)</button>
                    <button id="menu-edit-paste">Paste (Ctrl+V)</button>
                    <button id="menu-edit-delete" disabled>Delete (Del)</button>
                </div>
            </details>
            <details class="menu-dropdown">
                <summary>View</summary>
                <div class="menu-content checkbox-menu">
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-grid" checked><label for="view-toggle-grid">Grid</label></div>
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-light-helpers" checked><label for="view-toggle-light-helpers">Light Helpers</label></div>
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-spawn-helpers" checked><label for="view-toggle-spawn-helpers">Spawn Helpers</label></div>
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-msg-triggers" checked><label for="view-toggle-msg-triggers">Message Triggers</label></div>
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-death-triggers" checked><label for="view-toggle-death-triggers">Death Zones</label></div>
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-water-volumes" checked><label for="view-toggle-water-volumes">Water Volumes</label></div>
                </div>
            </details>
             <details class="menu-dropdown">
                <summary>Help</summary>
                <div class="menu-content">
                    <button id="menu-help-metrics">Player Metrics Info</button>
                </div>
            </details>
        </div>

        <!-- TOOLBAR -->
        <div id="editor-toolbar">
            <div class="toolbar-group">
                <button id="tool-translate" class="active" title="Translate (T)">T</button>
                <button id="tool-rotate" title="Rotate (R)">R</button>
                <button id="tool-scale" title="Scale (S)">S</button>
            </div>
            <div class="separator"></div>
            <div class="toolbar-group">
                 <button id="tool-space" title="Toggle Space (Q)">World</button>
            </div>
            <div class="separator"></div>
            <div class="toolbar-group snap-group">
                 <input type="checkbox" id="snap-toggle" title="Enable Snapping">
                 <label for="snap-toggle">Enable Snapping</label>
                 <input type="number" id="snap-translation-input" step="0.25" value="1" title="Grid Snap (m)">
                 <input type="number" id="snap-rotation-input" step="5" value="15" title="Angle Snap (°)">
            </div>
        </div>

        <!-- OUTLINER PANEL (Left) -->
        <div id="editor-outliner" class="side-panel">
            <div class="panel-header">OUTLINER</div>
            <div class="panel-content" id="outliner-content">
                <!-- Dynamically populated tree view -->
            </div>
        </div>

        <!-- VIEWPORT (Center) -->
        <div id="editor-viewport">
            <canvas id="game-canvas"></canvas>
            <!-- REWORKED: Single create button and context menu -->
            <div id="create-button-container">
                <button id="create-button" title="Create Object">+</button>
                <div id="create-context-menu" class="context-menu" style="display: none;">
                    <div class="context-menu-section">Primitives</div>
                    <button data-action="addBox">Box</button>
                    <div class="context-menu-section">Lights</div>
                    <button data-action="addDirectionalLight">Directional Light</button>
                    <div class="context-menu-section">Actors</div>
                    <button data-action="addEnemyRanged">Enemy (Ranged)</button>
                    <button data-action="addEnemyMelee">Enemy (Melee)</button>
                    <button data-action="addAllyRanged">Ally (Ranged)</button>
                    <button data-action="addAllyMelee">Ally (Melee)</button>
                    <div class="context-menu-section">Volumes</div>
                    <button data-action="addMessageTrigger">Message Trigger</button>
                    <button data-action="addDeathTrigger">Death Zone</button>
                    <button data-action="addWaterVolume">Water Volume</button>
                    <button data-action="addWaterfall">Waterfall</button>
                    <div class="context-menu-section">Scene Points</div>
                    <button data-action="setSpawnPointToCamera">Set Initial Spawn</button>
                    <button data-action="setDeathSpawnPointToCamera">Set Death Spawn</button>
                </div>
            </div>
        </div>

        <!-- INSPECTOR PANEL (Right) -->
        <div id="editor-inspector" class="side-panel">
            <div class="panel-header">INSPECTOR</div>
            <div class="panel-content" id="inspector-content">
                <!-- Dynamically populated properties -->
                <div class="placeholder-text">Select an object to view its properties.</div>
            </div>
        </div>
        
        <!-- ASSET BROWSER (Bottom) - REMOVED for new Create button -->
        <div id="editor-asset-browser" style="display: none;"></div>

        <!-- STATUS BAR (Bottom Edge) -->
        <div id="editor-status-bar">
            <span id="status-message">Ready.</span>
        </div>
    </div>

    <!-- INFO MODAL (Unchanged) -->
    <div id="editor-info-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <span class="modal-close-btn">×</span>
            <h3>Player Movement Metrics</h3>
            <pre id="info-modal-text"></pre>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
            "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>
    
    <script type="module" src="src/editor/editor_main.js"></script>
</body>
</html>
--------------------------------------------------
=== END OF FILE: editor.html ===


=== FILE: index.html ===
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELEMENTALS</title>
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/game.css">
    <link rel="icon" href="data:,">
</head>
<body class="">
    <!-- Menu System (wrapper) -->
    <div id="menu-system">
        <!-- Main Menu -->
        <div id="main-menu" class="menu-screen">
            <h1>ELEMENTALS</h1>
            <div class="menu-options">
                <button id="play-btn">Play</button>
                <button id="loadout-btn">Loadout</button>
                <button id="editor-btn">Level Editor</button>
                <button id="asset-editor-btn">Asset Editor</button>
            </div>
        </div>
        <!-- Level Select -->
        <div id="level-select-menu" class="menu-screen" style="display: none;">
            <h2>Select Level</h2>
            <div id="level-list" class="menu-list">
                <!-- Dynamically populated -->
            </div>
            <div class="menu-options" style="margin-top: 20px;">
                 <button id="load-custom-level-btn">Load Custom Level</button>
            </div>
            <input type="file" id="custom-level-input" accept=".json" style="display: none;">
            <button class="back-button" data-target="main-menu">Back</button>
        </div>
        <!-- Pause Menu -->
        <div id="pause-menu" class="menu-screen" style="display: none;">
            <h2>Paused</h2>
            <div class="menu-options">
                <button id="resume-btn">Resume</button>
                <button id="pause-quit-btn">Quit to Menu</button>
            </div>
        </div>
        <!-- Death Screen -->
        <div id="death-screen" class="menu-screen" style="display: none;">
            <h2>YOU DIED</h2>
            <p id="respawn-timer-text">Respawning in 5...</p>
            <div class="menu-options">
                <button id="death-quit-btn">Return to Menu</button>
            </div>
        </div>
    </div>

    <!-- In-Game UI & VFX -->
    <div id="screen-overlay" class="vfx-overlay"></div>
    <div id="vfx-dash-forward" class="vfx-overlay"></div>
    <div id="vfx-dash-sideways" class="vfx-overlay"></div>
    <div id="vfx-jump-wind" class="vfx-overlay"></div>
    <div id="vfx-ground-slam" class="vfx-overlay"></div>
    <div id="vfx-earth-buff" class="vfx-overlay"></div>
    <div id="vfx-channeling-glow" class="vfx-overlay"></div>
    <div id="vfx-underwater-overlay" class="vfx-overlay"></div>
    <div id="target-frame"></div>
    <div id="tutorial-text-container" style="display: none;">
        <p id="tutorial-text"></p>
    </div>
    
    <!-- Crosshair & Movement Cooldowns -->
    <div id="crosshair-container">
        <div id="jump-cooldown-indicator" class="movement-cooldown">
            <svg viewBox="-5 -5 110 110">
                <path class="cooldown-track" d="M 50,0 A 50,50 0 0 0 50,100" />
                <path class="cooldown-progress" d="M 50,0 A 50,50 0 0 0 50,100" />
            </svg>
        </div>
        <div id="crosshair"></div>
        <div id="dash-cooldown-indicator" class="movement-cooldown">
            <svg viewBox="-5 -5 110 110">
                <path class="cooldown-track" d="M 50,0 A 50,50 0 0 1 50,100" />
                <path class="cooldown-progress" d="M 50,0 A 50,50 0 0 1 50,100" />
            </svg>
        </div>
    </div>

    <canvas id="game-canvas"></canvas>

    <!-- Game HUD -->
    <div id="game-hud">
        <div id="hud-top-left" class="hud-corner">
            <div id="health-bar-container" class="resource-bar-container">
                <div id="health-bar"></div>
                <span class="resource-text" id="health-text"></span>
            </div>
            <div id="energy-bar-container" class="resource-bar-container">
                <div id="energy-bar"></div>
                <span class="resource-text" id="energy-text"></span>
            </div>
            <div id="oxygen-bar-container" class="resource-bar-container" style="display: none;">
                <div id="oxygen-bar"></div>
                <span class="resource-text" id="oxygen-text"></span>
            </div>
        </div>

        <div id="hud-top-center" class="hud-corner">
            <div id="enemy-counter"></div>
        </div>

        <div id="hud-top-right" class="hud-corner">
            <canvas id="minimap-canvas" width="180" height="180"></canvas>
        </div>
        
        <div id="hud-bottom-right" class="hud-corner">
            <div id="ammo-counter" style="display: none;">
                <span id="ammo-mag"></span> / <span id="ammo-reserve"></span>
            </div>
        </div>
        
        <div id="hud-bottom-center" class="hud-corner">
            <div id="abilities-container">
                <div id="ability-0" class="ability-slot">
                    <svg class="cooldown-ring" viewBox="0 0 36 36">
                        <circle class="cooldown-track" cx="18" cy="18" r="15.9155" />
                        <circle class="cooldown-ring-circle" cx="18" cy="18" r="15.9155" />
                    </svg>
                    <span class="ability-icon"></span>
                </div>
                <div id="ability-1" class="ability-slot">
                     <svg class="cooldown-ring" viewBox="0 0 36 36">
                        <circle class="cooldown-track" cx="18" cy="18" r="15.9155" />
                        <circle class="cooldown-ring-circle" cx="18" cy="18" r="15.9155" />
                    </svg>
                    <span class="ability-icon"></span>
                </div>
                <div id="ability-2" class="ability-slot">
                     <svg class="cooldown-ring" viewBox="0 0 36 36">
                        <circle class="cooldown-track" cx="18" cy="18" r="15.9155" />
                        <circle class="cooldown-ring-circle" cx="18" cy="18" r="15.9155" />
                    </svg>
                    <span class="ability-icon"></span>
                </div>
                <div id="ability-3" class="ability-slot">
                     <svg class="cooldown-ring" viewBox="0 0 36 36">
                        <circle class="cooldown-track" cx="18" cy="18" r="15.9155" />
                        <circle class="cooldown-ring-circle" cx="18" cy="18" r="15.9155" />
                    </svg>
                    <span class="ability-icon"></span>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
            "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>
    
    <script type="module" src="src/client/client_main.js"></script>
</body>
</html>
--------------------------------------------------
=== END OF FILE: index.html ===


=== FILE: loadout.html ===
--------------------------------------------------
<!-- loadout.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELEMENTALS - Loadout</title>
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/loadout.css">
    <link rel="icon" href="data:,">
</head>
<body class="loadout-page">

    <div id="loadout-screen">

        <header id="loadout-header">
            <div id="loadout-manager" class="header-section">
                <select id="loadout-select-dropdown"></select>
                <input type="text" id="loadout-name-input" placeholder="New Loadout Name...">
                <button id="save-loadout-btn">Save</button>
            </div>
            <h1 class="loadout-title">LOADOUT</h1>
            <div id="nav-controls" class="header-section">
                <button id="back-to-menu-btn">Main Menu</button>
                <button id="play-game-btn" class="play-button" disabled>Play</button>
            </div>
        </header>

        <main id="loadout-main-content">
            <!-- Left Panel: Player & Equipped -->
            <div id="player-panel">
                 <div id="player-preview-container">
                    <canvas id="player-preview-canvas"></canvas>
                 </div>
                 <div id="equipped-slots-container">
                    <div class="equipped-slot" data-slot-index="0" data-slot-type="ability" title="Ability Slot 1"></div>
                    <div class="equipped-slot" data-slot-index="1" data-slot-type="ability" title="Ability Slot 2"></div>
                    <div class="equipped-slot" data-slot-index="2" data-slot-type="ability" title="Ability Slot 3"></div>
                    <div class="equipped-slot" data-slot-index="3" data-slot-type="ability" title="Ability Slot 4"></div>
                    <div class="slot-separator">+</div>
                    <div class="equipped-slot weapon-slot" data-slot-type="weapon" title="Primary Weapon">
                        <!-- This container will be populated by LoadoutUI.js -->
                    </div>
                </div>
                <div id="synergy-display">
                    <h3 id="synergy-name"></h3>
                    <p id="synergy-description"></p>
                </div>
            </div>

            <!-- Right Panel: Inventory & Details -->
            <div id="inventory-panel">
                <div class="panel-header">
                    <h2>INVENTORY</h2>
                </div>
                <div id="inventory-grid">
                    <!-- Dynamically populated inventory slots -->
                </div>
                <div id="card-details-panel">
                    <div id="details-view-2d">
                        <div id="details-content">
                            <h3 id="details-name">SELECT A CARD</h3>
                            <p id="details-element-tier">Click a card to see its details.</p>
                            <div id="details-stats">
                                <span id="details-cost"></span>
                                <span id="details-cooldown"></span>
                            </div>
                            <hr>
                            <p id="details-description"></p>
                            <p id="details-flavor-text"></p>
                        </div>
                        <div id="details-footer">
                            <button id="inspect-card-btn" disabled>Inspect</button>
                        </div>
                    </div>
                    <!-- The 3D view is now a modal -->
                </div>
            </div>
        </main>
    </div>

    <!-- Inspector Modal -->
    <div id="inspector-modal" class="inspector-modal-overlay">
        <div class="inspector-modal-content">
            <button id="inspector-modal-close-btn" class="inspector-modal-close">×</button>
            <canvas id="inspection-canvas"></canvas>
        </div>
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
        }
    }
    </script>
    <script type="module" src="src/client/ui/loadout_main.js"></script>

</body>
</html>
--------------------------------------------------
=== END OF FILE: loadout.html ===


=== FILE: snap.py ===
--------------------------------------------------
[Content Omitted - Generated/Tooling File]

--------------------------------------------------
=== END OF FILE: snap.py ===


=== FILE: .github/workflows/static.yml ===
--------------------------------------------------
# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

--------------------------------------------------
=== END OF FILE: .github/workflows/static.yml ===


=== FILE: assets/skyboxes/manifest.json ===
--------------------------------------------------
[
  {
    "name": "Moody Sky",
    "path": "./assets/skyboxes/moody-skybox/"
  }
]
--------------------------------------------------
=== END OF FILE: assets/skyboxes/manifest.json ===


=== FILE: css/asset-editor.css ===
--------------------------------------------------
/* --- ASSET EDITOR CONTAINER & LAYOUT --- */
#asset-editor-container {
    position: absolute;
    inset: 0;
    display: grid;
    grid-template-columns: 260px 1fr 320px;
    grid-template-rows: auto auto 1fr 250px;
    grid-template-areas:
        "menu menu menu"
        "toolbar toolbar toolbar"
        "outliner viewport inspector"
        "timeline timeline timeline";
    background-color: var(--color-bg-darkest);
    color: var(--color-text-light);
    z-index: 100;
    transition: grid-template-columns 0.3s ease, grid-template-rows 0.3s ease;
}

/* --- FULLSCREEN TEST MODE --- */
#asset-editor-container.is-testing {
    grid-template-columns: 1fr;
    grid-template-rows: auto 1fr;
    grid-template-areas:
        "menu"
        "viewport";
}

#asset-editor-container.is-testing #editor-toolbar,
#asset-editor-container.is-testing #editor-outliner,
#asset-editor-container.is-testing #editor-inspector,
#asset-editor-container.is-testing #editor-timeline,
#asset-editor-container.is-testing #create-button-container {
    display: none;
}


/* --- GRID AREA ASSIGNMENTS --- */
#editor-menu-bar { grid-area: menu; z-index: 30; }
#editor-toolbar { grid-area: toolbar; z-index: 20; }
#editor-outliner { grid-area: outliner; z-index: 10; }
#editor-inspector { grid-area: inspector; z-index: 10; }
#editor-timeline { grid-area: timeline; z-index: 10; }

#editor-viewport {
    grid-area: viewport;
    position: relative;
    overflow: hidden;
    z-index: 1;
    pointer-events: none;
}
#editor-viewport > * {
    pointer-events: auto;
}


/* --- REUSE FROM EDITOR.CSS: SIDE PANELS, MENU, TOOLBAR, CONTEXT MENU --- */
.side-panel {
    background-color: var(--color-bg-dark);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border-right: 1px solid var(--color-border);
}
#editor-inspector { border-right: none; border-left: 1px solid var(--color-border); }

.panel-header {
    background-color: var(--color-bg-light);
    padding: 8px 12px;
    font-weight: 600;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.8px;
    border-bottom: 1px solid var(--color-border);
    flex-shrink: 0;
}

.panel-content { padding: 8px; overflow-y: auto; flex-grow: 1; }
.panel-content .placeholder-text { color: var(--color-text-dark); font-size: 13px; text-align: center; margin-top: 20px; padding: 0 10px; }

#editor-menu-bar { display: flex; background-color: var(--color-bg-mid); border-bottom: 1px solid var(--color-border); padding: 0 5px; flex-shrink: 0; }
.menu-dropdown { position: relative; }
.menu-dropdown summary { padding: 8px 12px; cursor: pointer; list-style: none; font-size: 13px; font-weight: 600; transition: background-color 0.2s; user-select: none; }
.menu-dropdown summary::-webkit-details-marker { display: none; }
.menu-dropdown:hover > summary, .menu-dropdown[open] > summary { background-color: var(--color-accent); color: var(--color-accent-text); }
.menu-content { position: absolute; top: 100%; left: 0; background-color: var(--color-bg-mid); border: 1px solid var(--color-border); box-shadow: 0 8px 20px hsla(0,0%,0%,0.4); min-width: 200px; padding: 6px; z-index: 1010; display: flex; flex-direction: column; border-radius: 0 0 var(--border-radius-md) var(--border-radius-md);}
.menu-content button { background: none; border: none; color: var(--color-text-light); padding: 8px 12px; text-align: left; width: 100%; cursor: pointer; font-family: inherit; font-size: 13px; border-radius: var(--border-radius-sm); }
.menu-content button:hover:not(:disabled) { background-color: var(--color-accent); color: var(--color-accent-text); }
.menu-content button:disabled { color: var(--color-text-dark); cursor: not-allowed; }
.menu-content hr { border: none; border-top: 1px solid var(--color-bg-light); margin: 6px 0; }

#editor-toolbar { display: flex; align-items: center; padding: 6px; gap: 8px; background-color: var(--color-bg-dark); border-bottom: 1px solid var(--color-border); }
.toolbar-group { display: flex; gap: 4px; align-items: center; }
#editor-toolbar .separator { border-right: 1px solid var(--color-border); height: 24px; }
#editor-toolbar button { background-color: var(--color-bg-light); border: 1px solid var(--color-border); color: var(--color-text-light); padding: 6px 10px; border-radius: var(--border-radius-sm); cursor: pointer; font-family: inherit; font-weight: 700; min-width: 32px; transition: background-color 0.2s, color 0.2s; }
#editor-toolbar button:hover { background-color: var(--color-bg-mid); }
#editor-toolbar button.active { background-color: var(--color-accent); color: var(--color-accent-text); border-color: var(--color-accent); }

.snap-group input[type="number"] { background-color: var(--color-bg-darkest); border: 1px solid var(--color-border); color: var(--color-text-light); font-family: inherit; padding: 6px; border-radius: var(--border-radius-sm); width: 50px; }
.snap-group label { font-size: 12px; font-weight: 600; color: var(--color-text-mid); user-select: none; margin-left: 8px; cursor: pointer; }
.snap-group input[type="checkbox"] { width: auto; cursor: pointer; margin: 0; margin-left: 8px; }

#create-button-container { position: absolute; top: 15px; left: 15px; z-index: 500; }
#create-button { width: 44px; height: 44px; border-radius: 50%; background-color: var(--color-accent); color: var(--color-accent-text); border: none; font-size: 28px; font-weight: 700; cursor: pointer; display: flex; justify-content: center; align-items: center; box-shadow: 0 4px 15px hsla(190, 100%, 50%, 0.3); transition: background-color 0.2s, transform 0.2s; }
#create-button:hover { background-color: var(--color-accent-hover); transform: scale(1.05); }
.context-menu { position: absolute; top: 55px; left: 0; min-width: 220px; background-color: var(--color-bg-mid); border: 1px solid var(--color-border); border-radius: var(--border-radius-md); box-shadow: 0 5px 15px hsla(0,0%,0%,0.4); padding: 6px; display: flex; flex-direction: column; }
.context-menu button { background: none; border: none; color: var(--color-text-light); padding: 8px 12px; text-align: left; width: 100%; cursor: pointer; font-family: inherit; font-size: 13px; border-radius: var(--border-radius-sm); }
.context-menu button:hover { background-color: var(--color-accent); color: var(--color-accent-text); }

/* --- Outliner --- */
.outliner-item { padding: 6px 10px; border-radius: var(--border-radius-sm); cursor: pointer; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; transition: background-color 0.15s; user-select: none; }
.outliner-item:hover { background-color: var(--color-bg-light); }
.outliner-item.selected { background-color: var(--color-accent); color: var(--color-accent-text); font-weight: 600; }
.outliner-item.drag-over { border: 2px dashed var(--color-accent); background-color: hsla(190, 100%, 50%, 0.1); }
.outliner-item[data-depth="1"] { margin-left: 15px; }
.outliner-item[data-depth="2"] { margin-left: 30px; }
.outliner-item[data-depth="3"] { margin-left: 45px; }

/* --- Inspector --- */
#inspector-content { display: flex; flex-direction: column; gap: 16px; }
.prop-group { display: flex; flex-direction: column; gap: 6px; }
#inspector-content label { font-size: 11px; color: var(--color-text-dark); text-transform: uppercase; font-weight: 600; }
#inspector-content input { background-color: var(--color-bg-darkest); border: 1px solid var(--color-border); color: var(--color-text-light); padding: 8px; border-radius: var(--border-radius-sm); font-family: inherit; font-size: 13px; width: 100%; }
#inspector-content input:focus { border-color: var(--color-accent); outline: none; }
#inspector-content input[type="color"] { padding: 2px; height: 32px; }
.prop-input-group { display: flex; gap: 6px; }
.prop-input-group input { text-align: center; }
#inspector-content hr { border: none; border-top: 1px solid var(--color-bg-light); margin: 0; }

/* --- TIMELINE PANEL (BOTTOM) --- */
#editor-timeline {
    background-color: var(--color-bg-dark);
    border-top: 1px solid var(--color-border);
    display: flex;
    flex-direction: column;
}
.timeline-controls { display: flex; align-items: center; gap: 12px; padding: 8px; background-color: var(--color-bg-mid); border-bottom: 1px solid var(--color-border); flex-shrink: 0; }
.timeline-controls select, .timeline-controls button { background-color: var(--color-bg-light); border: 1px solid var(--color-border); color: var(--color-text-light); padding: 6px 10px; border-radius: var(--border-radius-sm); font-family: inherit; font-size: 13px; font-weight: 600; }
.timeline-controls button { cursor: pointer; }
.timeline-controls button:hover:not(:disabled) { background-color: var(--color-bg-mid); }
#anim-add-keyframe-btn { background-color: var(--color-accent); color: var(--color-accent-text); }
#anim-add-keyframe-btn:hover:not(:disabled) { background-color: var(--color-accent-hover); }
#anim-time-display { font-family: 'Consolas', monospace; font-size: 14px; color: var(--color-text-mid); min-width: 60px; text-align: center; }
.timeline-track-area { flex-grow: 1; overflow: auto; position: relative; padding: 10px 0; }
.timeline-scrubber { position: absolute; top: 0; left: 0; width: 2px; height: 100%; background-color: var(--color-accent); cursor: ew-resize; z-index: 10; }

/* --- HELP MODAL --- */
#help-modal-content { max-height: 60vh; overflow-y: auto; padding-right: 15px; }
#help-modal-content h4 { color: var(--color-accent); margin-top: 20px; margin-bottom: 5px; border-bottom: 1px solid var(--color-bg-light); padding-bottom: 5px;}
#help-modal-content p, #help-modal-content li { font-size: 14px; color: var(--color-text-mid); line-height: 1.6; }
#help-modal-content ul { padding-left: 20px; }

/* --- VIEWMODEL TEST OVERLAY --- */
#viewmodel-test-overlay {
    position: absolute;
    inset: 0;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    padding: 30px;
    background: linear-gradient(to top, hsla(0, 0%, 0%, 0.5) 0%, transparent 30%);
    pointer-events: none; /* The overlay itself is not interactive */
}
#viewmodel-test-overlay > * {
    pointer-events: auto; /* Buttons inside are interactive */
}
#exit-test-mode-btn {
    padding: 10px 20px;
    background-color: var(--color-accent);
    color: var(--color-accent-text);
    border: none;
    border-radius: var(--border-radius-sm);
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.2s;
    align-self: center; /* Center horizontally */
}
#exit-test-mode-btn:hover { background-color: var(--color-accent-hover); }
.test-controls-info {
    font-size: 16px;
    color: var(--color-text-light);
    text-shadow: 0 1px 3px black;
    align-self: center;
    margin-top: auto; /* Pushes it down */
    margin-bottom: 20px; /* Space above the button */
}
#viewmodel-crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 4px;
    height: 4px;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
}
--------------------------------------------------
=== END OF FILE: css/asset-editor.css ===


=== FILE: css/card-inspector.css ===
--------------------------------------------------
.inspector-page {
    background-color: var(--color-bg-darkest);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    padding: 0;
    overflow: hidden;
}

#inspector-container {
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-rows: auto 1fr;
    grid-template-columns: 100%;
    color: var(--color-text-light);
}

#inspector-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 24px;
    background-color: var(--color-bg-dark);
    border-bottom: 1px solid var(--color-border);
    z-index: 10;
}

#inspector-header h1 {
    margin: 0;
    font-size: 1.5rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--color-accent);
}

#inspector-header button {
    padding: 8px 16px;
    font-size: 14px;
    font-weight: 600;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    border: none;
    transition: background-color 0.2s, transform 0.2s;
}
.button-secondary { background-color: var(--color-bg-light); color: var(--color-text-light); }
.button-secondary:hover { background-color: var(--color-bg-mid); }

#inspector-main {
    position: relative;
    overflow: hidden;
}

#inspector-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
}

#inspector-prompt {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: var(--color-text-dark);
    font-size: 1.2rem;
    font-weight: 600;
    pointer-events: none;
    transition: opacity 0.5s;
}
--------------------------------------------------
=== END OF FILE: css/card-inspector.css ===


=== FILE: css/common.css ===
--------------------------------------------------
/* --- Google Font Import --- */
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

/* --- GLOBAL VARIABLES & DEFAULTS --- */
:root {
    --font-primary: 'Poppins', sans-serif;
    
    --color-bg-darkest: hsl(230, 10%, 8%);
    --color-bg-dark:   hsl(230, 10%, 12%);
    --color-bg-mid:    hsl(230, 10%, 18%);
    --color-bg-light:  hsl(230, 10%, 25%);

    --color-border:    hsl(230, 10%, 10%);
    
    --color-text-light:  hsl(230, 20%, 95%);
    --color-text-mid:    hsl(230, 10%, 70%);
    --color-text-dark:   hsl(230, 10%, 50%);
    
    --color-accent:      hsl(190, 100%, 50%); /* Bright Cyan/Blue */
    --color-accent-hover:hsl(190, 100%, 60%);
    --color-accent-text: hsl(230, 20%, 5%);
    
    /* REWORKED: New, more vibrant elemental colors */
    --color-accent-fire:   hsl(25, 100%, 55%);  /* #FF771A */
    --color-accent-water:  hsl(195, 100%, 50%); /* #00A3FF */
    --color-accent-air:    hsl(180, 80%, 85%);  /* #B3FCFC */
    --color-accent-earth:  hsl(35, 45%, 50%);   /* #B39159 */
    --color-accent-utility:hsl(265, 90%, 65%);  /* #A16BFF */

    --color-delete:      hsl(0, 80%, 60%);
    --color-delete-hover:hsl(0, 80%, 70%);

    --border-radius-sm: 4px;
    --border-radius-md: 8px;
}

/* --- GLOBAL RESETS & BASE STYLES --- */
*, *::before, *::after {
    box-sizing: border-box;
}

body {
    margin: 0;
    overflow: hidden;
    background-color: var(--color-bg-darkest);
    color: var(--color-text-light);
    font-family: var(--font-primary);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    cursor: default;
}

canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* --- CUSTOM SCROLLBAR --- */
::-webkit-scrollbar {
    width: 8px;
}
::-webkit-scrollbar-track {
    background: var(--color-bg-darkest);
}
::-webkit-scrollbar-thumb {
    background: var(--color-bg-light);
    border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
    background: var(--color-bg-mid);
}

/* --- COMMON COMPONENT STYLES: MODAL --- */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: hsla(230, 20%, 5%, 0.6);
    backdrop-filter: blur(8px);
    z-index: 1000;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: modal-fade-in 0.3s ease-out;
}

@keyframes modal-fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
}

.modal-content {
    background-color: var(--color-bg-dark);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md);
    padding: 24px;
    width: 90%;
    max-width: 550px;
    color: var(--color-text-light);
    position: relative;
    box-shadow: 0 10px 30px hsla(0, 0%, 0%, 0.5);
    transform: scale(0.95);
    animation: modal-scale-up 0.3s ease-out forwards;
}

@keyframes modal-scale-up {
    from { transform: scale(0.95); }
    to { transform: scale(1); }
}

.modal-close-btn {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 28px;
    font-weight: bold;
    color: var(--color-text-dark);
    cursor: pointer;
    transition: color 0.2s, transform 0.2s;
}
.modal-close-btn:hover {
    color: var(--color-text-light);
    transform: scale(1.1);
}

.modal-content h3 {
    margin-top: 0;
    color: var(--color-accent);
    border-bottom: 1px solid var(--color-bg-light);
    padding-bottom: 12px;
    margin-bottom: 16px;
    font-size: 1.5rem;
}

#info-modal-text {
    font-family: 'Consolas', 'Courier New', monospace;
    white-space: pre-wrap;
    font-size: 13px;
    line-height: 1.7;
    margin: 0;
    color: var(--color-text-mid);
}
--------------------------------------------------
=== END OF FILE: css/common.css ===


=== FILE: css/editor.css ===
--------------------------------------------------
/* --- EDITOR CONTAINER & LAYOUT --- */
#editor-container {
    position: absolute;
    inset: 0;
    display: grid;
    grid-template-columns: 260px 1fr 320px;
    grid-template-rows: auto auto 1fr;
    grid-template-areas:
        "menu menu menu"
        "toolbar toolbar toolbar"
        "outliner viewport inspector";
    background-color: var(--color-bg-darkest);
    color: var(--color-text-light);
    z-index: 100;
}

/* --- GRID AREA ASSIGNMENTS --- */
#editor-menu-bar { grid-area: menu; }
#editor-toolbar { grid-area: toolbar; }
#editor-outliner { grid-area: outliner; }
#editor-viewport { grid-area: viewport; position: relative; overflow: hidden; }
#editor-inspector { grid-area: inspector; }

/* --- GENERAL PANEL STYLES --- */
.side-panel {
    background-color: var(--color-bg-dark);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border-right: 1px solid var(--color-border);
}
#editor-inspector { border-right: none; border-left: 1px solid var(--color-border); }

.panel-header {
    background-color: var(--color-bg-light);
    padding: 8px 12px;
    font-weight: 600;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.8px;
    border-bottom: 1px solid var(--color-border);
    flex-shrink: 0;
}

.panel-content {
    padding: 8px;
    overflow-y: auto;
    flex-grow: 1;
}

.panel-content .placeholder-text {
    color: var(--color-text-dark);
    font-size: 13px;
    text-align: center;
    margin-top: 20px;
    padding: 0 10px;
}

/* --- MENU BAR (TOP) --- */
#editor-menu-bar {
    display: flex;
    background-color: var(--color-bg-mid);
    border-bottom: 1px solid var(--color-border);
    padding: 0 5px;
    flex-shrink: 0;
}
.menu-dropdown { position: relative; }
.menu-dropdown summary {
    padding: 8px 12px;
    cursor: pointer;
    list-style: none;
    font-size: 13px;
    font-weight: 600;
    transition: background-color 0.2s;
    user-select: none;
}
.menu-dropdown summary::-webkit-details-marker { display: none; }

.menu-dropdown:hover > summary, .menu-dropdown[open] > summary {
    background-color: var(--color-accent);
    color: var(--color-accent-text);
}
.menu-content {
    position: absolute;
    top: 100%;
    left: 0;
    background-color: var(--color-bg-mid);
    border: 1px solid var(--color-border);
    box-shadow: 0 8px 20px hsla(0,0%,0%,0.4);
    min-width: 200px;
    padding: 6px;
    z-index: 1010;
    display: flex;
    flex-direction: column;
    border-radius: 0 0 var(--border-radius-md) var(--border-radius-md);
}
.menu-content button {
    background: none;
    border: none;
    color: var(--color-text-light);
    padding: 8px 12px;
    text-align: left;
    width: 100%;
    cursor: pointer;
    font-family: inherit;
    font-size: 13px;
    border-radius: var(--border-radius-sm);
}
.menu-content button:hover:not(:disabled) { background-color: var(--color-accent); color: var(--color-accent-text); }
.menu-content button:disabled { color: var(--color-text-dark); cursor: not-allowed; }
.menu-content hr { border: none; border-top: 1px solid var(--color-bg-light); margin: 6px 0; }
.checkbox-menu .checkbox-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 12px;
    cursor: pointer;
    border-radius: var(--border-radius-sm);
}
.checkbox-menu .checkbox-row:hover { background-color: var(--color-bg-light); }

/* --- TOOLBAR (BELOW MENU) --- */
#editor-toolbar {
    display: flex;
    align-items: center;
    padding: 6px;
    gap: 8px;
    background-color: var(--color-bg-dark);
    border-bottom: 1px solid var(--color-border);
}
.toolbar-group { display: flex; gap: 4px; align-items: center; }
#editor-toolbar .separator { border-right: 1px solid var(--color-border); height: 24px; }
#editor-toolbar button {
    background-color: var(--color-bg-light);
    border: 1px solid var(--color-border);
    color: var(--color-text-light);
    padding: 6px 10px;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    font-family: inherit;
    font-weight: 700;
    min-width: 32px;
    transition: background-color 0.2s, color 0.2s;
}
#editor-toolbar button:hover { background-color: var(--color-bg-mid); }
#editor-toolbar button.active { background-color: var(--color-accent); color: var(--color-accent-text); border-color: var(--color-accent); }
.snap-group input[type="number"] {
    background-color: var(--color-bg-darkest);
    border: 1px solid var(--color-border);
    color: var(--color-text-light);
    font-family: inherit;
    padding: 6px;
    border-radius: var(--border-radius-sm);
    width: 50px;
}
.snap-group label {
    font-size: 12px;
    font-weight: 600;
    color: var(--color-text-mid);
    user-select: none;
    margin-left: 8px;
    cursor: pointer;
}
.snap-group input[type="checkbox"] {
    width: auto;
    cursor: pointer;
    margin: 0;
    margin-left: 8px;
}

/* --- VIEWPORT CREATE BUTTON & MENU --- */
#create-button-container {
    position: absolute;
    top: 15px;
    left: 15px;
    z-index: 500;
}
#create-button {
    width: 44px; height: 44px;
    border-radius: 50%;
    background-color: var(--color-accent);
    color: var(--color-accent-text);
    border: none;
    font-size: 28px;
    font-weight: 700;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 4px 15px hsla(190, 100%, 50%, 0.3);
    transition: background-color 0.2s, transform 0.2s;
}
#create-button:hover { background-color: var(--color-accent-hover); transform: scale(1.05); }

.context-menu {
    position: absolute;
    top: 55px;
    left: 0;
    min-width: 220px;
    background-color: var(--color-bg-mid);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md);
    box-shadow: 0 5px 15px hsla(0,0%,0%,0.4);
    padding: 6px;
    display: flex;
    flex-direction: column;
}
.context-menu-section {
    font-size: 10px;
    text-transform: uppercase;
    color: var(--color-text-dark);
    padding: 8px 12px 4px;
    font-weight: 700;
}
.context-menu button {
    background: none; border: none; color: var(--color-text-light); padding: 8px 12px;
    text-align: left; width: 100%; cursor: pointer; font-family: inherit;
    font-size: 13px; border-radius: var(--border-radius-sm);
}
.context-menu button:hover { background-color: var(--color-accent); color: var(--color-accent-text); }

/* --- OUTLINER --- */
#outliner-content details { margin-bottom: 5px; }
#outliner-content summary {
    font-weight: 700;
    cursor: pointer;
    padding: 6px;
    border-radius: var(--border-radius-sm);
    font-size: 11px;
    text-transform: uppercase;
    color: var(--color-text-dark);
    letter-spacing: 0.5px;
}
#outliner-content summary:hover { background-color: var(--color-bg-light); }
.outliner-item {
    padding: 6px 10px;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    font-size: 13px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    transition: background-color 0.15s;
    margin-left: 10px;
}
.outliner-item:hover { background-color: var(--color-bg-light); }
.outliner-item.selected { background-color: var(--color-accent); color: var(--color-accent-text); font-weight: 600; }

/* --- INSPECTOR --- */
#inspector-content { display: flex; flex-direction: column; gap: 16px; }
.prop-group { display: flex; flex-direction: column; gap: 6px; }
#inspector-content label { font-size: 11px; color: var(--color-text-dark); text-transform: uppercase; font-weight: 600; }
#inspector-content input, #inspector-content .delete-button {
    background-color: var(--color-bg-darkest);
    border: 1px solid var(--color-border);
    color: var(--color-text-light);
    padding: 8px;
    border-radius: var(--border-radius-sm);
    font-family: inherit;
    font-size: 13px;
    width: 100%;
}
#inspector-content input:focus { border-color: var(--color-accent); outline: none; }
#inspector-content input[type="color"] { padding: 2px; height: 32px; }
.prop-input-group { display: flex; gap: 6px; }
.prop-input-group input { text-align: center; }

#inspector-content hr { border: none; border-top: 1px solid var(--color-bg-light); margin: 0; }
.delete-button {
    background-color: var(--color-delete);
    border: 1px solid var(--color-delete);
    cursor: pointer;
    font-weight: 700;
    margin-top: auto; /* Pushes to the bottom */
    transition: background-color 0.2s;
}
.delete-button:hover { background-color: var(--color-delete-hover); }
--------------------------------------------------
=== END OF FILE: css/editor.css ===


=== FILE: css/game.css ===
--------------------------------------------------
/* css/game.css */
/* --- GAMEPLAY STATE --- */
body:not(.game-active) #game-hud,
body:not(.game-active) #crosshair-container,
body:not(.game-active) #target-frame,
body:not(.game-active) #tutorial-text-container {
    display: none !important;
}

/* --- IN-GAME VFX --- */
.vfx-overlay {
    position: absolute; inset: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 99; opacity: 0;
}
#screen-overlay.active {
    opacity: 1; animation: damage-pulse 0.3s ease-out forwards;
    background-image: radial-gradient(circle at 50% 50%, transparent 60%, hsla(0, 100%, 50%, 0.7) 95%);
}
@keyframes damage-pulse {
    from { opacity: 1; transform: scale(1); }
    to { opacity: 0; transform: scale(1.2); }
}
#vfx-dash-forward.active {
    opacity: 1;
    background: radial-gradient(ellipse at center, transparent 30%, hsla(190, 100%, 70%, 0.2) 100%);
    clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);
    animation: dash-forward-zoom 0.25s ease-out forwards;
}
@keyframes dash-forward-zoom {
    from { transform: scale(0.5, 2); opacity: 1; }
    to { transform: scale(2, 2); opacity: 0; }
}
#vfx-dash-sideways::before, #vfx-dash-sideways::after {
    content: ''; position: absolute; top: 50%; height: 2px; width: 40vw;
    background: linear-gradient(to right, transparent, hsla(190, 100%, 70%, 0.9) 70%, transparent);
    opacity: 0; will-change: transform, opacity;
}
#vfx-dash-sideways.active.left-to-right::before, #vfx-dash-sideways.active.left-to-right::after { animation: whoosh-lr 0.25s ease-out forwards; }
#vfx-dash-sideways.active.right-to-left::before, #vfx-dash-sideways.active.right-to-left::after { animation: whoosh-rl 0.25s ease-out forwards; }
@keyframes whoosh-lr {
    0%   { transform: translateX(-60vw) scaleX(0.3); opacity: 0.5; }
    20%  { transform: translateX(-30vw) scaleX(1); opacity: 1; }
    100% { transform: translateX(60vw) scaleX(0.3); opacity: 0; }
}
@keyframes whoosh-rl {
    0%   { transform: translateX(60vw) scaleX(0.3); opacity: 0.5; }
    20%  { transform: translateX(30vw) scaleX(1); opacity: 1; }
    100% { transform: translateX(-60vw) scaleX(0.3); opacity: 0; }
}
#vfx-jump-wind.active {
    opacity: 0.4;
    background-image: radial-gradient(ellipse at 50% 150%, hsla(190, 100%, 80%, 0.5) 0%, transparent 60%);
    animation: jump-wind-effect 0.4s ease-in-out forwards;
}
@keyframes jump-wind-effect {
    from { opacity: 0.4; transform: scaleY(1); }
    to { opacity: 0; transform: scaleY(1.5); }
}
#vfx-ground-slam.active {
    opacity: 1;
    background: radial-gradient(ellipse at 50% 100%, hsla(190, 100%, 80%, 0.4) 0%, transparent 60%);
    animation: ground-slam-shockwave 0.4s ease-out forwards;
}
@keyframes ground-slam-shockwave {
    from { transform: scale(0); opacity: 1; }
    to { transform: scale(2); opacity: 0; }
}

#vfx-earth-buff.active {
    opacity: 1;
    background-image: radial-gradient(ellipse at center, transparent 70%, hsla(35, 45%, 50%, 0.6) 100%);
    animation: earth-buff-pulse 3s infinite ease-in-out;
    transition: opacity 0.5s ease-out;
}
@keyframes earth-buff-pulse {
    0% { transform: scale(1.0); opacity: 0.8; }
    50% { transform: scale(1.02); opacity: 1.0; }
    100% { transform: scale(1.0); opacity: 0.8; }
}

/* NEW: Channeling VFX */
#vfx-channeling-glow {
    background-image:
        radial-gradient(ellipse 40vw 40vh at top left, hsla(265, 90%, 75%, 0.35) 0%, transparent 50%),
        radial-gradient(ellipse 40vw 40vh at top right, hsla(265, 90%, 75%, 0.35) 0%, transparent 50%),
        radial-gradient(ellipse 40vw 40vh at bottom left, hsla(265, 90%, 75%, 0.35) 0%, transparent 50%),
        radial-gradient(ellipse 40vw 40vh at bottom right, hsla(265, 90%, 75%, 0.35) 0%, transparent 50%);
    transition: opacity 0.5s ease-in-out;
}
#vfx-channeling-glow.active {
    opacity: 1;
    animation: channeling-pulse 4s infinite ease-in-out;
}
@keyframes channeling-pulse {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; }
}

/* NEW: Underwater VFX */
#vfx-underwater-overlay {
    background-color: hsla(195, 100%, 50%, 0.2);
    /* backdrop-filter: blur(2px); */ /* REMOVED as requested */
    transition: opacity 0.5s ease-in-out;
}
#vfx-underwater-overlay.active {
    opacity: 1;
}


/* REWORKED: CROSSHAIR & TARGETING */
#crosshair-container {
    position: absolute; inset: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none;
    z-index: 10;
}

#crosshair {
    width: 4px; height: 4px;
    background-color: hsla(0, 0%, 100%, 0.8);
    border-radius: 50%;
    box-shadow: 0 0 5px hsla(0, 0%, 100%, 0.5);
    flex-shrink: 0;
}

.movement-cooldown {
    position: absolute; /* REWORKED: Position on top of each other */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 60px; height: 60px;
    opacity: 0;
    transition: opacity 0.3s ease;
}
.movement-cooldown.on-cooldown { opacity: 0.8; }
.movement-cooldown svg { width: 100%; height: 100%; }
.movement-cooldown path {
    fill: none;
    stroke-linecap: round;
    stroke-width: 8;
}
.movement-cooldown .cooldown-track {
    stroke: hsla(230, 10%, 12%, 0.7);
}
.movement-cooldown .cooldown-progress {
    stroke: var(--color-accent);
    stroke-dasharray: 157; /* pi * r (3.14 * 50) */
    stroke-dashoffset: 157; /* Starts empty */
    transition: stroke-dashoffset 0.1s linear;
}

#target-frame {
    position: absolute; border: 2px solid var(--color-accent);
    border-radius: 50%;
    box-shadow: 0 0 10px var(--color-accent), inset 0 0 10px var(--color-accent);
    display: none; transform: translate(-50%, -50%);
    transition: width 0.1s linear, height 0.1s linear;
    animation: target-frame-pulse 2s infinite ease-in-out;
}
@keyframes target-frame-pulse {
    0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    50% { opacity: 0.7; transform: translate(-50%, -50%) scale(0.95); }
}

/* REWORKED GAME HUD LAYOUT */
#game-hud {
    position: absolute; inset: 0; pointer-events: none; z-index: 10;
    font-family: var(--font-primary);
}
.hud-corner {
    position: absolute;
    display: flex;
    flex-direction: column;
    padding: 20px;
}
#hud-top-left {
    top: 0; left: 0;
    gap: 8px;
    padding: 30px;
}
#hud-top-center {
    top: 0; left: 50%; transform: translateX(-50%);
}
#hud-top-right {
    top: 0; right: 0; align-items: flex-end;
}
#hud-bottom-center {
    bottom: 0; left: 50%; transform: translateX(-50%);
    align-items: center;
}
#hud-bottom-right {
    bottom: 0; right: 0; align-items: flex-end;
    justify-content: flex-end;
}

/* HUD WIDGETS */
#minimap-canvas {
    width: 180px; height: 180px;
    background-color: hsla(230, 10%, 8%, 0.5);
    border: 2px solid var(--color-border);
    border-radius: 50%;
    box-shadow: 0 0 15px hsla(0, 0%, 0%, 0.5);
}

#enemy-counter {
    background-color: hsla(230, 10%, 8%, 0.7);
    padding: 8px 20px;
    border-radius: var(--border-radius-sm);
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--color-text-mid);
    text-shadow: 1px 1px 2px black;
    letter-spacing: 1px;
    text-transform: uppercase;
}

.resource-bar-container {
    width: 400px;
    height: 15px;
    background-color: var(--color-bg-dark);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-sm);
    padding: 2px;
    box-shadow: inset 0 1px 2px hsla(0,0%,0%,0.5);
    position: relative;
}
#health-bar, #energy-bar, #oxygen-bar {
    height: 100%; border-radius: 2px;
    /* transition: width 0.2s ease-out; */ /* REMOVED to fix update bug */
    position: relative;
}
#health-bar { background: linear-gradient(to right, hsl(0, 100%, 60%), hsl(0, 100%, 75%)); }
#energy-bar { background: linear-gradient(to right, hsl(190, 100%, 45%), hsl(190, 100%, 65%)); }
#oxygen-bar { background: linear-gradient(to right, hsl(200, 100%, 70%), hsl(200, 100%, 85%)); }

/* REWORKED: Resource bar separators and text */
.resource-bar-container::after {
    content: '';
    position: absolute;
    inset: 2px;
    pointer-events: none;
    background-repeat: no-repeat;
    background-size: 2px 100%; /* Make separators wider to create a gap effect */
}

#health-bar-container::after {
    background-image:
        linear-gradient(var(--color-bg-dark) 0 0), linear-gradient(var(--color-bg-dark) 0 0),
        linear-gradient(var(--color-bg-dark) 0 0), linear-gradient(var(--color-bg-dark) 0 0),
        linear-gradient(var(--color-bg-dark) 0 0), linear-gradient(var(--color-bg-dark) 0 0),
        linear-gradient(var(--color-bg-dark) 0 0), linear-gradient(var(--color-bg-dark) 0 0),
        linear-gradient(var(--color-bg-dark) 0 0);
    background-position: 10% 0, 20% 0, 30% 0, 40% 0, 50% 0, 60% 0, 70% 0, 80% 0, 90% 0;
}

#energy-bar-container::after,
#oxygen-bar-container::after {
    background-image:
        linear-gradient(var(--color-bg-dark) 0 0), linear-gradient(var(--color-bg-dark) 0 0),
        linear-gradient(var(--color-bg-dark) 0 0), linear-gradient(var(--color-bg-dark) 0 0);
    background-position: 20% 0, 40% 0, 60% 0, 80% 0;
}

.resource-text {
    position: absolute;
    left: 0;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    font-size: 11px;
    font-weight: 700;
    color: var(--color-text-light);
    text-shadow: 1px 1px 2px hsla(0, 0%, 0%, 0.8);
    pointer-events: none;
    z-index: 1;
    text-align: center;
}

#energy-bar-container.flash-error #energy-bar::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(to right, hsl(0, 100%, 60%), hsl(0, 100%, 75%));
    border-radius: 2px;
    animation: blink-fade 0.5s 4;
}

@keyframes blink-fade {
    0%, 100% { opacity: 0; }
    50% { opacity: 1; }
}


/* REWORKED: Abilities Container & Slots */
#abilities-container {
    display: flex; gap: 16px;
}
.ability-slot {
    width: 64px; height: 64px;
    background-color: var(--color-bg-darkest);
    border: 2px solid var(--color-bg-light);
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    position: relative;
    transition: border-color 0.2s, box-shadow 0.2s, transform 0.2s;
    box-shadow: inset 0 0 10px hsla(0,0%,0%,0.6);
}
.ability-slot.ready { border-color: var(--color-text-light); }

.ability-icon {
    width: 100%;
    height: 100%;
    z-index: 2;
    background-size: 80%;
    background-position: center;
    background-repeat: no-repeat;
    /* For loading state */
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--color-text-dark);
}

.cooldown-ring {
    position: absolute; width: 100%; height: 100%;
    transform: rotate(-90deg); z-index: 1;
}
.cooldown-ring .cooldown-track {
    stroke-width: 4;
    stroke: hsla(230, 10%, 18%, 0.8);
    fill: none;
}
.cooldown-ring-circle {
    fill: none;
    stroke-width: 5;
    stroke-linecap: round;
    stroke-dasharray: 100 100;
    stroke-dashoffset: 100; /* Starts empty */
    transition: stroke-dashoffset 0.1s linear;
}

/* Elemental Slot Styling */
.ability-slot.selected { transform: scale(1.1); }
.ability-slot.element-fire .cooldown-ring-circle { stroke: var(--color-accent-fire); }
.ability-slot.element-fire.selected { border-color: var(--color-accent-fire); box-shadow: 0 0 15px var(--color-accent-fire); }
.ability-slot.element-water .cooldown-ring-circle { stroke: var(--color-accent-water); }
.ability-slot.element-water.selected { border-color: var(--color-accent-water); box-shadow: 0 0 15px var(--color-accent-water); }
.ability-slot.element-air .cooldown-ring-circle { stroke: var(--color-accent-air); }
.ability-slot.element-air.selected { border-color: var(--color-accent-air); box-shadow: 0 0 15px var(--color-accent-air); }
.ability-slot.element-earth .cooldown-ring-circle { stroke: var(--color-accent-earth); }
.ability-slot.element-earth.selected { border-color: var(--color-accent-earth); box-shadow: 0 0 15px var(--color-accent-earth); }
.ability-slot.element-utility .cooldown-ring-circle { stroke: var(--color-accent-utility); }
.ability-slot.element-utility.selected { border-color: var(--color-accent-utility); box-shadow: 0 0 15px var(--color-accent-utility); }

.ability-slot:not([class*='element-']) .cooldown-ring-circle {
    stroke: var(--color-accent);
}
.ability-slot:not([class*='element-']).selected {
    border-color: var(--color-accent);
    box-shadow: 0 0 15px var(--color-accent);
}

/* REWORKED: Ability Cooldown Error Flash */
.ability-slot.flash-cooldown-error {
    /* This animation targets the slot's border and glow */
    animation: flash-red-border-error 0.5s 4;
}

.ability-slot.flash-cooldown-error .ability-icon {
    /* This animation targets the icon itself, making it blink red */
    animation: blink-red-icon-error 0.5s 4;
}

.ability-slot.flash-cooldown-error .cooldown-track {
    /* This makes the background of the cooldown ring flash red as well */
    animation: flash-track-error 0.5s 4;
}

/* The .cooldown-ring-circle is NOT animated, preserving the cooldown progress display. */

@keyframes flash-red-border-error {
    0%, 49.9% {
        border-color: hsl(0, 80%, 60%);
        /* Combine outer glow with existing inner shadow */
        box-shadow: 0 0 15px hsl(0, 80%, 60%), inset 0 0 10px hsla(0,0%,0%,0.6);
    }
    /* 50%-100%: Properties revert to their normally computed values for the "off" part of the blink */
}

@keyframes blink-red-icon-error {
    0%, 49.9% {
        /* A filter trick to make the icon red and bright */
        filter: brightness(1.5) sepia(1) hue-rotate(-50deg) saturate(8);
        opacity: 0.5;
    }
    /* 50%-100%: Revert to normal state */
}

@keyframes flash-track-error {
    0%, 49.9% {
        stroke: hsl(0, 50%, 30%);
    }
    /* 50%-100%: Revert to normal state */
}

/* NEW: Ammo Counter */
#ammo-counter {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--color-text-light);
    text-shadow: 2px 2px 5px hsla(0, 0%, 0%, 0.7);
    text-align: right;
    margin-bottom: 20px;
}
#ammo-counter.reloading #ammo-mag {
    color: var(--color-accent-fire);
    animation: ammo-reloading-pulse 1s infinite;
}
@keyframes ammo-reloading-pulse {
    50% { opacity: 0.6; }
}
#ammo-mag {
    font-size: 3rem;
    color: var(--color-accent);
}

/* --- PAUSE & DEATH SCREENS --- */
#pause-menu h2 { color: var(--color-text-light); }
#death-screen h2 { color: var(--color-accent-fire); text-shadow: 0 0 20px var(--color-accent-fire); }
#respawn-timer-text { font-size: 1.5rem; color: var(--color-text-mid); }

/* --- TUTORIAL TEXT --- */
#tutorial-text-container {
    position: absolute; bottom: 25%; left: 50%;
    transform: translateX(-50%); width: 90%; max-width: 600px;
    background-color: hsla(230, 10%, 12%, 0.8);
    border-left: 4px solid var(--color-accent);
    padding: 20px 25px; border-radius: var(--border-radius-sm);
    z-index: 50; transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    backdrop-filter: blur(5px);
}
#tutorial-text {
    color: var(--color-text-light); font-size: 1.1rem; line-height: 1.6; margin: 0;
}
#tutorial-text kbd {
    background-color: var(--color-text-light); color: var(--color-bg-darkest);
    border-radius: var(--border-radius-sm); padding: 2px 6px;
    font-weight: bold; font-size: 0.9em;
    border-bottom: 2px solid var(--color-text-mid);
}
#tutorial-text-container.level-complete {
    border-left-color: gold;
    background-color: hsla(45, 100%, 50%, 0.1);
}
#tutorial-text-container.level-complete #tutorial-text {
    font-size: 2.5rem; text-align: center; color: gold;
    font-weight: 700; text-shadow: 0 0 15px gold;
}
--------------------------------------------------
=== END OF FILE: css/game.css ===


=== FILE: css/loadout.css ===
--------------------------------------------------
/* css/loadout.css */
/* css/loadout.css */
.loadout-page {
    background-color: var(--color-bg-darkest);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
}

#loadout-screen {
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-rows: auto 1fr;
    color: var(--color-text-light);
}

/* --- HEADER --- */
#loadout-header {
    grid-row: 1;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 24px;
    background-color: var(--color-bg-dark);
    border-bottom: 1px solid var(--color-border);
    z-index: 10;
}
.header-section { flex: 1; display: flex; gap: 10px; align-items: center; }
.header-section:last-child { justify-content: flex-end; }
.header-section:first-child { justify-content: flex-start; }
#loadout-header h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; text-transform: uppercase; color: var(--color-accent); flex: 0; white-space: nowrap; padding: 0 40px;}
#loadout-manager select, #loadout-manager input { background: var(--color-bg-darkest); border: 1px solid var(--color-border); color: var(--color-text-light); padding: 8px 12px; border-radius: var(--border-radius-sm); font-family: inherit; }
#loadout-manager button, #nav-controls button { padding: 8px 16px; font-size: 14px; font-weight: 600; border-radius: var(--border-radius-sm); cursor: pointer; border: none; transition: background-color 0.2s, transform 0.2s; }
#save-loadout-btn, #play-game-btn.play-button { background-color: var(--color-accent); color: var(--color-accent-text); }
#back-to-menu-btn { background-color: var(--color-bg-light); color: var(--color-text-light); }
#play-game-btn:disabled { background-color: var(--color-bg-darkest); color: var(--color-text-dark); cursor: not-allowed; }

/* --- MAIN 2-COLUMN LAYOUT --- */
#loadout-main-content {
    grid-row: 2;
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 20px;
    padding: 20px;
    overflow: hidden;
}
#player-panel {
    background-color: var(--color-bg-dark);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md);
    display: flex;
    flex-direction: column;
    gap: 20px; 
    padding: 20px;
}

/* --- PLAYER PANEL (LEFT) --- */
#player-preview-container { flex-grow: 1; position: relative; background-color: var(--color-bg-darkest); border-radius: var(--border-radius-md); overflow: hidden; }
#player-preview-canvas { position: absolute; inset: 0; width: 100%; height: 100%; }
#equipped-slots-container { display: flex; justify-content: center; align-items: center; gap: 15px; padding: 10px 0; }

.equipped-slot {
    width: 85px;
    height: 119px;
    border-radius: var(--border-radius-sm);
    background-color: var(--color-bg-darkest);
    border: 2px dashed var(--color-bg-light);
    transition: all 0.2s;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}
.equipped-slot:hover, .equipped-slot.drag-over { border-color: var(--color-accent); background-color: hsla(190, 100%, 50%, 0.1); transform: scale(1.05); }

.equipped-slot:has(.card-item) {
    border-color: transparent;
    background-color: transparent;
}
.equipped-slot .card-item { width: 100%; height: 100%; }

/* NEW: Separator Style */
.slot-separator {
    font-size: 2rem;
    color: var(--color-text-dark);
    font-weight: 200;
    margin: 0 -5px; /* Pull it closer to the slots */
}

#synergy-display { padding: 15px; border-radius: var(--border-radius-sm); text-align: center; transition: all 0.3s; background-color: var(--color-bg-darkest); border: 1px solid var(--color-border); }
#synergy-display.synergy-valid { background: hsla(150, 70%, 40%, 0.15); border-color: hsla(150, 70%, 40%, 0.8); }
#synergy-display.synergy-invalid { background: hsla(0, 70%, 50%, 0.15); border-color: hsla(0, 70%, 50%, 0.8); }
#synergy-name { margin: 0 0 5px 0; font-size: 18px; font-weight: bold; }
#synergy-display.synergy-valid #synergy-name { color: hsl(150, 70%, 60%); }
#synergy-display.synergy-invalid #synergy-name { color: hsl(0, 70%, 60%); }
#synergy-description { margin: 0; font-size: 14px; color: var(--color-text-mid); }

/* --- INVENTORY & DETAILS PANEL (RIGHT) --- */
#inventory-panel {
    display: flex;
    flex-direction: column;
    background-color: var(--color-bg-dark);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md);
    overflow: hidden;
    transition: background-color 0.2s ease-out;
}
#inventory-panel.inventory-drag-over { background-color: var(--color-bg-mid); }
#inventory-panel .panel-header { padding: 12px 15px; border-bottom: 1px solid var(--color-border); flex-shrink: 0; }
#inventory-panel h2 { margin: 0; font-size: 1rem; text-transform: uppercase; letter-spacing: 1px; color: var(--color-text-mid); }
#inventory-grid {
    flex-grow: 1;
    overflow-y: auto;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    grid-auto-rows: 140px;
    gap: 15px;
    padding: 15px;
}
.inventory-slot { border: 1px solid var(--color-bg-light); border-radius: var(--border-radius-sm); background-color: var(--color-bg-darkest); display: flex; justify-content: center; align-items: center; }
.inventory-slot .card-item { width: 100%; height: 100%; }

/* --- CARD DETAILS SUB-PANEL --- */
#card-details-panel {
    flex-shrink: 0;
    height: 280px;
    border-top: 1px solid var(--color-border);
    background-color: var(--color-bg-dark);
    position: relative;
}
#details-view-2d { padding: 20px; display: flex; flex-direction: column; height: 100%; }
#details-content { flex-grow: 1; overflow-y: auto; }
#details-name { font-size: 1.5rem; margin: 0 0 5px 0; color: var(--color-text-light); text-shadow: 0 0 10px var(--color-accent); }
#details-element-tier { font-size: 0.9rem; color: var(--color-text-mid); margin-bottom: 10px; }
#details-stats { display: flex; gap: 20px; font-weight: bold; font-size: 0.9rem; color: var(--color-text-mid); }
#details-description { font-size: 0.95rem; line-height: 1.6; color: var(--color-text-mid); }
#details-flavor-text { font-style: italic; color: var(--color-text-dark); border-left: 3px solid var(--color-bg-light); padding-left: 10px; margin-top: 10px; font-size: 0.85rem; }
#details-footer { margin-top: auto; padding-top: 15px; }
#details-footer button { width: 100%; padding: 10px; font-size: 14px; font-weight: 600; cursor: pointer; background-color: var(--color-bg-light); color: var(--color-text-light); border: 1px solid var(--color-border); border-radius: var(--border-radius-sm); transition: all 0.2s; }
#details-footer button:not(:disabled):hover { background-color: var(--color-accent); color: var(--color-accent-text); }
#details-footer button:disabled { background-color: var(--color-bg-darkest); color: var(--color-text-dark); cursor: not-allowed; }

/* --- CARD ITEM STYLES --- */
.card-item {
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    height: 100%;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
    overflow: hidden;
    color: white;
    box-shadow: inset 0 0 20px 10px hsla(0, 0%, 0%, 0.2);
    border: 1px solid transparent;
}
.card-item.dragging { opacity: 0.5; transform: scale(0.95); }
.card-item.selected, .inventory-slot:hover .card-item { transform: scale(1.05); border-color: var(--color-accent); }

.card-item::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background-color: var(--color-text-dark);
    z-index: 2;
}
.card-item.tier-1::after { background-color: hsl(210, 80%, 60%); }
.card-item.tier-2::after { background-color: hsl(290, 80%, 65%); }
.card-item.tier-3::after { background-color: hsl(0, 80%, 60%); }

.card-item-icon {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-size: 85%;
    background-position: center;
    background-repeat: no-repeat;
    opacity: 0.8;
    transition: all 0.3s;
}
.card-item:hover .card-item-icon {
    opacity: 1;
    transform: scale(1.1);
}

.card-item-text {
    position: relative;
    z-index: 1;
    padding: 8px;
    background: linear-gradient(to top, hsla(0, 0%, 0%, 0.8), transparent);
}
.card-item-name, .card-item-type {
    display: block;
    text-align: left;
    text-shadow: 1px 1px 3px hsla(0, 0%, 0%, 0.6);
    line-height: 1.2;
}
.card-item-name {
    font-weight: 700;
    font-size: 0.8rem;
    text-transform: uppercase;
}
.card-item-type {
    font-weight: 400;
    font-size: 0.65rem;
    padding-bottom: 5px;
}

/* Elemental/Ability Card Backgrounds */
.card-item.element-fire    { background-color: hsl(25, 100%, 55%); }
.card-item.element-water   { background-color: hsl(195, 100%, 50%); }
.card-item.element-air     { background-color: hsl(180, 80%, 85%); }
.card-item.element-earth   { background-color: hsl(35, 45%, 50%); }
.card-item.element-utility { background-color: hsl(265, 90%, 65%); }

/* Weapon Card Overrides */
.card-item.type-weapon {
    background: linear-gradient(145deg, hsl(230, 10%, 28%), hsl(230, 10%, 18%));
    border: 1px solid hsl(230, 10%, 12%);
}
.card-item.type-weapon::after {
    background-color: var(--color-text-dark);
}
.card-item.type-weapon.tier-1::after { background-color: hsl(210, 10%, 60%); }
.card-item.type-weapon.tier-2::after { background-color: hsl(210, 10%, 85%); }
.card-item.type-weapon.tier-3::after { background-color: hsl(0, 0%, 100%); }

.card-item.type-weapon .card-item-icon {
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="rgba(255,255,255,0.8)"><path d="M22,4 C22,4 18,1 18,1 C18,1 14,4 14,4 C14,4 14,14 14,14 C14,14 12,16 12,16 C12,16 11,23 11,23 L13,23 L13,16 C13,16 18,16 18,16 C18,16 22,13 22,13 C22,13 22,4 22,4 Z M10,14 L10,23 L8,23 L8,14 C8,14 2,14 2,14 C2,14 2,4 2,4 C2,4 6,1 6,1 C6,1 10,4 10,4 L10,14 Z"/></svg>');
    background-size: 65%;
    opacity: 0.6;
}


/* --- INSPECTOR MODAL --- */
.inspector-modal-overlay {
    position: fixed; inset: 0; background-color: hsla(230, 20%, 5%, 0.6);
    backdrop-filter: blur(8px); z-index: 2000;
    justify-content: center; align-items: center;
    display: none;
}
.inspector-modal-overlay.active {
    display: flex;
    animation: modal-fade-in 0.3s ease-out;
}
@keyframes modal-fade-in { from { opacity: 0; } to { opacity: 1; } }

.inspector-modal-content {
    width: 90vw; height: 90vh; max-width: 1400px; max-height: 900px;
    background-color: var(--color-bg-darkest); border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md); position: relative;
    box-shadow: 0 10px 40px hsla(0, 0%, 0%, 0.5); overflow: hidden;
    animation: modal-scale-up 0.3s ease-out forwards;
}
@keyframes modal-scale-up { from { transform: scale(0.95); } to { transform: scale(1); } }
.inspector-modal-close {
    position: absolute; top: 10px; right: 15px; width: 40px; height: 40px;
    background: hsla(0, 0%, 100%, 0.1); border: none; border-radius: 50%;
    color: var(--color-text-light); font-size: 28px; font-weight: 300;
    line-height: 40px; text-align: center; cursor: pointer; z-index: 10;
    transition: background-color 0.2s, transform 0.2s;
}
.inspector-modal-close:hover { background: var(--color-accent); color: var(--color-accent-text); transform: rotate(90deg); }
#inspection-canvas { position: absolute; inset: 0; width: 100%; height: 100%; }
--------------------------------------------------
=== END OF FILE: css/loadout.css ===


=== FILE: css/menu.css ===
--------------------------------------------------
/* --- MENU SYSTEM --- */
#menu-system {
    position: absolute;
    inset: 0;
    z-index: 200;
    pointer-events: none; /* Wrapper is non-interactive */
}

.menu-screen {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    background-color: hsla(230, 10%, 8%, 0.7);
    backdrop-filter: blur(10px);
    color: var(--color-text-light);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    pointer-events: auto; /* Individual screens are interactive */
    animation: menu-fade-in 0.5s ease-out;
}

@keyframes menu-fade-in {
    from { opacity: 0; transform: scale(0.98); }
    to { opacity: 1; transform: scale(1); }
}

.menu-screen h1, .menu-screen h2 {
    margin: 0 0 50px 0;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
}

.menu-screen h1 {
    font-size: 6rem;
    color: var(--color-accent);
    text-shadow: 0 0 20px hsla(190, 100%, 50%, 0.5), 0 0 40px hsla(190, 100%, 50%, 0.3);
}

.menu-screen h2 {
    font-size: 4rem;
    color: var(--color-text-light);
    text-shadow: 0 0 10px hsla(0, 0%, 100%, 0.2);
}

.menu-options {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-top: 20px;
}

.menu-screen button {
    padding: 14px 30px;
    font-size: 1.2rem;
    font-weight: 600;
    font-family: inherit;
    background-color: var(--color-bg-mid);
    color: var(--color-text-light);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-sm);
    min-width: 300px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
}

.menu-screen button:not(:disabled):hover {
    background-color: var(--color-accent);
    border-color: var(--color-accent-hover);
    color: var(--color-accent-text);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px hsla(190, 100%, 50%, 0.2);
}

.menu-screen button:disabled {
    background-color: var(--color-bg-light);
    color: var(--color-text-dark);
    cursor: not-allowed;
}

/* --- LEVEL SELECT SPECIFICS --- */
#level-list {
    width: 90%;
    max-width: 450px;
    max-height: 50vh;
    overflow-y: auto;
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md);
    padding: 10px;
    background-color: var(--color-bg-dark);
    margin-bottom: 20px;
}

#level-list button {
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 10px;
}
#level-list button:last-child {
    margin-bottom: 0;
}

.back-button {
    margin-top: 20px;
    background-color: var(--color-bg-light) !important;
}

.back-button:hover {
    background-color: var(--color-text-dark) !important;
    border-color: var(--color-text-dark) !important;
    color: var(--color-text-light) !important;
    box-shadow: none !important;
}
--------------------------------------------------
=== END OF FILE: css/menu.css ===


=== FILE: data/abilities.json ===
--------------------------------------------------
{
    "WEAPON_001": {
        "id": "WEAPON_001",
        "name": "Katana",
        "type": "Weapon",
        "element": "Utility",
        "tier": 3,
        "description": "A sharp, reliable blade for close-quarters combat. Does not consume energy.",
        "flavor": "An elegant weapon for a more civilized age. A very, very close-range age."
    },
    "WEAPON_REVOLVER": {
        "id": "WEAPON_REVOLVER",
        "name": "Revolver",
        "type": "Weapon",
        "element": "Fire",
        "tier": 2,
        "description": "A powerful handgun with 6 rounds. Press [R] to reload.",
        "flavor": "Six shots. More than enough to kill anything that moves."
    },
    "WEAPON_SAI": {
        "id": "WEAPON_SAI",
        "name": "Twin Sai",
        "type": "Weapon",
        "element": "Utility",
        "tier": 2,
        "description": "Dual-wielded melee weapons. Deals 150 damage and causes bleeding on enemies below 50% HP.",
        "flavor": "Lethal in pairs, silent in the shadows."
    },
    "FIRE_001": {
        "id": "FIRE_001",
        "name": "Fireball",
        "type": "Ability",
        "element": "Fire",
        "tier": 1,
        "energyCost": 125,
        "cooldown": 0.8,
        "description": "Launch a sphere of raw flame that explodes on impact, leaving a burning area.",
        "flavor": "Simple, effective, and very, very hot."
    },
    "FIRE_002": {
        "id": "FIRE_002",
        "name": "Fireflies",
        "type": "Ability",
        "element": "Fire",
        "tier": 2,
        "energyCost": 250,
        "cooldown": 12.0,
        "description": "Release a swarm of homing cinders that seek out a locked-on target.",
        "flavor": "Why aim when they can do it for you?"
    },
    "EARTH_001": {
        "id": "EARTH_001",
        "name": "Stone Plating",
        "type": "Ability",
        "element": "Earth",
        "tier": 2,
        "energyCost": 400,
        "cooldown": 25.0,
        "description": "Hit hard and absorb damage at the cost of slower movement",
        "flavor": "Patience is a virtue. So is being made of rock."
    },
    "WATER_001": {
        "id": "WATER_001",
        "name": "Wave Power",
        "type": "Ability",
        "element": "Water",
        "tier": 2,
        "energyCost": 350,
        "cooldown": 10.0,
        "description": "When used on the ground, release a forceful wave in front of you that knocks enemies back.",
        "flavor": "Get out of the way."
    },
    "UTILITY_001": {
        "id": "UTILITY_001",
        "name": "Second Chance",
        "type": "Ability",
        "element": "Utility",
        "tier": 1,
        "castType": "channel",
        "energyCost": 0,
        "cooldown": 18.0,
        "description": "Hold to channel your power, converting 2 Energy into 1 Health per tick. Cooldown begins on release.",
        "flavor": "Sometimes, willpower is the best medicine."
    }
}
--------------------------------------------------
=== END OF FILE: data/abilities.json ===


=== FILE: data/player-profile.json ===
--------------------------------------------------
{
  "inventory": [
    "WEAPON_001",
    "WEAPON_REVOLVER",
    "WEAPON_SAI",
    "FIRE_001",
    "FIRE_002",
    "EARTH_001",
    "WATER_001",
    "UTILITY_001"
  ],
  "savedLoadouts": {
    "My First Build": {
      "name": "My First Build",
      "weapon": "WEAPON_001",
      "cards": [
        "FIRE_001",
        "FIRE_002",
        "EARTH_001",
        "WATER_001"
      ]
    },
    "Gunslinger": {
      "name": "Gunslinger",
      "weapon": "WEAPON_REVOLVER",
      "cards": [
        "FIRE_001",
        "UTILITY_001",
        null,
        null
      ]
    }
  },
  "activeLoadoutName": "My First Build"
}
--------------------------------------------------
=== END OF FILE: data/player-profile.json ===


=== FILE: levels/level-stadium.json ===
--------------------------------------------------
{
  "name": "Corrupt Arena",
  "spawnPoint": {
    "x": 0,
    "y": 3,
    "z": -20
  },
  "deathSpawnPoint": {
    "x": 0,
    "y": 3,
    "z": 0
  },
  "settings": {
    "backgroundColor": "0x302010",
    "skybox": "./assets/skyboxes/moody-skybox/",
    "fogColor": "0x403020",
    "fogNear": 50,
    "fogFar": 250,
    "ambientLight": {
      "color": "0xA08070",
      "intensity": 0.9
    },
    "directionalLights": [
      {
        "color": "0xFFC080",
        "intensity": 1.8,
        "position": {
          "x": 0,
          "y": 100,
          "z": 0
        },
        "targetPosition": {
          "x": 0,
          "y": 0,
          "z": 0
        }
      }
    ]
  },
  "objects": [
    {
      "type": "Plane",
      "name": "Ground Plane",
      "size": [
        250,
        250
      ],
      "position": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "rotation": {
        "x": -90,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x334455"
      },
      "physics": {
        "mass": 0
      },
      "editorSelectable": false
    },
    {
      "type": "Box",
      "name": "Arena_Playfield",
      "size": [
        110,
        1,
        70
      ],
      "position": {
        "x": 0,
        "y": 0.5,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x4CAF50"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier1_Z_Positive",
      "size": [
        130,
        2,
        20
      ],
      "position": {
        "x": 0,
        "y": 8,
        "z": 45
      },
      "rotation": {
        "x": -29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x607D8B"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier1_Z_Negative",
      "size": [
        130,
        2,
        20
      ],
      "position": {
        "x": 0,
        "y": 8,
        "z": -45
      },
      "rotation": {
        "x": 29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x607D8B"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier1_X_Positive",
      "size": [
        20,
        2,
        70
      ],
      "position": {
        "x": 65,
        "y": 8,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 29.999999999999993
      },
      "material": {
        "color": "0x607D8B"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier1_X_Negative",
      "size": [
        20,
        2,
        70
      ],
      "position": {
        "x": -65,
        "y": 8,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": -29.999999999999993
      },
      "material": {
        "color": "0x607D8B"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier2_Z_Positive",
      "size": [
        150,
        2,
        20
      ],
      "position": {
        "x": 0,
        "y": 18,
        "z": 55
      },
      "rotation": {
        "x": -29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x455A64"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier2_Z_Negative",
      "size": [
        150,
        2,
        20
      ],
      "position": {
        "x": 0,
        "y": 18,
        "z": -55
      },
      "rotation": {
        "x": 29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x455A64"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier2_X_Positive",
      "size": [
        20,
        2,
        70
      ],
      "position": {
        "x": 75,
        "y": 18,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 29.999999999999993
      },
      "material": {
        "color": "0x455A64"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier2_X_Negative",
      "size": [
        20,
        2,
        70
      ],
      "position": {
        "x": -75,
        "y": 18,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": -29.999999999999993
      },
      "material": {
        "color": "0x455A64"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "OuterWall_Z_Positive",
      "size": [
        190,
        64,
        4
      ],
      "position": {
        "x": 0,
        "y": 32,
        "z": 80
      },
      "rotation": {
        "x": 45.00000000000001,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x263238"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "OuterWall_Z_Negative",
      "size": [
        190,
        64,
        4
      ],
      "position": {
        "x": 0,
        "y": 32,
        "z": -80
      },
      "rotation": {
        "x": -45.00000000000001,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x263238"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "OuterWall_X_Positive",
      "size": [
        4,
        64,
        160
      ],
      "position": {
        "x": 95,
        "y": 32,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": -45.00000000000001
      },
      "material": {
        "color": "0x263238"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "OuterWall_X_Negative",
      "size": [
        4,
        64,
        160
      ],
      "position": {
        "x": -95,
        "y": 32,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 45.00000000000001
      },
      "material": {
        "color": "0x263238"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Roof",
      "size": [
        192,
        4,
        162
      ],
      "position": {
        "x": 0,
        "y": 50,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x1A2228"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Divider_Z_Positive",
      "size": [
        2,
        25,
        20
      ],
      "position": {
        "x": 0,
        "y": 18,
        "z": 55
      },
      "rotation": {
        "x": -29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x37474F"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Divider_Z_Negative",
      "size": [
        2,
        25,
        20
      ],
      "position": {
        "x": 0,
        "y": 18,
        "z": -55
      },
      "rotation": {
        "x": 29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x37474F"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Divider_X_Positive",
      "size": [
        20,
        25,
        2
      ],
      "position": {
        "x": 75,
        "y": 18,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 29.999999999999993
      },
      "material": {
        "color": "0x37474F"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Divider_X_Negative",
      "size": [
        20,
        25,
        2
      ],
      "position": {
        "x": -75,
        "y": 18,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": -29.999999999999993
      },
      "material": {
        "color": "0x37474F"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Center_Cover",
      "size": [
        20,
        4,
        20
      ],
      "position": {
        "x": 0,
        "y": 2,
        "z": 0
      },
      "material": {
        "color": "0x546E7A"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Corner_Cover_PZ_PX",
      "size": [
        8,
        3,
        8
      ],
      "position": {
        "x": 40,
        "y": 1.5,
        "z": 25
      },
      "material": {
        "color": "0x546E7A"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Corner_Cover_PZ_NX",
      "size": [
        8,
        3,
        8
      ],
      "position": {
        "x": -40,
        "y": 1.5,
        "z": 25
      },
      "material": {
        "color": "0x546E7A"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Corner_Cover_NZ_PX",
      "size": [
        8,
        3,
        8
      ],
      "position": {
        "x": 40,
        "y": 1.5,
        "z": -25
      },
      "material": {
        "color": "0x546E7A"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Corner_Cover_NZ_NX",
      "size": [
        8,
        3,
        8
      ],
      "position": {
        "x": -40,
        "y": 1.5,
        "z": -25
      },
      "material": {
        "color": "0x546E7A"
      },
      "physics": {
        "mass": 0
      }
    }
  ],
  "npcs": [
    {
      "type": "NPC",
      "team": "enemy",
      "attackType": "ranged",
      "position": { "x": 20, "y": 3, "z": 0 }
    },
    {
      "type": "NPC",
      "team": "enemy",
      "attackType": "ranged",
      "position": { "x": -20, "y": 3, "z": 0 }
    },
    {
      "type": "NPC",
      "team": "enemy",
      "attackType": "ranged",
      "position": { "x": 50, "y": 12, "z": 25 }
    },
    {
      "type": "NPC",
      "team": "enemy",
      "attackType": "ranged",
      "position": { "x": -50, "y": 12, "z": 25 }
    },
    {
      "type": "NPC",
      "team": "enemy",
      "attackType": "ranged",
      "position": { "x": 50, "y": 12, "z": -25 }
    },
    {
      "type": "NPC",
      "team": "enemy",
      "attackType": "ranged",
      "position": { "x": -50, "y": 12, "z": -25 }
    },
    {
      "type": "NPC",
      "team": "enemy",
      "attackType": "melee",
      "position": { "x": 10, "y": 3, "z": 10 }
    },
    {
      "type": "NPC",
      "team": "enemy",
      "attackType": "melee",
      "position": { "x": -10, "y": 3, "z": 10 }
    },
    {
      "type": "NPC",
      "team": "player",
      "attackType": "ranged",
      "position": { "x": -10, "y": 3, "z": -20 }
    },
    {
      "type": "NPC",
      "team": "player",
      "attackType": "melee",
      "position": { "x": 10, "y": 3, "z": -20 }
    }
  ],
  "triggers": [],
  "deathTriggers": []
}
--------------------------------------------------
=== END OF FILE: levels/level-stadium.json ===


=== FILE: levels/level-tutorial.json ===
--------------------------------------------------
{
    "name": "Tutorial",
    "spawnPoint": { "x": 0, "y": 2, "z": 0 },
    "deathSpawnPoint": { "x": 0, "y": 2, "z": 0 },
    "settings": {
        "backgroundColor": "0x302010",
        "skybox": "./assets/skyboxes/moody-skybox/",
        "fogColor": "0x403020",
        "fogNear": 30,
        "fogFar": 200,
        "ambientLight": {
            "color": "0xA08070",
            "intensity": 0.9
        },
        "directionalLights": [
            {
                "color": "0xFFC080",
                "intensity": 6.0,
                "position": { "x": -150, "y": 80, "z": -50 },
                "targetPosition": { "x": 0, "y": 0, "z": 0 }
            }
        ]
    },
    "objects": [
        { "type": "Box", "name": "Start_Platform", "size": [10, 2, 10], "position": { "x": 0, "y": 0, "z": 0 }, "material": {"color": "0x445566"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Jump_Platform_1", "size": [6, 2, 6], "position": { "x": 0, "y": 0, "z": 15 }, "material": {"color": "0x445566"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Jump_Platform_2", "size": [6, 2, 6], "position": { "x": 0, "y": 4, "z": 30 }, "material": {"color": "0x445566"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Dash_Platform_1", "size": [6, 2, 6], "position": { "x": 0, "y": 4, "z": 50 }, "material": {"color": "0x445566"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Slam_Tower_Base", "size": [8, 10, 8], "position": { "x": 20, "y": 5, "z": 50 }, "material": {"color": "0x5A5A5A"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Slam_Tower_Ledge", "size": [4, 2, 4], "position": { "x": 20, "y": 12, "z": 45 }, "material": {"color": "0x555555"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Slam_Tower_Top", "size": [8, 2, 8], "position": { "x": 20, "y": 18, "z": 50 }, "material": {"color": "0x445566"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Arena_Platform", "size": [30, 2, 30], "position": { "x": 20, "y": -2, "z": 80 }, "material": {"color": "0x455A64"}, "physics": {"mass": 0}}
    ],
    "npcs": [
        { "type": "NPC", "team": "enemy", "attackType": "ranged", "position": { "x": 15, "y": 1, "z": 85 }},
        { "type": "NPC", "team": "enemy", "attackType": "ranged", "position": { "x": 25, "y": 1, "z": 85 }},
        { "type": "NPC", "team": "enemy", "attackType": "melee", "position": { "x": 20, "y": 1, "z": 95 }},
        { "type": "NPC", "team": "player", "attackType": "melee", "position": { "x": 20, "y": 1, "z": 75 }}
    ],
    "triggers": [
        { "type": "Trigger", "name": "Move_Tuto", "position": {"x": 0, "y": 3, "z": 2}, "size": [10, 5, 4], "message": "Use <kbd>WASD</kbd> to move and your <kbd>Mouse</kbd> to look around.", "duration": 8, "color": "0x2ed573"},
        { "type": "Trigger", "name": "Jump_Tuto", "position": {"x": 0, "y": 3, "z": 10}, "size": [8, 5, 4], "message": "Press <kbd>Space</kbd> to jump across the gap.", "duration": 6, "color": "0x2ed573"},
        { "type": "Trigger", "name": "DoubleJump_Tuto", "position": {"x": 0, "y": 3, "z": 22}, "size": [8, 5, 4], "message": "This gap is higher. Press <kbd>Space</kbd> again in mid-air to double jump.", "duration": 8, "color": "0x2ed573"},
        { "type": "Trigger", "name": "Dash_Tuto", "position": {"x": 0, "y": 7, "z": 40}, "size": [8, 5, 4], "message": "Double-tap a movement key (<kbd>W</kbd>,<kbd>A</kbd>,<kbd>S</kbd>, or <kbd>D</kbd>) to dash.", "duration": 8, "color": "0x2ed573"},
        { "type": "Trigger", "name": "Slam_Tuto", "position": {"x": 20, "y": 15, "z": 50}, "size": [10, 10, 10], "message": "Get to the top of the tower, then jump and hold <kbd>L-Shift</kbd> in mid-air to ground slam onto the arena below.", "duration": 10, "color": "0x2ed573"},
        { "type": "Trigger", "name": "Combat_Tuto", "position": {"x": 20, "y": 2, "z": 70}, "size": [30, 8, 4], "message": "Destroy the enemies to complete the tutorial. An ally will help you. <kbd>LMB</kbd> to attack, <kbd>RMB</kbd> to use abilities. <kbd>1-4</kbd> to select abilities.", "duration": 12, "color": "0xff4757"}
    ],
    "deathTriggers": [
        { "type": "DeathTrigger", "name": "Death_Zone", "position": { "x": 10, "y": -15, "z": 50 }, "size": [100, 2, 120] }
    ]
}
--------------------------------------------------
=== END OF FILE: levels/level-tutorial.json ===


=== FILE: levels/level-waterfall.json ===
--------------------------------------------------
{
  "name": "New Level",
  "spawnPoint": {
    "x": 78.31545656791558,
    "y": 25.301396566818845,
    "z": -24.543979533999458
  },
  "deathSpawnPoint": {
    "x": 78.31545656791558,
    "y": 25.301396566818845,
    "z": -24.543979533999458
  },
  "settings": {
    "backgroundColor": "0x1d2938",
    "fogColor": "0x1d2938",
    "fogNear": 20,
    "fogFar": 150,
    "ambientLight": {
      "color": "0x607080",
      "intensity": 0.7
    },
    "directionalLights": [
      {
        "color": "0xffffff",
        "intensity": 3,
        "position": {
          "x": -57.750323630867584,
          "y": 63.78569880242395,
          "z": 55.114990773152876
        },
        "targetPosition": {
          "x": 28.394169670440604,
          "y": 35.866581210362526,
          "z": 42.44547243913128
        }
      }
    ],
    "skybox": "./assets/skyboxes/moody-skybox/"
  },
  "objects": [
    {
      "type": "Plane",
      "name": "Ground Plane",
      "size": [
        200,
        200
      ],
      "position": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x525634",
        "roughness": 0.9
      },
      "physics": {
        "mass": 0
      },
      "editorSelectable": false,
      "quaternion": {
        "x": -0.7071067811865475,
        "y": 0,
        "z": 0,
        "w": 0.7071067811865476
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577",
      "size": [
        14,
        150.84569296324426,
        16
      ],
      "position": {
        "x": 46,
        "y": -3,
        "z": -53
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769",
      "size": [
        14,
        20,
        16
      ],
      "position": {
        "x": 57,
        "y": 16,
        "z": -40
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_350",
      "size": [
        14,
        45.749378916712764,
        16
      ],
      "position": {
        "x": 44.65554033535191,
        "y": 65.40990879210926,
        "z": -82.12680881887539
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.7563694814674462,
        "y": -1.7867651802561113e-16,
        "z": -0.00267944152074601,
        "w": 0.6541391504089964
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_428",
      "size": [
        49.48032966960089,
        11.674678541517498,
        62.889150973856914
      ],
      "position": {
        "x": 76.95789282318496,
        "y": 6.364755597355968,
        "z": -27.5090715007741
      },
      "material": {
        "color": "0xd3ca92"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.030865062830827877,
        "y": -0.6499646297228505,
        "z": -0.036018292704592864,
        "w": 0.7584827028985783
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_381",
      "size": [
        7.426890383308172,
        72.06809571106996,
        16
      ],
      "position": {
        "x": 99.14717987387269,
        "y": 46.47065808709171,
        "z": 6.4295198370767395
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_381_copy_994",
      "size": [
        7.426890383308172,
        66.24326612594561,
        16
      ],
      "position": {
        "x": 95.33383259624387,
        "y": 41.802648346446425,
        "z": -9.971379471542834
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_381_copy_738",
      "size": [
        7.426890383308172,
        72.06809571106996,
        16
      ],
      "position": {
        "x": 101.87790560022253,
        "y": 42.62758341177992,
        "z": -26.09061460714136
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_381_copy_994_copy_928",
      "size": [
        32.73465419983477,
        25.334114451794875,
        20.951628393983736
      ],
      "position": {
        "x": 66.09913056431634,
        "y": 5.416984045159602,
        "z": -49.77345803072737
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_311",
      "size": [
        44.57006083349483,
        34.741574028785514,
        16
      ],
      "position": {
        "x": 73.14109141086027,
        "y": 13.608302881122736,
        "z": -63.107435586722865
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_350_copy_613",
      "size": [
        14,
        20.524362572744913,
        32.61208623605824
      ],
      "position": {
        "x": 49.521192985344676,
        "y": 74.02217132583868,
        "z": -100.5835550587672
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.5087229773061518,
        "y": 1.10550916332516e-9,
        "z": 0.00028953449475195277,
        "w": 0.8609302228000483
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_381_copy_738_copy_758",
      "size": [
        7.426890383308172,
        105.08573804251523,
        28.0780571686081
      ],
      "position": {
        "x": 95.18769422568211,
        "y": 59.25036637399147,
        "z": -45.19373652017691
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0.2945956559600281,
        "z": 0,
        "w": 0.9556219961310438
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_381_copy_994_copy_590",
      "size": [
        19.43332874605406,
        24.953201397407568,
        16
      ],
      "position": {
        "x": 95.16090664051714,
        "y": 21.630627836185596,
        "z": -43.2709459389058
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_311_copy_919",
      "size": [
        44.57006083349483,
        52.03343760887548,
        16
      ],
      "position": {
        "x": 63.05675765394652,
        "y": 38.82984827285034,
        "z": -70.35366856400114
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0.29864401169683863,
        "z": 0,
        "w": 0.9543645814245301
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_381_copy_738_copy_758_copy_407",
      "size": [
        7.426890383308172,
        105.08573804251523,
        28.0780571686081
      ],
      "position": {
        "x": 84.40962253528751,
        "y": 9.226012961522109,
        "z": -65.03334638276034
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0.2945956559600281,
        "z": 0,
        "w": 0.9556219961310438
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_381_copy_738_copy_758_copy_407_copy_188",
      "size": [
        7.426890383308172,
        105.08573804251523,
        28.0780571686081
      ],
      "position": {
        "x": 93.60058171040004,
        "y": 40.409060449840645,
        "z": -69.4462809315035
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": -0.054713948208991565,
        "z": 0,
        "w": 0.9985020700386072
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_350_copy_613_copy_520",
      "size": [
        14,
        14.657557892507871,
        16
      ],
      "position": {
        "x": 55.48445948191036,
        "y": 65.33896895622624,
        "z": -79.80271236808633
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.5087229773061513,
        "y": 1.1055092674627787e-9,
        "z": 0.19910674637658543,
        "w": 0.8375902553803353
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_350_copy_613_copy_520_copy_927",
      "size": [
        14,
        14.657557892507871,
        16
      ],
      "position": {
        "x": 89.09510589325537,
        "y": 57.92897065059704,
        "z": -75.17162722298576
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.5087229773061513,
        "y": 1.1055091286849006e-9,
        "z": 0.6152081473207809,
        "w": 0.6022622915565088
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_350_copy_613_copy_520_copy_997",
      "size": [
        14,
        14.657557892507871,
        16
      ],
      "position": {
        "x": 66.56803751127126,
        "y": 62.001883728191714,
        "z": -90.80653237615158
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.5087229773061518,
        "y": 1.105509100929325e-9,
        "z": 0.8597229505490573,
        "w": 0.045578291543102445
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_381_copy_738_copy_758_copy_407_copy_188_copy_775",
      "size": [
        7.426890383308172,
        105.08573804251523,
        46.29807096951087
      ],
      "position": {
        "x": 72.49548431567482,
        "y": 50.924132435614524,
        "z": -96.53175547099094
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0.5767643086991326,
        "z": 0,
        "w": 0.8169106023371294
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_350_copy_613_copy_163",
      "size": [
        33.07530798916817,
        58.728472395182365,
        35.61308916348624
      ],
      "position": {
        "x": 22.940443484103024,
        "y": 74.91647575166616,
        "z": -108.75007775800142
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.861959508769854,
        "y": -0.4831501304625283,
        "z": -0.13303734347668425,
        "w": 0.07676471791090249
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_350_copy_613_copy_163_copy_996",
      "size": [
        33.07530798916817,
        44.48291667822448,
        35.61308916348624
      ],
      "position": {
        "x": -7.245136953313015,
        "y": 85.88118562647216,
        "z": -117.66071701351335
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.8577049526461484,
        "y": 0.4820493437224116,
        "z": -0.1565347913765257,
        "w": 0.08641471814319616
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_350_copy_613_copy_163_copy_996_copy_303",
      "size": [
        33.07530798916817,
        44.48291667822448,
        35.61308916348624
      ],
      "position": {
        "x": -52.430422611583516,
        "y": 76.12025799515337,
        "z": -110.64093494421631
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.24265500619266797,
        "y": 0.24338392847294174,
        "z": 0.6585832213167641,
        "w": 0.669440775521441
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_350_copy_613_copy_163_copy_996_copy_303_copy_698",
      "size": [
        33.07530798916817,
        44.48291667822448,
        35.61308916348624
      ],
      "position": {
        "x": -108,
        "y": 53,
        "z": -63
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.5721714626874537,
        "y": 0.6204949116955089,
        "z": 0.3635506406502199,
        "w": 0.3942547571417461
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_350_copy_613_copy_163_copy_996_copy_303_copy_698_copy_713",
      "size": [
        33.07530798916817,
        44.48291667822448,
        35.61308916348624
      ],
      "position": {
        "x": -104,
        "y": 55,
        "z": -102
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.3161615395109762,
        "y": 0.4414713204837671,
        "z": -0.4889269280040274,
        "w": 0.6827118083034108
      }
    },
    {
      "type": "Box",
      "name": "Box_1751850879121",
      "size": [
        12,
        6,
        24
      ],
      "position": {
        "x": -89,
        "y": 71,
        "z": -68
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.5624222244434793,
        "y": 0.3036031793409594,
        "z": -0.676783131082773,
        "w": 0.36533675482752603
      }
    },
    {
      "type": "Box",
      "name": "Box_1751850879121_copy_692",
      "size": [
        12,
        12,
        48
      ],
      "position": {
        "x": -85,
        "y": 72,
        "z": -80
      },
      "material": {
        "color": "0x6a4c2a"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.2151937419510249,
        "y": 0.20348193344072182,
        "z": -0.6940461283943042,
        "w": 0.6561910757159216
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851004594",
      "size": [
        156.91943442139822,
        60,
        2
      ],
      "position": {
        "x": -21.877955136664006,
        "y": 29,
        "z": -60
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851053529",
      "size": [
        126,
        2,
        36
      ],
      "position": {
        "x": -26,
        "y": 63.58988369863561,
        "z": -76
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.13052619222005157,
        "y": 0,
        "z": 0,
        "w": 0.9914448613738104
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851133379",
      "size": [
        24,
        32,
        32
      ],
      "position": {
        "x": -99,
        "y": 24,
        "z": -43
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": -0.2588190451025207,
        "z": 0,
        "w": 0.9659258262890683
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851188163",
      "size": [
        4,
        12,
        6
      ],
      "position": {
        "x": -93,
        "y": 14,
        "z": -29
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851188163_copy_518",
      "size": [
        12,
        12,
        12
      ],
      "position": {
        "x": -96,
        "y": 44,
        "z": -45
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851441000",
      "size": [
        2,
        2,
        2
      ],
      "position": {
        "x": 64.73147974134633,
        "y": 21.33524661206111,
        "z": -34.78615639372975
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851441000_copy_471",
      "size": [
        5.127246124899222,
        2,
        9.338540567905756
      ],
      "position": {
        "x": 52.93047534956148,
        "y": 37.91311006325847,
        "z": -50.102994125545955
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.33283676104842297,
        "y": 0,
        "z": 0,
        "w": 0.9429844593071484
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851441000_copy_471_copy_978",
      "size": [
        5.127246124899222,
        2,
        9.338540567905756
      ],
      "position": {
        "x": 59.201829874887224,
        "y": 44.93311555995761,
        "z": -56.17092392386403
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.33283676104842297,
        "y": 0,
        "z": 0,
        "w": 0.9429844593071484
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851441000_copy_471_copy_978_copy_388",
      "size": [
        5.127246124899222,
        2,
        9.338540567905756
      ],
      "position": {
        "x": 68.62901023390239,
        "y": 47.951404830673305,
        "z": -61.48223604137541
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.3101123596592775,
        "y": 0.34245836401011,
        "z": -0.5952822703862394,
        "w": 0.657412816934594
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_350_copy_613_copy_520_copy_927_copy_508",
      "size": [
        14,
        14.657557892507871,
        16
      ],
      "position": {
        "x": 86.00903895449446,
        "y": 48.785946710166634,
        "z": -68.64156111991316
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.508722977306152,
        "y": 1.105509036527716e-9,
        "z": 0.8609267232965542,
        "w": 0.0024717351441808154
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851133379_copy_338",
      "size": [
        24,
        32,
        25.252757712545034
      ],
      "position": {
        "x": -106.87225824281141,
        "y": 20.459775691036185,
        "z": -21.24788745613182
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.3425767213751029,
        "y": -0.6866761974533543,
        "z": 0.2862371827133699,
        "w": 0.573746690670369
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851133379_copy_338_copy_353",
      "size": [
        24,
        32,
        25.252757712545034
      ],
      "position": {
        "x": -107.62591628766816,
        "y": 15.850493336341465,
        "z": 1.7552712918264213
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.2378130637701274,
        "y": -0.7296080844380627,
        "z": 0.19870276390402739,
        "w": 0.6096180783406825
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851133379_copy_338_copy_353_copy_320",
      "size": [
        24,
        32,
        25.252757712545034
      ],
      "position": {
        "x": -110.1546666209501,
        "y": 15.214992591447817,
        "z": 26.085439173988206
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.20377274079759153,
        "y": -0.6915003637016277,
        "z": -0.19589774166642204,
        "w": 0.6647766481445854
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851133379_copy_338_copy_353_copy_320_copy_639",
      "size": [
        48.759254698121026,
        68.8430225053071,
        14.62695170331216
      ],
      "position": {
        "x": -99.41695839692046,
        "y": -6.0481755732977724,
        "z": 63.93067565274836
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.15838602784269035,
        "y": 0.5374811088018825,
        "z": -0.2341220141195986,
        "w": 0.7944902808530109
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851133379_copy_338_copy_353_copy_320_copy_639_copy_556",
      "size": [
        48.759254698121026,
        68.8430225053071,
        14.62695170331216
      ],
      "position": {
        "x": -105.95295710498362,
        "y": 8.749105517194373,
        "z": 87.54371579543289
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.08093151698072429,
        "y": -0.27464014393343517,
        "z": -0.2708308344162229,
        "w": 0.919061227573459
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_381_copy_996",
      "size": [
        7.426890383308172,
        66.45564792287985,
        63.83639456757249
      ],
      "position": {
        "x": 102.74718825800316,
        "y": 22.895209071405027,
        "z": 38.02647670167605
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.13176662110792284,
        "y": 0,
        "z": 0,
        "w": 0.9912807662624152
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_381_copy_996_copy_320",
      "size": [
        7.426890383308172,
        66.45564792287985,
        63.83639456757249
      ],
      "position": {
        "x": 75.91777444353986,
        "y": 29.16453076047876,
        "z": 98.4697841469163
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.0901022362277215,
        "y": -0.6026388380758732,
        "z": -0.11724714700520031,
        "w": 0.7841945704915754
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_741",
      "size": [
        14,
        20,
        16
      ],
      "position": {
        "x": 97.6533958279006,
        "y": 14.56276645999925,
        "z": 76.74218502839379
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_741_copy_415",
      "size": [
        14,
        20,
        16
      ],
      "position": {
        "x": 99.61513942107027,
        "y": 27.970640772512674,
        "z": 90.44763827906785
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_741_copy_415_copy_684",
      "size": [
        14,
        32.90142646104477,
        25.53855611427971
      ],
      "position": {
        "x": 104.90954072877058,
        "y": 37.217918242155775,
        "z": 79.63151800681264
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0.1010813745835569,
        "w": 0.9948781612400076
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851133379_copy_338_copy_353_copy_320_copy_639_copy_556_copy_837",
      "size": [
        48.759254698121026,
        68.8430225053071,
        14.62695170331216
      ],
      "position": {
        "x": -47.45208241935228,
        "y": 26.911519426701524,
        "z": 95.0503816369429
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.048589739830116316,
        "y": 0.1648887063838468,
        "z": -0.2784569778163475,
        "w": 0.9449404548413033
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_741_copy_586",
      "size": [
        41.053739388013184,
        20,
        16
      ],
      "position": {
        "x": 30.193187022495092,
        "y": 11.827106045351819,
        "z": 98.58024964348049
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_741_copy_586_copy_390",
      "size": [
        41.053739388013184,
        20,
        16
      ],
      "position": {
        "x": 15.70491983686684,
        "y": 26.972067302874507,
        "z": 112.06285281708546
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": -0.15724817572743743,
        "z": 0,
        "w": 0.9875591178407462
      }
    },
    {
      "type": "Box",
      "name": "Box_1751851133379_copy_338_copy_353_copy_320_copy_639_copy_556_copy_837_copy_616",
      "size": [
        48.759254698121026,
        68.8430225053071,
        14.62695170331216
      ],
      "position": {
        "x": -15.974791020373312,
        "y": 34.81176621909163,
        "z": 111.20743834425755
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.06826366372119816,
        "y": -0.2316519339959983,
        "z": -0.27429787371895875,
        "w": 0.9308265843671049
      }
    },
    {
      "type": "Box",
      "name": "Box_1751849158577_copy_769_copy_741_copy_586_copy_390_copy_851",
      "size": [
        41.053739388013184,
        20,
        16
      ],
      "position": {
        "x": 31.540130273282063,
        "y": 42.93780279536036,
        "z": 123.74010805467822
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0.23275815301491712,
        "z": 0,
        "w": 0.9725346483314024
      }
    },
    {
      "type": "Box",
      "name": "Box_1751852919267",
      "size": [
        14.588436086194646,
        13.579247182260303,
        9.290122875481464
      ],
      "position": {
        "x": 42.32855373868895,
        "y": 26.752521549425786,
        "z": 108.18671879835095
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751852969047",
      "size": [
        15,
        2,
        2
      ],
      "position": {
        "x": 18.02259070999368,
        "y": 10.896985690197845,
        "z": 4.071404139913404
      },
      "material": {
        "color": "0x4a360d"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751852969047_copy_779",
      "size": [
        15,
        2,
        2
      ],
      "position": {
        "x": 8.167281172759477,
        "y": 8.83917179813707,
        "z": 47.51287415780578
      },
      "material": {
        "color": "0x4a360d"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.0301811416924442,
        "y": 0.33386331025978844,
        "z": -0.08541310152222671,
        "w": 0.9382584882839434
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853037947",
      "size": [
        16.947275359853652,
        22.270491197070758,
        6.772615749272733
      ],
      "position": {
        "x": -0.44014039112735226,
        "y": 13.710282920298589,
        "z": 104.24026283176404
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": -0.3904224657577357,
        "w": 0.9206358119428386
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853094851",
      "size": [
        17.025764517783706,
        2,
        2
      ],
      "position": {
        "x": 83.80146292402996,
        "y": 27.14402102259502,
        "z": 71.27933434377137
      },
      "material": {
        "color": "0x563815"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": -0.24595623647711531,
        "w": 0.9692809343724931
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853094851_copy_337",
      "size": [
        17.025764517783706,
        2,
        2
      ],
      "position": {
        "x": 72.98305873134068,
        "y": 36.83063867449553,
        "z": 69.44690124835651
      },
      "material": {
        "color": "0x563815"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.09532572947307108,
        "y": -0.16738749191735255,
        "z": -0.48560140901442134,
        "w": 0.852693206501174
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853158733",
      "size": [
        11.060623622690933,
        1.123303874319657,
        15.70473968746348
      ],
      "position": {
        "x": 66.88758022338456,
        "y": 40.706929044312034,
        "z": 79.45791878705106
      },
      "material": {
        "color": "0x3a6e30"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853158733_copy_70",
      "size": [
        11.060623622690933,
        1.123303874319657,
        15.70473968746348
      ],
      "position": {
        "x": 72.33454946611398,
        "y": 44.415061610702,
        "z": 64.64880231849389
      },
      "material": {
        "color": "0x3a6e30"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853094851_copy_51",
      "size": [
        17.025764517783706,
        2,
        2
      ],
      "position": {
        "x": 70.74437340736473,
        "y": 35.5409828752305,
        "z": 76.99252505175632
      },
      "material": {
        "color": "0x563815"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.10365879880517978,
        "y": 0.4085055894533636,
        "z": -0.22304556416179627,
        "w": 0.8789930108501279
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853094851_copy_745",
      "size": [
        17.025764517783706,
        2,
        2
      ],
      "position": {
        "x": 91.60468867963706,
        "y": 13.193333327164158,
        "z": 50.411358755435685
      },
      "material": {
        "color": "0x563815"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.18921534499072235,
        "y": 0.7456726002037578,
        "z": -0.15713695772169142,
        "w": 0.6192559269343977
      }
    },
    {
      "type": "Box",
      "name": "Box_1751852969047_copy_118",
      "size": [
        15,
        2,
        2
      ],
      "position": {
        "x": -41.6945920818592,
        "y": 10.524220711791596,
        "z": -0.7548334848301224
      },
      "material": {
        "color": "0x4a360d"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0.15984487194576527,
        "w": 0.9871421462548552
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853158733_copy_72",
      "size": [
        11.060623622690933,
        1.123303874319657,
        15.70473968746348
      ],
      "position": {
        "x": -35.36766817723043,
        "y": 13.590334704887791,
        "z": -3.040455419992405
      },
      "material": {
        "color": "0x3a6e30"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751902972436_copy_416_copy_390_copy_142",
      "size": [
        11.813740485621498,
        8.579634048463047,
        6.176974009059231
      ],
      "position": {
        "x": -58.66833747117792,
        "y": 26.815032418090404,
        "z": 49.75164172131486
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": -0.2763849044740639,
        "z": 0,
        "w": 0.9610470251651907
      }
    },
    {
      "type": "Box",
      "name": "Box_1751902972436_copy_416_copy_390_copy_142_copy_779",
      "size": [
        5.032911285152845,
        37.55649026020293,
        5.5146784402409725
      ],
      "position": {
        "x": -54.797411225650265,
        "y": 8.266914924760282,
        "z": 53.16579049766363
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751902972436_copy_416_copy_390_copy_142_copy_779_copy_355",
      "size": [
        5.032911285152845,
        39.27877612428166,
        5.5146784402409725
      ],
      "position": {
        "x": -62.10810199835952,
        "y": 7.478559060646482,
        "z": 47.941194508358286
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751903269123",
      "size": [
        2,
        2,
        5.9781560466703185
      ],
      "position": {
        "x": -62.86751235475382,
        "y": 44.81563362541057,
        "z": 43.68285629494328
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.24771026559101988,
        "y": 0,
        "z": 0,
        "w": 0.9688341572843241
      }
    },
    {
      "type": "Box",
      "name": "Box_1751903269123_copy_901",
      "size": [
        2,
        2,
        5.9781560466703185
      ],
      "position": {
        "x": -52.88059761030137,
        "y": 44.70850258368087,
        "z": 51.217454033595935
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": -0.2879449256898477,
        "y": -0.5501682184071313,
        "z": 0.36324425668270305,
        "w": 0.6945907148898708
      }
    },
    {
      "type": "Box",
      "name": "Box_1751903597970",
      "size": [
        9.626575552953147,
        18.993790155298452,
        3.5449941423034943
      ],
      "position": {
        "x": -59.60578233991823,
        "y": 37.727750976519374,
        "z": 49.53365780679029
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": -0.3533913156771818,
        "z": 0,
        "w": 0.9354755892079443
      }
    },
    {
      "type": "Box",
      "name": "Box_1751903708553",
      "size": [
        3.996562377179412,
        4.645826635135241,
        4.285220420725681
      ],
      "position": {
        "x": -59.93290330885601,
        "y": 49.24751105477968,
        "z": 50.02072800937353
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": -0.3030665500695695,
        "z": 0,
        "w": 0.9529693941721996
      }
    },
    {
      "type": "Box",
      "name": "Box_1751904060209",
      "size": [
        8.376121451931061,
        2,
        2
      ],
      "position": {
        "x": -53.3756693028295,
        "y": 43.27926588506584,
        "z": 48.445936727617884
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": -0.3663928367185759,
        "z": 0,
        "w": 0.930460256647921
      }
    },
    {
      "type": "Box",
      "name": "Box_1751904060209_copy_259",
      "size": [
        8.376121451931061,
        2,
        2
      ],
      "position": {
        "x": -60.23067549609401,
        "y": 43.14627343513631,
        "z": 42.996683733555464
      },
      "material": {
        "color": "0xcccccc"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": -0.23845863705844605,
        "z": 0,
        "w": 0.9711526545359531
      }
    },
    {
      "type": "Box",
      "name": "Box_1751904267937",
      "size": [
        4.28328050119502,
        23.290360228032963,
        1.0722320419726226
      ],
      "position": {
        "x": -61.20484435532218,
        "y": 39.82530033247296,
        "z": 51.987652666575514
      },
      "material": {
        "color": "0x5c5c5c"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": -0.30729504336552926,
        "z": 0,
        "w": 0.9516142896798984
      }
    },
    {
      "type": "Box",
      "name": "Box_1751904475272",
      "size": [
        4.226710694441161,
        0.69369678896435,
        5.260309517624608
      ],
      "position": {
        "x": -59.9020125252128,
        "y": 51.70108498608498,
        "z": 49.98928834947113
      },
      "material": {
        "color": "0x383838"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": -0.32190014292468355,
        "z": 0,
        "w": 0.946773625522526
      }
    },
    {
      "type": "Box",
      "name": "Box_1751852969047_copy_505",
      "size": [
        15,
        2,
        2
      ],
      "position": {
        "x": -16.467295364637323,
        "y": 10.202317605758715,
        "z": 15.727945327451788
      },
      "material": {
        "color": "0x4a360d"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.1268474130342984,
        "y": 0.5156890739402777,
        "z": 0.2004383821710644,
        "w": 0.8232854716183028
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853094851_copy_745_copy_403",
      "size": [
        17.025764517783706,
        2,
        2
      ],
      "position": {
        "x": 97.84455513930261,
        "y": 22.4094109415763,
        "z": 56.31434023852501
      },
      "material": {
        "color": "0x563815"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.15438015754240372,
        "y": 0.8458313294649622,
        "z": 0.08213033338070272,
        "w": 0.5039749372652294
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853094851_copy_745_copy_403_copy_603",
      "size": [
        17.025764517783706,
        2,
        2
      ],
      "position": {
        "x": 89.69497864544137,
        "y": 31.08139683645426,
        "z": 46.81054226757902
      },
      "material": {
        "color": "0x563815"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0.3704098465503834,
        "y": 0.9026840866596579,
        "z": 0.16749095036375744,
        "w": 0.1410842543170071
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853158733_copy_70_copy_278",
      "size": [
        11.060623622690933,
        1.123303874319657,
        15.70473968746348
      ],
      "position": {
        "x": 83.01466837649397,
        "y": 37.91059814787482,
        "z": 43.74060427811049
      },
      "material": {
        "color": "0x3a6e30"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751905503988",
      "size": [
        5,
        20,
        5
      ],
      "position": {
        "x": -70.4831419248292,
        "y": 6.387238505765449,
        "z": -17.734840044105717
      },
      "material": {
        "color": "0x735121"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751905503988_copy_90",
      "size": [
        5,
        20,
        5
      ],
      "position": {
        "x": -69.36195035502641,
        "y": 17.91042558508134,
        "z": -18.43066388000493
      },
      "material": {
        "color": "0x735121"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Box",
      "name": "Box_1751853158733_copy_72_copy_71",
      "size": [
        11.060623622690933,
        1.123303874319657,
        15.70473968746348
      ],
      "position": {
        "x": -69.35299861451172,
        "y": 28.467242371662554,
        "z": -19.172086980360117
      },
      "material": {
        "color": "0x3a6e30"
      },
      "physics": {
        "mass": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Water",
      "name": "WaterVolume_1751849041383",
      "size": [
        200,
        10,
        200
      ],
      "position": {
        "x": 0,
        "y": 5,
        "z": 0
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Water",
      "name": "WaterVolume_1751851835711",
      "size": [
        132.54649184918532,
        5,
        40.59476865495244
      ],
      "position": {
        "x": -25.018127726028194,
        "y": 66.26286700738792,
        "z": -71.55050709782384
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Water",
      "name": "WaterVolume_1751851913943",
      "size": [
        144.29413893998853,
        58.17101503697324,
        6.085456739395756
      ],
      "position": {
        "x": -22.579665429371754,
        "y": 39.83547957613843,
        "z": -54.4651136497402
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Waterfall",
      "name": "Waterfall_1751849086078",
      "size": [
        125,
        100,
        0
      ],
      "position": {
        "x": -23,
        "y": 20,
        "z": -50
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    },
    {
      "type": "Waterfall",
      "name": "Waterfall_1751849086078_copy_607",
      "size": [
        125,
        60,
        0
      ],
      "position": {
        "x": -23,
        "y": 69.6799060058554,
        "z": -80
      },
      "quaternion": {
        "x": -0.7071067811865475,
        "y": 0,
        "z": 0,
        "w": 0.7071067811865476
      }
    },
    {
      "type": "Waterfall",
      "name": "Waterfall_1751903906427",
      "size": [
        1.0888491145904546,
        17.80234802854945
      ],
      "position": {
        "x": -59.23143447383292,
        "y": 41.40933911874975,
        "z": 46.93368542850366
      },
      "quaternion": {
        "x": 0,
        "y": -0.4306282919574751,
        "z": 0,
        "w": 0.9025293757910529
      }
    },
    {
      "type": "Waterfall",
      "name": "Waterfall_1751903906427_copy_884",
      "size": [
        1.0888491145904546,
        17.80234802854945
      ],
      "position": {
        "x": -57.67687522859403,
        "y": 41.05393563175382,
        "z": 48.76459262445475
      },
      "quaternion": {
        "x": 0,
        "y": -0.1877304746020014,
        "z": 0,
        "w": 0.9822205805753143
      }
    }
  ],
  "npcs": [
    {
      "type": "Dummy",
      "team": "enemy",
      "attackType": "ranged",
      "position": {
        "x": 72.28059687750329,
        "y": 46.364617088840106,
        "z": 68.08619286909729
      }
    },
    {
      "type": "Dummy",
      "team": "enemy",
      "attackType": "ranged",
      "position": {
        "x": 66.83269983976291,
        "y": 42.478181286401096,
        "z": 80.66707604045486
      }
    },
    {
      "type": "Dummy",
      "team": "enemy",
      "attackType": "ranged",
      "position": {
        "x": -69.69917626801737,
        "y": 31.02362344162298,
        "z": -18.59416055059451
      }
    },
    {
      "type": "Dummy",
      "team": "enemy",
      "attackType": "ranged",
      "position": {
        "x": -55.989923917437565,
        "y": 45.385142502035954,
        "z": 46.213642602867935
      }
    },
    {
      "type": "Dummy",
      "team": "enemy",
      "attackType": "melee",
      "position": {
        "x": 52.8031794834911,
        "y": 27.62842390792051,
        "z": -33.02737319453194
      }
    },
    {
      "type": "Dummy",
      "team": "enemy",
      "attackType": "melee",
      "position": {
        "x": 60.36857833390194,
        "y": 27.703638102108155,
        "z": -41.80737994891453
      },
      "name": "Dummy_copy_761"
    }
  ],
  "triggers": [],
  "deathTriggers": [
    {
      "type": "DeathTrigger",
      "name": "DeathZone_1751850752178",
      "size": [
        300,
        48,
        4.238367338385679
      ],
      "position": {
        "x": -15,
        "y": 101,
        "z": -121
      },
      "quaternion": {
        "x": 0,
        "y": 0,
        "z": 0,
        "w": 1
      }
    }
  ]
}
--------------------------------------------------
=== END OF FILE: levels/level-waterfall.json ===


=== FILE: levels/manifest.json ===
--------------------------------------------------
[
  {
    "name": "Tutorial",
    "path": "./levels/level-tutorial.json"
  },
  {
    "name": "Corrupt Arena",
    "path": "./levels/level-stadium.json"
  },
  {
    "name": "Maria's Tears",
    "path": "./levels/level-waterfall.json"
  }
]
--------------------------------------------------
=== END OF FILE: levels/manifest.json ===


=== FILE: src/asset-editor/AnimationManager.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Manages animation playback for the asset editor.
 * This is a placeholder implementation for the ViewModel test mode.
 */
export class AnimationManager {
    constructor(app) {
        this.app = app;
        this.assetRoot = app.assetContext.assetRoot;
        this.isPlaying = false;
        this.playbackTime = 0;
        this.activeClipName = null;
        this.activeClipDuration = 0;

        // Store initial transforms to revert to
        this.initialTransforms = new Map();
    }

    triggerClip(clipName) {
        if (this.isPlaying) return; // Don't interrupt animations for now

        this.isPlaying = true;
        this.activeClipName = clipName;
        this.playbackTime = 0;
        
        // Simple placeholder durations
        this.activeClipDuration = (clipName === 'fire') ? 0.4 : 1.0;
        
        // Store initial state before animating
        this.storeInitialTransforms();
    }

    storeInitialTransforms() {
        this.initialTransforms.clear();
        this.assetRoot.traverse(child => {
            if (this.app.assetContext.parts.has(child.uuid)) {
                this.initialTransforms.set(child, {
                    position: child.position.clone(),
                    quaternion: child.quaternion.clone(),
                });
            }
        });
    }

    update(deltaTime) {
        if (!this.isPlaying) return;

        this.playbackTime += deltaTime;

        if (this.playbackTime >= this.activeClipDuration) {
            this.resetToIdle();
            return;
        }

        if (this.activeClipName === 'fire') {
            this.applyFireAnimation();
        } else if (this.activeClipName === 'reload') {
            this.applyReloadAnimation();
        }
    }

    applyFireAnimation() {
        // Example: A simple "kickback" animation for the whole asset
        const progress = this.playbackTime / this.activeClipDuration;
        const kickProgress = Math.sin(progress * Math.PI); // 0 -> 1 -> 0

        const initialTransform = this.initialTransforms.get(this.assetRoot);
        if (initialTransform) {
            this.assetRoot.position.z = initialTransform.position.z + kickProgress * 0.1;
            
            const kickRotation = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(1, 0, 0),
                kickProgress * -0.2
            );
            this.assetRoot.quaternion.copy(initialTransform.quaternion).multiply(kickRotation);
        }
    }
    
    applyReloadAnimation() {
        // Example: Rotate the asset down and up
        const progress = this.playbackTime / this.activeClipDuration;
        const reloadProgress = Math.sin(progress * Math.PI); // 0 -> 1 -> 0

        const initialTransform = this.initialTransforms.get(this.assetRoot);
        if (initialTransform) {
            const reloadRotation = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(1, 0, 0),
                reloadProgress * 0.8
            );
            this.assetRoot.quaternion.copy(initialTransform.quaternion).multiply(reloadRotation);
        }
    }

    resetToIdle() {
        this.isPlaying = false;
        this.activeClipName = null;
        this.initialTransforms.forEach((transform, part) => {
            part.position.copy(transform.position);
            part.quaternion.copy(transform.quaternion);
        });
    }
}
--------------------------------------------------
=== END OF FILE: src/asset-editor/AnimationManager.js ===


=== FILE: src/asset-editor/AssetContext.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * The "document" or data model for the asset being edited.
 * It holds the definitive state of all parts and their hierarchy.
 */
export class AssetContext {
    constructor(scene) {
        this.scene = scene;
        this.assetRoot = new THREE.Group();
        this.assetRoot.name = "AssetRoot";
        this.scene.add(this.assetRoot);

        /** @type {Map<string, THREE.Object3D>} */
        this.parts = new Map();
        this.animations = {};
        this.selectedPart = null;
    }

    addPart(partMesh, parent) {
        this.parts.set(partMesh.uuid, partMesh);
        const targetParent = parent || this.assetRoot;
        targetParent.add(partMesh);
        return partMesh;
    }

    removePart(partMesh) {
        if (!partMesh) return;
        partMesh.removeFromParent();
        this.parts.delete(partMesh.uuid);
        // Recursively remove children from the map
        [...partMesh.children].forEach(child => this.removePart(child));
    }

    reparentPart(part, newParent) {
        if (!part || !newParent) return;
        newParent.attach(part); // .attach() preserves world transform
    }
    
    setSelectedPart(part) {
        this.selectedPart = part;
    }

    serialize() {
        const geometry = [];
        this.parts.forEach(part => {
            const transform = {
                position: part.position.toArray(),
                rotation: part.rotation.toArray(),
                scale: part.scale.toArray(),
            };

            const partData = {
                uuid: part.uuid,
                name: part.name,
                type: part.geometry.type.replace('Geometry', ''),
                parent: part.parent !== this.assetRoot ? part.parent.uuid : null,
                transform: transform,
                material: { color: '#' + part.material.color.getHexString() }
            };
            geometry.push(partData);
        });
        
        return {
            assetName: this.assetRoot.name,
            type: "weapon",
            geometry,
            animations: {}
        };
    }

    loadFromData(assetData) {
        this.clear();
        if (!assetData || !assetData.geometry) return;

        this.assetRoot.name = assetData.assetName || "CustomAsset";
        
        const createdParts = new Map(); // Maps original UUID to new THREE.Mesh
        const geometryMap = {
            'Box': (s) => new THREE.BoxGeometry(...s),
            'Cylinder': (s) => new THREE.CylinderGeometry(s[0], s[1], s[2]),
            'Sphere': (s) => new THREE.SphereGeometry(s[0]),
        };

        // First pass: create all meshes
        assetData.geometry.forEach(partData => {
            const geoFn = geometryMap[partData.type];
            if (!geoFn) return;

            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color(partData.material.color)
            });

            const scale = partData.transform.scale || [1, 1, 1];
            const partMesh = new THREE.Mesh(geoFn(scale), material);
            partMesh.name = partData.name;
            
            createdParts.set(partData.uuid, partMesh);
        });
        
        // Second pass: set transforms and build hierarchy
        assetData.geometry.forEach(partData => {
            const partMesh = createdParts.get(partData.uuid);
            if (!partMesh) return;

            const { position, rotation } = partData.transform;
            if (position) partMesh.position.fromArray(position);
            if (rotation) partMesh.rotation.fromArray(rotation);

            const parentMesh = partData.parent ? createdParts.get(partData.parent) : null;
            this.addPart(partMesh, parentMesh);
        });
    }

    clear() {
        [...this.assetRoot.children].forEach(child => this.removePart(child));
        this.parts.clear();
        this.animations = {};
        this.selectedPart = null;
    }
}
--------------------------------------------------
=== END OF FILE: src/asset-editor/AssetContext.js ===


=== FILE: src/asset-editor/AssetEditorActions.js ===
--------------------------------------------------
import * as THREE from 'three';
import { StateChangeCommand } from './UndoManager.js';

export class AssetEditorActions {
    constructor(app) {
        this.app = app;
    }

    _createPart(geometry, name) {
        const material = new THREE.MeshStandardMaterial({
            color: 0xcccccc,
            metalness: 0.5,
            roughness: 0.5
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.name = name;
        return mesh;
    }

    _addPart(geometry, name) {
        const newPart = this._createPart(geometry, name);
        
        const command = {
            execute: () => {
                this.app.assetContext.addPart(newPart, this.app.primarySelectedObject);
                this.app.select(newPart);
            },
            undo: () => {
                this.app.deselect();
                this.app.assetContext.removePart(newPart);
            }
        };
        this.app.undoManager.execute(command);
    }
    
    addBox() { this._addPart(new THREE.BoxGeometry(1, 1, 1), 'Box'); }
    addCylinder() { this._addPart(new THREE.CylinderGeometry(0.5, 0.5, 1, 16), 'Cylinder'); }
    addSphere() { this._addPart(new THREE.SphereGeometry(0.5, 16, 16), 'Sphere'); }

    loadExamplePistol() {
        const oldState = this.app.assetContext.serialize();

        const pistolData = {
            assetName: "Example Pistol",
            type: "weapon",
            geometry: [
                {
                    uuid: "pistol-body",
                    name: "Body",
                    type: "Box",
                    parent: null,
                    transform: {
                        position: [0, 0, 0.05],
                        rotation: [0, 0, 0],
                        scale: [0.08, 0.12, 0.2]
                    },
                    material: { color: '#ff4757' }
                },
                {
                    uuid: "pistol-slide",
                    name: "Slide",
                    type: "Box",
                    parent: "pistol-body",
                    transform: {
                        position: [0, 0.08, 0],
                        rotation: [0, 0, 0],
                        scale: [0.07, 0.04, 0.3]
                    },
                    material: { color: '#ff4757' }
                }
            ],
            animations: {}
        };

        const command = {
            execute: () => {
                this.app.assetContext.loadFromData(pistolData);
                this.app.ui.updateOutliner();
                this.app.deselect();
            },
            undo: () => {
                this.app.assetContext.loadFromData(oldState);
                this.app.ui.updateOutliner();
                this.app.deselect();
            }
        };

        this.app.undoManager.execute(command);
    }

    deleteSelected() {
        if (this.app.selectedObjects.size === 0) return;
        
        const partsToDelete = [...this.app.selectedObjects];
        const command = {
            execute: () => {
                this.app.deselect();
                partsToDelete.forEach(part => this.app.assetContext.removePart(part));
            },
            undo: () => {
                this.app.deselect();
                partsToDelete.forEach(part => {
                    this.app.assetContext.addPart(part, part.parent);
                    this.app.addToSelection(part);
                });
            }
        };
        this.app.undoManager.execute(command);
    }

    reparentPart(partUuid, newParentUuid) {
        const part = this.app.assetContext.parts.get(partUuid);
        const oldParent = part.parent;
        const newParent = newParentUuid ? this.app.assetContext.parts.get(newParentUuid) : this.app.assetContext.assetRoot;

        if (!part || !newParent || part === newParent || part.children.includes(newParent)) return;

        const command = {
            execute: () => {
                this.app.assetContext.reparentPart(part, newParent);
                this.app.ui.updateOutliner();
            },
            undo: () => {
                this.app.assetContext.reparentPart(part, oldParent);
                this.app.ui.updateOutliner();
            }
        };
        this.app.undoManager.execute(command);
    }
}
--------------------------------------------------
=== END OF FILE: src/asset-editor/AssetEditorActions.js ===


=== FILE: src/asset-editor/AssetEditorApp.js ===
--------------------------------------------------
import * as THREE from 'three';
import { Renderer } from '../core/Renderer.js';
import { InputManager } from '../core/InputManager.js';
import { ModelEditorUI } from './ModelEditorUI.js';
import { EditorCamera } from './EditorCamera.js';
import { AssetEditorControls } from './AssetEditorControls.js';
import { AssetEditorActions } from './AssetEditorActions.js';
import { UndoManager } from './UndoManager.js';
import { AssetContext } from './AssetContext.js';
import { AnimationManager } from './AnimationManager.js';
import { ViewModelCamera } from './ViewModelCamera.js';
import { ViewModelGuide } from './ViewModelGuide.js';
import { EDITOR_LAYERS } from './layers.js';

export class AssetEditorApp {
    constructor() {
        this.clock = new THREE.Clock();
        this.container = document.getElementById('asset-editor-container');
        const canvas = document.getElementById('editor-canvas');
        this.renderer = new Renderer(canvas);
        this.input = new InputManager();

        this.scene = this.renderer.scene;
        this.camera = this.renderer.camera; // There is now only one camera

        this.gridHelper = null;
        this.viewModelGuide = null;
        
        this.selectedObjects = new Set();
        this.primarySelectedObject = null;
        this.selectionGroup = new THREE.Group();
        this.scene.add(this.selectionGroup);

        this.editorState = 'EDITING'; // 'EDITING' or 'TESTING'
        this.editorBackgroundColor = new THREE.Color(0x333333);
        this.testBackgroundColor = new THREE.Color(0x87CEEB); // Sky blue
    }

    async init() {
        this.scene.background = this.editorBackgroundColor;
        this.camera.position.set(0, 1.5, 5);
        this.camera.lookAt(0, 0, 0);

        this.scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 10, 7.5);
        this.scene.add(dirLight);

        this.gridHelper = new THREE.GridHelper(50, 50, 0xcccccc, 0x888888);
        this.scene.add(this.gridHelper);

        this.viewModelGuide = new ViewModelGuide();
        this.scene.add(this.viewModelGuide);

        // Core editor components
        this.assetContext = new AssetContext(this.scene);
        this.undoManager = new UndoManager(this);
        this.actions = new AssetEditorActions(this);
        this.controls = new AssetEditorControls(this);
        this.ui = new ModelEditorUI(this);
        
        // Camera Controllers - these now manipulate the single main camera
        this.editorCameraController = new EditorCamera(this);
        this.viewModelCameraController = new ViewModelCamera(this);
        
        this.animationManager = new AnimationManager(this);

        this.renderer.renderer.setAnimationLoop(() => this.animate());
    }

    enterViewModelTest() {
        if (this.editorState === 'TESTING') return;
        this.editorState = 'TESTING';

        this.deselect();
        this.controls.transformControls.enabled = false;
        
        // Setup test environment
        this.scene.background = this.testBackgroundColor;
        this.gridHelper.visible = true;
        this.viewModelGuide.setVisible(false);
        
        this.viewModelCameraController.start();

        // Attach asset to camera for viewmodel effect
        const asset = this.assetContext.assetRoot;
        asset.layers.set(EDITOR_LAYERS.VIEWMODEL);
        this.camera.add(asset);
        asset.position.set(0.25, -0.4, -0.8);
        asset.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
        
        this.container.classList.add('is-testing');
    }

    exitViewModelTest() {
        if (this.editorState !== 'TESTING') return;
        this.editorState = 'EDITING';
        
        this.viewModelCameraController.stop();

        // Detach asset from camera and restore state
        const asset = this.assetContext.assetRoot;
        this.scene.add(asset); // Reparent back to scene
        asset.layers.set(EDITOR_LAYERS.DEFAULT);
        asset.position.set(0, 0, 0); // Reset transform for editing
        asset.quaternion.identity();

        // Restore editor environment
        this.scene.background = this.editorBackgroundColor;
        this.controls.transformControls.enabled = true;
        this.gridHelper.visible = document.getElementById('view-toggle-grid').checked;
        this.viewModelGuide.setVisible(document.getElementById('view-toggle-viewmodel-guide').checked);
        
        this.animationManager.resetToIdle();
        this.container.classList.remove('is-testing');
    }
    
    select(object) {
        if (this.editorState !== 'EDITING') return;
        this.deselect();
        this.addToSelection(object);
    }

    addToSelection(object) {
        if (!object || this.selectedObjects.has(object) || this.editorState !== 'EDITING') return;
        this.selectedObjects.add(object);
        this.primarySelectedObject = object;
        this.controls.updateSelection();
        this.ui.updateOnSelectionChange();
    }

    removeFromSelection(object) {
        if (!object || !this.selectedObjects.has(object)) return;
        this.selectedObjects.delete(object);
        if (this.primarySelectedObject === object) {
            this.primarySelectedObject = this.selectedObjects.size > 0 ? this.selectedObjects.values().next().value : null;
        }
        this.controls.updateSelection();
        this.ui.updateOnSelectionChange();
    }

    deselect() {
        if (this.selectedObjects.size === 0) return;
        this.selectedObjects.clear();
        this.primarySelectedObject = null;
        this.controls.updateSelection();
        this.ui.updateOnSelectionChange();
    }

    animate() {
        const deltaTime = this.clock.getDelta();
        
        if (this.editorState === 'EDITING') {
            this.editorCameraController.update(deltaTime);
            this.controls.update();
        } else { // 'TESTING'
            this.viewModelCameraController.update(deltaTime);
        }
        
        this.animationManager.update(deltaTime);
        
        // Render logic
        const webglRenderer = this.renderer.renderer;
        webglRenderer.autoClear = false;
        webglRenderer.clear();

        if (this.editorState === 'TESTING') {
            // Render the main scene (world)
            this.camera.layers.set(EDITOR_LAYERS.DEFAULT);
            webglRenderer.render(this.scene, this.camera);
            
            webglRenderer.clearDepth();

            // Render the viewmodel
            this.camera.layers.set(EDITOR_LAYERS.VIEWMODEL);
            webglRenderer.render(this.scene, this.camera);
        } else {
            this.camera.layers.set(EDITOR_LAYERS.DEFAULT);
            webglRenderer.render(this.scene, this.camera);
        }
        
        webglRenderer.autoClear = true;
        this.camera.layers.set(EDITOR_LAYERS.DEFAULT); // Reset for next frame
    }
}
--------------------------------------------------
=== END OF FILE: src/asset-editor/AssetEditorApp.js ===


=== FILE: src/asset-editor/AssetEditorControls.js ===
--------------------------------------------------
import * as THREE from 'three';
import { TransformControls } from 'three/addons/controls/TransformControls.js';
import { StateChangeCommand } from './UndoManager.js';

export class AssetEditorControls {
    constructor(app) {
        this.app = app;
        this.camera = app.camera;
        this.renderer = app.renderer.renderer;
        this.input = app.input;
        this.scene = app.scene;

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        
        // --- Snapping State ---
        this.isSnapEnabled = false;
        this.translationSnapValue = 0.5;
        this.rotationSnapValue = 15;

        this._initialDragState = null;
        this._onMouseDownHandler = this.onMouseDown.bind(this);
        this.init();
    }

    init() {
        this.transformControls = new TransformControls(this.camera, this.renderer.domElement);
        this.scene.add(this.transformControls);
        this.transformControls.addEventListener('dragging-changed', (event) => this.onDraggingChanged(event));
        this.renderer.domElement.addEventListener('mousedown', this._onMouseDownHandler, false);
        this.applySnapSettings();
    }
    
    setSnapEnabled(enabled) {
        this.isSnapEnabled = enabled;
        this.applySnapSettings();
    }

    setTranslationSnap(value) {
        this.translationSnapValue = value;
        this.applySnapSettings();
    }

    setRotationSnap(value) {
        this.rotationSnapValue = value;
        this.applySnapSettings();
    }

    applySnapSettings() {
        if (this.isSnapEnabled) {
            this.transformControls.setTranslationSnap(this.translationSnapValue);
            this.transformControls.setRotationSnap(THREE.MathUtils.degToRad(this.rotationSnapValue));
            // A reasonable default for scale snapping, can be customized later if needed
            this.transformControls.setScaleSnap(this.translationSnapValue / 10);
        } else {
            this.transformControls.setTranslationSnap(null);
            this.transformControls.setRotationSnap(null);
            this.transformControls.setScaleSnap(null);
        }
    }

    onMouseDown(event) {
        if (event.button !== 0 || this.transformControls.dragging) return;

        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.app.assetContext.assetRoot.children, true);
        
        if (intersects.length > 0) {
            const object = intersects[0].object;
             if (event.shiftKey) {
                if (this.app.selectedObjects.has(object)) {
                    this.app.removeFromSelection(object);
                } else {
                    this.app.addToSelection(object);
                }
            } else {
                if (!this.app.selectedObjects.has(object)) {
                    this.app.select(object);
                }
            }
        } else {
            if (!event.shiftKey) {
                this.app.deselect();
            }
        }
    }
    
    onDraggingChanged(event) {
        this.input.enabled = !event.value;
        const selected = this.app.selectedObjects;
        if (selected.size === 0) return;

        if (event.value) { // Drag started
            this._initialDragState = [];
            selected.forEach(obj => {
                this._initialDragState.push({
                    object: obj,
                    position: obj.position.clone(),
                    quaternion: obj.quaternion.clone(),
                    scale: obj.scale.clone()
                });
            });
            if (this.app.selectionGroup.children.length > 0) {
                 this._initialDragState.push({
                    object: this.app.selectionGroup,
                    position: this.app.selectionGroup.position.clone(),
                    quaternion: this.app.selectionGroup.quaternion.clone(),
                    scale: this.app.selectionGroup.scale.clone()
                });
            }
        } else { // Drag ended
            const changes = [];
            this.detachFromGroup(); // Detach first to get final world transforms

            this._initialDragState.forEach(state => {
                const { object, ...beforeState } = state;
                const afterState = {
                    position: object.position.clone(),
                    quaternion: object.quaternion.clone(),
                    scale: object.scale.clone()
                };
                
                if (!beforeState.position.equals(afterState.position) ||
                    !beforeState.quaternion.equals(afterState.quaternion) ||
                    !beforeState.scale.equals(afterState.scale)) {
                     changes.push({ entity: object, beforeState, afterState });
                }
            });

            if (changes.length > 0) {
                this.app.undoManager.execute(new StateChangeCommand(this.app, changes));
            }
            this._initialDragState = null;
            this.updateSelection(); // Re-sync selection boxes and gizmo
        }
    }

    updateSelection() {
        this.detachFromGroup();
        this.transformControls.detach();

        const selected = this.app.selectedObjects;
        if (selected.size === 0) return;

        if (selected.size === 1) {
            const object = selected.values().next().value;
            this.transformControls.attach(object);
        } else {
            const group = this.app.selectionGroup;
            const centroid = new THREE.Vector3();
            selected.forEach(obj => centroid.add(obj.position));
            centroid.divideScalar(selected.size);
            group.position.copy(centroid);
            group.rotation.set(0,0,0);
            group.scale.set(1,1,1);
            
            selected.forEach(obj => group.attach(obj)); // .attach() preserves world transform
            this.transformControls.attach(group);
        }
    }

    detachFromGroup() {
        const group = this.app.selectionGroup;
        const root = this.app.assetContext.assetRoot;
        while(group.children.length) {
            root.attach(group.children[0]); // .attach() preserves world transform
        }
    }

    select(object) { this.updateSelection(); }
    deselect() { this.updateSelection(); }
    setMode(mode) { this.transformControls.setMode(mode); this.app.ui.updateTransformModeButtons(mode); }
    update() { /* Not needed for controls */ }
    dispose() { this.renderer.domElement.removeEventListener('mousedown', this._onMouseDownHandler); this.transformControls.dispose(); }
}
--------------------------------------------------
=== END OF FILE: src/asset-editor/AssetEditorControls.js ===


=== FILE: src/asset-editor/asset_editor_main.js ===
--------------------------------------------------
import { AssetEditorApp } from './AssetEditorApp.js';

/**
 * The entry point for the asset editor application.
 * It creates and initializes the main AssetEditorApp instance.
 */
class Main {
    constructor() {
        this.app = new AssetEditorApp();
    }

    async run() {
        try {
            await this.app.init();
        } catch(error) {
            console.error("Failed to initialize the asset editor application:", error);
            document.body.innerHTML = `<div style="color:red; text-align:center; margin-top: 50px;">
                <h1>Asset Editor Failed to Start</h1>
                <p>Please check the console for errors.</p>
            </div>`;
        }
    }
}

const main = new Main();
main.run();
--------------------------------------------------
=== END OF FILE: src/asset-editor/asset_editor_main.js ===


=== FILE: src/asset-editor/EditorCamera.js ===
--------------------------------------------------
import * as THREE from 'three';

export class EditorCamera {
    constructor(app) {
        this.app = app;
        this.camera = app.camera;
        this.input = app.input;
    }

    update(deltaTime) {
        // Prevent camera movement while transform controls are active or input is disabled
        if (this.app.controls?.transformControls.dragging || !this.input.enabled) {
            this.input.update();
            return;
        }

        const moveSpeed = 10 * deltaTime;
        const forward = new THREE.Vector3();
        this.camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(this.camera.up, forward).negate();
        
        if (this.input.keys['KeyW']) this.camera.position.addScaledVector(forward, moveSpeed);
        if (this.input.keys['KeyS']) this.camera.position.addScaledVector(forward, -moveSpeed);
        if (this.input.keys['KeyA']) this.camera.position.addScaledVector(right, -moveSpeed);
        if (this.input.keys['KeyD']) this.camera.position.addScaledVector(right, moveSpeed);
        if (this.input.keys['Space']) this.camera.position.y += moveSpeed;
        if (this.input.keys['ShiftLeft']) this.camera.position.y -= moveSpeed;
        
        if (this.input.mouse.rightClick) {
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            euler.setFromQuaternion(this.camera.quaternion);
            euler.y -= this.input.mouse.movementX * 0.002;
            euler.x -= this.input.mouse.movementY * 0.002;
            euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
            this.camera.quaternion.setFromEuler(euler);
        }

        this.input.update();
    }
}
--------------------------------------------------
=== END OF FILE: src/asset-editor/EditorCamera.js ===


=== FILE: src/asset-editor/layers.js ===
--------------------------------------------------
// Defines rendering layers for the asset editor scene.
export const EDITOR_LAYERS = {
    DEFAULT: 0,
    VIEWMODEL: 1, // For the asset when in viewmodel test mode
};
--------------------------------------------------
=== END OF FILE: src/asset-editor/layers.js ===


=== FILE: src/asset-editor/ModelEditorUI.js ===
--------------------------------------------------
import * as THREE from 'three';
import { StateChangeCommand } from './UndoManager.js';

export class ModelEditorUI {
    constructor(app) {
        this.app = app;
        this.outlinerContent = document.getElementById('outliner-content');
        this.inspectorContent = document.getElementById('inspector-content');
        this.draggedElement = null;
        this.init();
    }

    init() {
        // --- Menu ---
        document.getElementById('menu-file-exit').onclick = () => { window.location.href = 'index.html'; };
        document.getElementById('menu-file-load-example').onclick = () => this.app.actions.loadExamplePistol();
        document.getElementById('menu-file-test-viewmodel').onclick = () => this.app.enterViewModelTest();
        document.getElementById('menu-edit-delete').onclick = () => this.app.actions.deleteSelected();
        document.getElementById('menu-edit-undo').onclick = () => this.app.undoManager.undo();
        document.getElementById('menu-edit-redo').onclick = () => this.app.undoManager.redo();
        document.getElementById('menu-help-guide').onclick = () => this.showHelpModal(true);

        // --- View Menu ---
        document.getElementById('view-toggle-grid').onchange = (e) => { if(this.app.gridHelper) this.app.gridHelper.visible = e.target.checked; };
        document.getElementById('view-toggle-viewmodel-guide').onchange = (e) => { if(this.app.viewModelGuide) this.app.viewModelGuide.setVisible(e.target.checked); };

        // --- Toolbar ---
        document.getElementById('tool-translate').onclick = () => this.app.controls.setMode('translate');
        document.getElementById('tool-rotate').onclick = () => this.app.controls.setMode('rotate');
        document.getElementById('tool-scale').onclick = () => this.app.controls.setMode('scale');
        
        const snapToggle = document.getElementById('snap-toggle');
        const transSnapInput = document.getElementById('snap-translation-input');
        const rotSnapInput = document.getElementById('snap-rotation-input');
        snapToggle.onchange = (e) => this.app.controls.setSnapEnabled(e.target.checked);
        transSnapInput.onchange = (e) => this.app.controls.setTranslationSnap(parseFloat(e.target.value));
        rotSnapInput.onchange = (e) => this.app.controls.setRotationSnap(parseFloat(e.target.value));
        document.querySelector('label[for="snap-toggle"]').onclick = () => snapToggle.click();
        
        snapToggle.checked = this.app.controls.isSnapEnabled;
        transSnapInput.value = this.app.controls.translationSnapValue;
        rotSnapInput.value = this.app.controls.rotationSnapValue;

        // --- Create Button & Menu ---
        const createButton = document.getElementById('create-button');
        const createMenu = document.getElementById('create-context-menu');
        createButton.onclick = (e) => { e.stopPropagation(); createMenu.style.display = createMenu.style.display === 'none' ? 'flex' : 'none'; };
        createMenu.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            if (action && typeof this.app.actions[action] === 'function') this.app.actions[action]();
            createMenu.style.display = 'none';
        });
        document.addEventListener('click', () => { createMenu.style.display = 'none'; });
        
        // --- Outliner ---
        this.outlinerContent.addEventListener('click', (e) => this.handleOutlinerClick(e));
        this.outlinerContent.addEventListener('dragstart', (e) => this.handleOutlinerDragStart(e));
        this.outlinerContent.addEventListener('dragover', (e) => this.handleOutlinerDragOver(e));
        this.outlinerContent.addEventListener('dragleave', (e) => this.handleOutlinerDragLeave(e));
        this.outlinerContent.addEventListener('drop', (e) => this.handleOutlinerDrop(e));

        // --- Viewmodel Test ---
        document.getElementById('exit-test-mode-btn').onclick = () => this.app.exitViewModelTest();

        // --- Help Modal ---
        const helpModal = document.getElementById('help-modal');
        helpModal.querySelector('.modal-close-btn').onclick = () => this.showHelpModal(false);
        helpModal.onclick = (e) => { if (e.target === e.currentTarget) this.showHelpModal(false); };

        // --- Top Menu Hover Logic to close other menus ---
        const menuDropdowns = document.querySelectorAll('#editor-menu-bar .menu-dropdown');
        menuDropdowns.forEach(dropdown => {
            dropdown.addEventListener('pointerenter', () => {
                const openDropdown = document.querySelector('#editor-menu-bar .menu-dropdown[open]');
                if (openDropdown && openDropdown !== dropdown) {
                    openDropdown.open = false;
                }
                dropdown.open = true;
            });

            dropdown.addEventListener('mouseleave', () => {
                dropdown.open = false;
            });
        });
    }
    
    showHelpModal(show) {
        document.getElementById('help-modal').style.display = show ? 'flex' : 'none';
    }

    updateOnSelectionChange() {
        document.getElementById('menu-edit-delete').disabled = this.app.selectedObjects.size === 0;
        this.updateOutliner();
        this.updateInspector();
    }

    handleOutlinerClick(event) {
        const item = event.target.closest('.outliner-item');
        if (!item) return;

        const object = this.app.assetContext.parts.get(item.dataset.uuid);
        if (!object) return;

        if (event.shiftKey) {
            if (this.app.selectedObjects.has(object)) {
                this.app.removeFromSelection(object);
            } else {
                this.app.addToSelection(object);
            }
        } else {
            this.app.select(object);
        }
    }

    handleOutlinerDragStart(event) {
        const item = event.target.closest('.outliner-item');
        if (!item) return;
        this.draggedElement = item;
        event.dataTransfer.setData('text/plain', item.dataset.uuid);
        event.dataTransfer.effectAllowed = 'move';
    }
    
    handleOutlinerDragOver(event) {
        event.preventDefault();
        const targetItem = event.target.closest('.outliner-item');
        if (targetItem && targetItem !== this.draggedElement) {
            targetItem.classList.add('drag-over');
        }
    }

    handleOutlinerDragLeave(event) {
        const targetItem = event.target.closest('.outliner-item');
        if (targetItem) {
            targetItem.classList.remove('drag-over');
        }
    }

    handleOutlinerDrop(event) {
        event.preventDefault();
        const targetItem = event.target.closest('.outliner-item');
        if (targetItem) targetItem.classList.remove('drag-over');
        
        const draggedUuid = event.dataTransfer.getData('text/plain');
        const targetUuid = targetItem ? targetItem.dataset.uuid : null;

        if (draggedUuid && draggedUuid !== targetUuid) {
            this.app.actions.reparentPart(draggedUuid, targetUuid);
        }
        this.draggedElement = null;
    }

    updateOutliner() {
        this.outlinerContent.innerHTML = '';
        if (this.app.assetContext.parts.size === 0) {
            this.outlinerContent.innerHTML = '<div class="placeholder-text">Create a part to begin.</div>';
            return;
        }

        const buildTree = (parent, level) => {
            parent.children.forEach(child => {
                if (!this.app.assetContext.parts.has(child.uuid)) return; // Skip children that aren't in the context (like gizmos)
                const item = document.createElement('div');
                item.className = 'outliner-item';
                item.textContent = child.name;
                item.dataset.uuid = child.uuid;
                item.dataset.depth = level;
                item.draggable = true;
                if (this.app.selectedObjects.has(child)) item.classList.add('selected');
                this.outlinerContent.appendChild(item);
                buildTree(child, level + 1);
            });
        };
        buildTree(this.app.assetContext.assetRoot, 0);
    }

    updateInspector() {
        this.inspectorContent.innerHTML = '';
        const obj = this.app.primarySelectedObject;

        if (this.app.selectedObjects.size > 1) {
             const multiSelectInfo = document.createElement('div');
            multiSelectInfo.className = 'placeholder-text';
            multiSelectInfo.innerHTML = `<b>${this.app.selectedObjects.size} objects selected.</b><br>Properties shown for primary selection.`;
            this.inspectorContent.appendChild(multiSelectInfo);
        }

        if (!obj) {
            this.inspectorContent.innerHTML = '<div class="placeholder-text">Select a part to view its properties.</div>';
            return;
        }

        const fragment = document.createDocumentFragment();
        
        const createPropGroup = (label) => {
            const group = document.createElement('div'); group.className = 'prop-group';
            const labelEl = document.createElement('label'); labelEl.textContent = label;
            group.appendChild(labelEl); fragment.appendChild(group);
            return group;
        };
        const createVec3Inputs = (group, vec, step, callback) => {
            const container = document.createElement('div'); container.className = 'prop-input-group';
            ['x', 'y', 'z'].forEach(axis => {
                const input = document.createElement('input'); input.type = 'number';
                
                const currentStep = typeof step === 'object' ? (step[axis] || 0.1) : step;
                input.step = currentStep;
                
                const isInt = currentStep >= 1;
                input.value = isInt ? (vec[axis] || 0).toFixed(0) : (vec[axis] || 0).toFixed(3);

                input.onchange = () => callback(axis, parseFloat(input.value));
                container.appendChild(input);
            });
            group.appendChild(container);
        };
        
        const nameGroup = createPropGroup('Name');
        const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = obj.name;
        nameInput.onchange = () => this.app.undoManager.execute(new StateChangeCommand(this.app, { entity: obj, beforeState: { name: obj.name }, afterState: { name: nameInput.value } }));
        nameGroup.appendChild(nameInput);
        
        fragment.appendChild(document.createElement('hr'));

        const posGroup = createPropGroup('Position');
        createVec3Inputs(posGroup, obj.position, 0.1, (axis, value) => {
            const before = { position: obj.position.clone() };
            const after = { position: obj.position.clone() }; after.position[axis] = value;
            this.app.undoManager.execute(new StateChangeCommand(this.app, { entity: obj, beforeState: before, afterState: after }));
        });

        const rotGroup = createPropGroup('Rotation (Deg)');
        const eulerDeg = new THREE.Euler().setFromQuaternion(obj.quaternion, 'YXZ');
        eulerDeg.x = THREE.MathUtils.radToDeg(eulerDeg.x); eulerDeg.y = THREE.MathUtils.radToDeg(eulerDeg.y); eulerDeg.z = THREE.MathUtils.radToDeg(eulerDeg.z);
        createVec3Inputs(rotGroup, eulerDeg, 5, (axis, value) => {
            const before = { quaternion: obj.quaternion.clone() };
            const newEuler = new THREE.Euler().setFromQuaternion(obj.quaternion, 'YXZ');
            newEuler[axis] = THREE.MathUtils.degToRad(value);
            const after = { quaternion: new THREE.Quaternion().setFromEuler(newEuler) };
            this.app.undoManager.execute(new StateChangeCommand(this.app, { entity: obj, beforeState: before, afterState: after }));
        });
        
        const sizeGroup = createPropGroup('Size');
        const displaySize = {};
        let steps = 0.1;
        const params = obj.geometry.parameters;
        
        switch (obj.geometry.type) {
            case 'BoxGeometry':
                displaySize.x = params.width;
                displaySize.y = params.height;
                displaySize.z = params.depth;
                break;
            case 'CylinderGeometry':
                displaySize.x = params.radiusTop;
                displaySize.y = params.height;
                displaySize.z = params.radiusBottom;
                break;
            case 'SphereGeometry':
                displaySize.x = params.radius;
                displaySize.y = params.widthSegments;
                displaySize.z = params.heightSegments;
                steps = { x: 0.1, y: 1, z: 1 };
                break;
            default:
                displaySize.x = 0; displaySize.y = 0; displaySize.z = 0;
                break;
        }

        createVec3Inputs(sizeGroup, displaySize, steps, (axis, value) => {
            const before = { geometry: { ...obj.geometry.parameters } };
            const after = { geometry: { ...obj.geometry.parameters } };
            const keyMap = { x: 'width', y: 'height', z: 'depth' };
            if(obj.geometry.type === 'CylinderGeometry') { Object.assign(keyMap, { x: 'radiusTop', y: 'height', z: 'radiusBottom'}); }
            if(obj.geometry.type === 'SphereGeometry') { Object.assign(keyMap, { x: 'radius', y: 'widthSegments', z: 'heightSegments'}); }

            const propName = keyMap[axis];
            if (propName) {
                if (obj.geometry.type === 'SphereGeometry' && (axis === 'y' || axis === 'z')) {
                    value = Math.max(3, Math.round(value));
                }
                after.geometry[propName] = value;
                this.app.undoManager.execute(new StateChangeCommand(this.app, { entity: obj, beforeState: before, afterState: after }));
            }
        });

        fragment.appendChild(document.createElement('hr'));

        const matGroup = createPropGroup('Material');
        const matContainer = document.createElement('div'); matContainer.className = 'prop-input-group';
        const colorInput = document.createElement('input'); colorInput.type = 'color'; colorInput.value = '#' + obj.material.color.getHexString();
        colorInput.oninput = () => obj.material.color.set(colorInput.value);
        const beforeColor = obj.material.color.getHex();
        colorInput.onchange = () => this.app.undoManager.execute(new StateChangeCommand(this.app, { entity: obj, beforeState: { material: { color: beforeColor }}, afterState: { material: { color: obj.material.color.getHex() }}}));
        matContainer.appendChild(colorInput);
        matGroup.appendChild(matContainer);
        
        this.inspectorContent.appendChild(fragment);
    }
    
    updateTransformModeButtons(mode) {
        ['translate', 'rotate', 'scale'].forEach(m => document.getElementById(`tool-${m}`).classList.toggle('active', m === mode));
    }
}
--------------------------------------------------
=== END OF FILE: src/asset-editor/ModelEditorUI.js ===


=== FILE: src/asset-editor/UndoManager.js ===
--------------------------------------------------
import * as THREE from 'three';

export class StateChangeCommand {
    constructor(app, changes) {
        this.app = app;
        
        const changeArray = Array.isArray(changes) ? changes : [{ entity: changes.entity || changes, ...changes }];

        // Create a clean, deep copy of the changes array with cloned THREE objects.
        this.changes = changeArray.map(c => {
            const cloneState = (state) => {
                if (!state) return null;
                const cloned = {};
                if (state.position) cloned.position = state.position.clone();
                if (state.quaternion) cloned.quaternion = state.quaternion.clone();
                if (state.scale) cloned.scale = state.scale.clone();
                if (state.name !== undefined) cloned.name = state.name;
                if (state.material?.color !== undefined) {
                    // Handle both raw hex and THREE.Color objects
                    cloned.material = { color: state.material.color.isColor ? state.material.color.getHex() : state.material.color };
                }
                if (state.geometry !== undefined) cloned.geometry = { ...state.geometry };
                return cloned;
            };

            return {
                entity: c.entity,
                beforeState: cloneState(c.beforeState),
                afterState: cloneState(c.afterState)
            };
        });
    }

    _applyState(stateSource) {
        this.app.deselect();
        this.changes.forEach(change => {
            const state = change[stateSource];
            if (!state) return;
            
            const entity = change.entity;

            if (state.position) entity.position.copy(state.position);
            if (state.quaternion) entity.quaternion.copy(state.quaternion);
            if (state.scale) entity.scale.copy(state.scale);
            if (state.name) entity.name = state.name;
            if (state.material?.color !== undefined) entity.material.color.setHex(state.material.color);
            
            if (state.geometry) {
                entity.geometry.dispose(); // Dispose the old geometry
                const params = state.geometry;
                switch(entity.geometry.type) {
                    case 'BoxGeometry':
                        entity.geometry = new THREE.BoxGeometry(params.width, params.height, params.depth);
                        break;
                    case 'CylinderGeometry':
                         entity.geometry = new THREE.CylinderGeometry(params.radiusTop, params.radiusBottom, params.height, params.radialSegments || 16);
                        break;
                    case 'SphereGeometry':
                         entity.geometry = new THREE.SphereGeometry(params.radius, params.widthSegments || 16, params.heightSegments || 16);
                        break;
                }
            }
            
            this.app.addToSelection(entity);
        });
        this.app.ui.updateInspector();
    }

    execute() { this._applyState('afterState'); }
    undo() { this._applyState('beforeState'); }
}


export class UndoManager {
    constructor(app) {
        this.app = app;
        this.undoStack = [];
        this.redoStack = [];
        this.maxHistory = 100;

        this.updateUI();
    }

    execute(command) {
        this.undoStack.push(command);
        if (this.undoStack.length > this.maxHistory) {
            this.undoStack.shift();
        }
        this.redoStack = [];
        if(command.execute) command.execute();
        this.updateUI();
    }

    undo() {
        if (this.undoStack.length === 0) return;
        const command = this.undoStack.pop();
        this.redoStack.push(command);
        if(command.undo) command.undo();
        this.updateUI();
    }

    redo() {
        if (this.redoStack.length === 0) return;
        const command = this.redoStack.pop();
        this.undoStack.push(command);
        if(command.execute) command.execute();
        this.updateUI();
    }
    
    updateUI() {
        document.getElementById('menu-edit-undo').disabled = this.undoStack.length === 0;
        document.getElementById('menu-edit-redo').disabled = this.redoStack.length === 0;
    }
}
--------------------------------------------------
=== END OF FILE: src/asset-editor/UndoManager.js ===


=== FILE: src/asset-editor/ViewModelCamera.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * A controller that manipulates the main camera to simulate a first-person
 * perspective for testing assets.
 */
export class ViewModelCamera {
    constructor(app) {
        this.app = app;
        this.input = app.input;
        this.camera = app.camera; // It controls the main camera now
        this.moveSpeed = 5;
        this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
        
        // Store the camera's state before taking over
        this.originalCameraState = {};
    }

    start() {
        // Save the editor camera's current state
        this.originalCameraState = {
            position: this.camera.position.clone(),
            quaternion: this.camera.quaternion.clone(),
        };

        // Reset for test mode
        this.camera.position.set(0, 1.6, 5);
        this.euler.set(0, 0, 0);
        this.camera.quaternion.setFromEuler(this.euler);
    }

    stop() {
        if (this.originalCameraState.position) {
            this.camera.position.copy(this.originalCameraState.position);
            this.camera.quaternion.copy(this.originalCameraState.quaternion);
        }
    }
    
    update(deltaTime) {
        // --- Look Controls ---
        this.euler.setFromQuaternion(this.camera.quaternion, 'YXZ');
        this.euler.y -= this.input.mouse.movementX * 0.002;
        this.euler.x -= this.input.mouse.movementY * 0.002;
        this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
        this.camera.quaternion.setFromEuler(this.euler);
        
        // --- Movement Controls ---
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion);
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(this.camera.quaternion);

        if (this.input.keys['KeyW']) this.camera.position.addScaledVector(forward, this.moveSpeed * deltaTime);
        if (this.input.keys['KeyS']) this.camera.position.addScaledVector(forward, -this.moveSpeed * deltaTime);
        if (this.input.keys['KeyA']) this.camera.position.addScaledVector(right, -this.moveSpeed * deltaTime);
        if (this.input.keys['KeyD']) this.camera.position.addScaledVector(right, this.moveSpeed * deltaTime);

        this.camera.position.y = 1.6; // Keep a fixed height

        // --- Animation Triggers ---
        if (this.input.mouse.leftClick) {
            this.app.animationManager.triggerClip('fire');
        }
        if (this.input.keys['KeyR']) {
            this.app.animationManager.triggerClip('reload');
        }

        this.input.update();
    }
}
--------------------------------------------------
=== END OF FILE: src/asset-editor/ViewModelCamera.js ===


=== FILE: src/asset-editor/ViewModelGuide.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * A visual guide in the editor to help with weapon scale, orientation, and root position.
 */
export class ViewModelGuide extends THREE.Group {
    constructor() {
        super();
        this.name = 'ViewModelGuide';
        this.createHelpers();
    }

    createHelpers() {
        // 1. Bounding box for typical weapon size
        const boxSize = { width: 0.4, height: 0.5, depth: 1.2 };
        const boxGeom = new THREE.BoxGeometry(boxSize.width, boxSize.height, boxSize.depth);
        const boxEdges = new THREE.EdgesGeometry(boxGeom);
        const boxMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4 });
        const boxHelper = new THREE.LineSegments(boxEdges, boxMat);
        // Position the box so its back is at the origin (where the grip should be)
        boxHelper.position.z = boxSize.depth / 2;
        this.add(boxHelper);

        // 2. Arrow indicating the "forward" direction (+Z) for modeling
        const arrow = new THREE.ArrowHelper(
            new THREE.Vector3(0, 0, 1), // direction
            new THREE.Vector3(0, 0, 0), // origin
            1.5, // length
            0xffff00, // color
            0.2, // headLength
            0.1 // headWidth
        );
        this.add(arrow);

        // 3. Sphere indicating the hand/grip position at the origin
        const handGeom = new THREE.SphereGeometry(0.08);
        const handMat = new THREE.MeshBasicMaterial({ color: 0x00a3ff, wireframe: true });
        const handSphere = new THREE.Mesh(handGeom, handMat);
        this.add(handSphere);
    }

    /**
     * Sets the visibility of the entire guide.
     * @param {boolean} visible 
     */
    setVisible(visible) {
        this.visible = visible;
    }
}
--------------------------------------------------
=== END OF FILE: src/asset-editor/ViewModelGuide.js ===


=== FILE: src/client/client_main.js ===
--------------------------------------------------
import * as THREE from 'three';
import { Renderer } from '../core/Renderer.js';
import { Physics } from '../core/Physics.js';
import { InputManager } from '../core/InputManager.js';
import { AssetManager } from '../core/AssetManager.js';
import { Game } from '../game/Game.js';
import { UIManager } from './ui/UIManager.js';
import { VFXManager } from './rendering/VFXManager.js';
import { VFXSystem } from './systems/VFXSystem.js';
import { WorldUISystem } from './systems/WorldUISystem.js';
import { PhysicsSyncSystem } from '../game/systems/PhysicsSyncSystem.js';
import { AbilityIconService } from './ui/AbilityIconService.js';

class App {
    constructor() {
        this.clock = new THREE.Clock();
        this.core = {};
        this.game = null;
        this.ui = null;
        this.vfxManager = null;
        this.vfxSystem = null;
        this.worldUISystem = null;
        this.physicsSyncSystem = null;
        this.abilityIconService = null;
    }

    async init() {
        // 1. Initialize Core Engine Modules
        const canvas = document.getElementById('game-canvas');
        this.core.clock = this.clock;
        this.core.renderer = new Renderer(canvas);
        this.core.physics = new Physics();
        this.core.input = new InputManager();
        this.core.assets = new AssetManager();
        
        // 2. Initialize UI & VFX Managers
        this.abilityIconService = new AbilityIconService();
        this.ui = new UIManager(this.abilityIconService);
        this.vfxManager = new VFXManager(this.core.renderer.scene);
        
        // 3. Initialize Client-side Systems
        this.physicsSyncSystem = new PhysicsSyncSystem();
        this.worldUISystem = new WorldUISystem(this.core.renderer.scene);
        
        // 4. Initialize Game State Manager
        this.game = new Game(this.core, this.ui);

        // 5. Hook up client-side systems to game events
        this.game.on('worldCreated', (world) => {
            if (this.vfxSystem) this.vfxSystem.dispose();
            
            this.vfxSystem = new VFXSystem(world, this.vfxManager);
            this.worldUISystem.registerWorld(world);
        });

        // 6. Load initial assets, set up game, start loop
        await this.game.init();

        this.core.renderer.renderer.setAnimationLoop(() => this.animate());
    }

    animate() {
        const deltaTime = this.clock.getDelta();
        
        // 1. Process inputs
        if (this.game.world?.player) {
            this.game.playerController.update(deltaTime);
        }

        // 2. Update game logic
        if (this.game.world) {
            this.game.update(deltaTime);
        }

        // 3. Step physics
        this.core.physics.update(deltaTime);
        
        // 4. Sync visuals
        if (this.game.world) {
            this.physicsSyncSystem.update(this.game.world);
        }

        // 5. Update client systems & UI
        this.vfxManager.update(deltaTime);
        this.vfxSystem?.update(deltaTime);
        this.worldUISystem?.update(deltaTime);
        this.ui.update(this.game);

        // 6. Render
        this.core.renderer.render();

        // 7. Reset input deltas
        this.core.input.update();
    }
}

const app = new App();
window.app = app; 
app.init().catch(err => console.error("Application failed to initialize:", err));
--------------------------------------------------
=== END OF FILE: src/client/client_main.js ===


=== FILE: src/client/entities/PlayerController.js ===
--------------------------------------------------
import * as THREE from 'three';
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Handles client-side player input and translates it into commands for the player entity.
 * This class acts as the bridge between the InputManager and the player's state/actions.
 */
export class PlayerController {
    constructor(inputManager) {
        this.input = inputManager;
        this.player = null; // Will be attached by the game state

        // --- Internal State for Input Processing ---
        this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
        this.keyLastPress = {};
        this.keyPreviousState = {};
        this.isRightMouseDown = false;
        
        // --- PERFORMANCE: Reusable Vectors ---
        this._forward = new THREE.Vector3();
        this._right = new THREE.Vector3();
        this._moveDirection = new THREE.Vector3();
        this._upVector = new THREE.Vector3(0, 1, 0);
        
        // --- Event Handlers ---
        this._onSinglePress = this._onSinglePress.bind(this);
        this._onScroll = this._onScroll.bind(this);
    }

    /**
     * Attaches the controller to a specific player entity.
     * @param {Player} player - The player entity to control.
     */
    attach(player) {
        this.player = player;
        // Sync the controller's euler angles with the player's camera on attach
        this.euler.setFromQuaternion(this.player.camera.quaternion);
        this.input.on('singlePress', this._onSinglePress);
        this.input.on('scroll', this._onScroll);
    }

    /**
     * Detaches the controller from the player entity.
     */
    detach() {
        this.input.off('singlePress', this._onSinglePress);
        this.input.off('scroll', this._onScroll);
        this.player = null;
    }

    /**
     * Called every frame to process inputs and update the attached player.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    update(deltaTime) {
        if (!this.player || this.player.isDead || !document.pointerLockElement) {
            if (this.isRightMouseDown) {
                this.player.stopUsingAbility();
                this.isRightMouseDown = false;
            }
            return;
        }

        this._handleLook();
        this._handleMovement(deltaTime);
        this._handleActions();
    }

    /**
     * Processes mouse movement to update the player's view direction.
     */
    _handleLook() {
        const PI_2 = Math.PI / 2;
        this.euler.y -= this.input.mouse.movementX * 0.002;
        this.euler.x -= this.input.mouse.movementY * 0.002;
        this.euler.x = Math.max(-PI_2, Math.min(PI_2, this.euler.x));
        
        this.player.setLookDirection(this.euler);
    }

    /**
     * Processes keyboard inputs for movement, jumping, and dashing.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    _handleMovement(deltaTime) {
        const xInput = (this.input.keys['KeyD'] ? 1 : 0) - (this.input.keys['KeyA'] ? 1 : 0);
        const zInput = (this.input.keys['KeyW'] ? 1 : 0) - (this.input.keys['KeyS'] ? 1 : 0);

        this.player.camera.getWorldDirection(this._forward);
        this._forward.y = 0;
        this._forward.normalize();
        
        // The "right" vector is the cross product of forward and up.
        this._right.crossVectors(this._forward, this._upVector).normalize();

        this._moveDirection.set(0, 0, 0);
        if (zInput) this._moveDirection.add(this._forward.clone().multiplyScalar(zInput));
        if (xInput) this._moveDirection.add(this._right.clone().multiplyScalar(xInput));
        
        if (this._moveDirection.lengthSq() > 0) {
            this._moveDirection.normalize();
        }

        this.player.setMoveDirection(this._moveDirection);
        
        if (this.player.isSwimming) {
            let swimDirection = 0;
            if (this.input.keys['Space']) swimDirection = 1;
            else if (this.input.keys['ShiftLeft']) swimDirection = -1;
            this.player.requestSwim(swimDirection);
            this.player.requestSlam(false);
        } else {
            // Only handle dash and slam on land/in air
            this._handleDashInput();
            if (this.input.keys['ShiftLeft']) {
                this.player.requestSlam(true);
            } else {
                this.player.requestSlam(false);
            }
            // Ensure swim is neutral when not in water
            this.player.requestSwim(0);
        }
    }

    /**
     * Checks for double-tap inputs to trigger a dash.
     */
    _handleDashInput() {
        const now = performance.now();
        ['KeyW', 'KeyA', 'KeyS', 'KeyD'].forEach(key => {
            const isPressed = this.input.keys[key];
            if (isPressed && !this.keyPreviousState[key]) {
                if (now - (this.keyLastPress[key] || 0) < GAME_CONFIG.PLAYER.DOUBLE_TAP_WINDOW) {
                    // Pass the current intended move direction to the dash function
                    this.player.dash(this._moveDirection);
                }
                this.keyLastPress[key] = now;
            }
            this.keyPreviousState[key] = isPressed;
        });
    }
    
    _onSinglePress(event) {
        if (!this.player || this.player.isDead || !document.pointerLockElement) return;
        
        if (event.code === 'Space') {
            // Let the MovementSystem decide what a jump means based on state (land vs water)
            this.player.jump();
        }
        
        if (event.code === 'KeyR') {
            this.player.reloadWeapon();
        }

        if (event.code === 'KeyF') {
            this.player.inspectWeapon();
        }
    }

    _onScroll(event) {
        if (!this.player || this.player.isDead || !document.pointerLockElement) return;
    
        // Positive deltaY means scrolling down/forward, negative means up/backward
        const direction = Math.sign(event.deltaY);
        this.player.cycleAbility(direction);
    }

    /**
     * Processes mouse clicks and number keys for attacks and ability selection.
     */
    _handleActions() {
        if (this.input.mouse.leftClick) {
            this.player.weapon?.attack();
        }

        if (this.input.mouse.rightClick) {
            if (!this.isRightMouseDown) {
                // First frame of press
                this.player.startUsingAbility();
                this.isRightMouseDown = true;
            }
        } else {
            if (this.isRightMouseDown) {
                // First frame of release
                this.player.stopUsingAbility();
                this.isRightMouseDown = false;
            }
        }

        for (let i = 1; i <= 4; i++) {
            if (this.input.keys[`Digit${i}`]) {
                this.player.selectAbility(i - 1);
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/client/entities/PlayerController.js ===


=== FILE: src/client/rendering/BulletTracer.js ===
--------------------------------------------------
import * as THREE from 'three';

export class BulletTracer {
    constructor({ scene, weapon, hitPoint }) {
        this.scene = scene;
        this.lifetime = 0.2; // Very short-lived
        this.elapsedTime = 0;

        const startPoint = new THREE.Vector3(0, 0, -0.27);
        weapon.mesh.localToWorld(startPoint);
        
        const distance = startPoint.distanceTo(hitPoint);
        const direction = new THREE.Vector3().subVectors(hitPoint, startPoint).normalize();
        
        const material = new THREE.MeshBasicMaterial({ color: 0xffffaf, transparent: true, opacity: 0.8 });
        const geometry = new THREE.CylinderGeometry(0.01, 0.01, distance, 4);
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(startPoint).add(direction.clone().multiplyScalar(distance / 2));
        
        const orientation = new THREE.Matrix4();
        const offsetRotation = new THREE.Matrix4();
        orientation.lookAt(startPoint, hitPoint, new THREE.Object3D().up);
        offsetRotation.makeRotationX(Math.PI / 2);
        orientation.multiply(offsetRotation);
        this.mesh.quaternion.setFromRotationMatrix(orientation);

        this.scene.add(this.mesh);
    }

    update(deltaTime) {
        this.elapsedTime += deltaTime;
        if (this.elapsedTime >= this.lifetime) {
            this.cleanup();
            return false; // Signal to VFXManager to remove
        }
        this.mesh.material.opacity = 1.0 - (this.elapsedTime / this.lifetime);
        return true;
    }

    cleanup() {
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/BulletTracer.js ===


=== FILE: src/client/rendering/CardObject.js ===
--------------------------------------------------
import * as THREE from 'three';
import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
import { ShaderLib } from './shaders/ShaderLib.js';

export class CardObject {
    constructor(cardData, faceMaterial, backMaterial) {
        this.cardData = cardData;
        this.faceMaterial = faceMaterial;
        this.backMaterial = backMaterial;

        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4, metalness: 0.2 });
        const geometry = new RoundedBoxGeometry(1.25, 1.75, 0.02, 5, 0.04);
        this.mesh = new THREE.Mesh(geometry, [
            bodyMaterial, bodyMaterial, bodyMaterial, bodyMaterial,
            this.faceMaterial, this.backMaterial,
        ]);
    }

    static async create(cardData) {
        const [
            vertexShader, fragShaderSource, backVertexShader, backFragmentShader
        ] = await Promise.all([
            fetch('./src/client/rendering/shaders/card.vert').then(res => res.text()),
            fetch('./src/client/rendering/shaders/card.frag').then(res => res.text()),
            fetch('./src/client/rendering/shaders/card_back.vert').then(res => res.text()),
            fetch('./src/client/rendering/shaders/card_back.frag').then(res => res.text())
        ]);
        
        const finalFragmentShader = ShaderLib.noise + '\n' + fragShaderSource;
        const finalBackFragmentShader = ShaderLib.noise + '\n' + backFragmentShader;
        
        const elementMap = { Fire: 0, Water: 1, Air: 2, Earth: 3, Utility: 4 };
        const elementColors = { Fire: new THREE.Color('#FF771A'), Water: new THREE.Color('#00A3FF'), Air: new THREE.Color('#B3FCFC'), Earth: new THREE.Color('#B39159'), Utility: new THREE.Color('#A16BFF'), Default: new THREE.Color('#FFFFFF')};

        const elementId = elementMap[cardData.element] ?? 5;
        const elementColor = elementColors[cardData.element] || elementColors.Default;
        const textTexture = new THREE.CanvasTexture(await this.createTextCanvas(cardData));
        textTexture.wrapS = THREE.ClampToEdgeWrapping;
        textTexture.wrapT = THREE.ClampToEdgeWrapping;

        const faceMaterial = new THREE.ShaderMaterial({ vertexShader, fragmentShader: finalFragmentShader, uniforms: { uTime: { value: 0 }, uElementColor: { value: elementColor }, uElementId: { value: elementId }, uTextTexture: { value: textTexture }}, transparent: true });
        const backMaterial = new THREE.ShaderMaterial({ vertexShader: backVertexShader, fragmentShader: finalBackFragmentShader, uniforms: { uTime: { value: 0 }, uElementColor: { value: elementColor }} });
        
        return new CardObject(cardData, faceMaterial, backMaterial);
    }

    static async createTextCanvas(cardData) {
        const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d'), w = 512, h = 717;
        canvas.width = w; canvas.height = h;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.textAlign = 'center';
        ctx.font = 'bold 50px Poppins'; ctx.textBaseline = 'top'; ctx.fillText(cardData.name, w / 2, 50);
        ctx.textAlign = 'left';
        
        // REWORK: Reduced font size and line height for description
        ctx.font = '26px Poppins';
        this.wrapText(ctx, cardData.description || '', 60, 480, 400, 32);

        ctx.font = 'bold 32px Poppins'; ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        const statsY = 620;
        this.drawLightningIcon(ctx, 60, statsY + 16);
        ctx.fillText(cardData.energyCost || '0', 90, statsY);
        this.drawClockIcon(ctx, w - 140, statsY + 16);
        ctx.textAlign = 'right';
        ctx.fillText(`${cardData.cooldown || '0'}s`, w - 60, statsY);
        return canvas;
    }

    static wrapText(ctx, text, x, y, maxW, lineH) {
        const words = text.split(' '); let line = '';
        for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            if (ctx.measureText(testLine).width > maxW && n > 0) {
                ctx.fillText(line, x, y); line = words[n] + ' '; y += lineH;
            } else { line = testLine; }
        }
        ctx.fillText(line, x, y);
    }

    static drawLightningIcon(ctx, x, y) {
        ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 3; ctx.beginPath();
        ctx.moveTo(x + 6, y - 12); ctx.lineTo(x - 2, y); ctx.lineTo(x + 4, y); ctx.lineTo(x - 4, y + 12);
        ctx.stroke(); ctx.restore();
    }

    static drawClockIcon(ctx, x, y) {
        ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 3; ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2); ctx.moveTo(x, y); ctx.lineTo(x, y - 6); ctx.moveTo(x, y); ctx.lineTo(x + 4, y);
        ctx.stroke(); ctx.restore();
    }
    
    update(deltaTime) {
        if (this.faceMaterial) this.faceMaterial.uniforms.uTime.value += deltaTime;
        if (this.backMaterial) this.backMaterial.uniforms.uTime.value += deltaTime;
    }

    dispose() {
        this.mesh.geometry.dispose();
        if (this.faceMaterial) {
            this.faceMaterial.uniforms.uTextTexture.value?.dispose();
            this.faceMaterial.dispose();
        }
        this.backMaterial?.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/CardObject.js ===


=== FILE: src/client/rendering/CardParticleSystem.js ===
--------------------------------------------------
import * as THREE from 'three';

// Asynchronously load shaders once at the module level
const vertexShaderPromise = fetch('./src/client/rendering/shaders/gpu_particle.vert').then(res => res.text());
const fragmentShaderPromise = fetch('./src/client/rendering/shaders/gpu_particle.frag').then(res => res.text());

export class CardParticleSystem {
    constructor(scene, element) {
        this.scene = scene;
        this.element = element;
        this.isStreamType = ['Air', 'Water'].includes(this.element);
        this.isReady = false;
        this.points = null;
        this.streamGroup = null;

        this.init();
    }

    async init() {
        if (this.isStreamType) {
            this.initStreamSystem();
        } else {
            await this.initPointSystem();
        }
        this.isReady = true;
    }

    initStreamSystem() {
        this.streamGroup = new THREE.Group();
        this.streams = [];
        const streamMaterial = new THREE.MeshBasicMaterial({ map: this.createStreamTexture(), blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, color: this.element === 'Air' ? 0xB3FCFC : 0x00A3FF });
        const streamGeometry = new THREE.PlaneGeometry(1, 1);
        for (let i = 0; i < 50; i++) {
            const streamMesh = new THREE.Mesh(streamGeometry, streamMaterial.clone());
            streamMesh.userData.velocity = new THREE.Vector3();
            streamMesh.userData.phase = Math.random() * Math.PI * 2;
            this.initStreamParticle(streamMesh);
            this.streams.push(streamMesh);
            this.streamGroup.add(streamMesh);
        }
        this.scene.add(this.streamGroup);
    }
    
    async initPointSystem() {
        this.particleCount = 150;
        this.respawnCursor = 0;
        const elementColors = { Fire: new THREE.Color('#FF771A'), Earth: new THREE.Color('#B39159'), Utility: new THREE.Color('#A16BFF'), Default: new THREE.Color('#FFFFFF') };
        this.color = elementColors[this.element] || elementColors.Default;
        
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(this.particleCount * 3);
        const velocities = new Float32Array(this.particleCount * 3);
        const lifetimes = new Float32Array(this.particleCount * 4); // maxLifetime, spawnTime, 0, 0

        for (let i = 0; i < this.particleCount; i++) {
            this.initPointParticle(i, 0, positions, velocities, lifetimes);
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
        geometry.setAttribute('aLifetime', new THREE.BufferAttribute(lifetimes, 4));

        const [vertexShader, fragmentShader] = await Promise.all([vertexShaderPromise, fragmentShaderPromise]);
        
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uTexture: { value: this.createPointTexture() },
                uColor: { value: this.color },
                uScale: { value: 2.0 },
                uGravity: { value: new THREE.Vector3(0, 0, 0) } // No gravity for card VFX
            },
            vertexShader,
            fragmentShader,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        this.points = new THREE.Points(geometry, material);
        this.scene.add(this.points);
    }

    initPointParticle(i, currentTime, positions, velocities, lifetimes) {
        const i3 = i * 3;
        const i4 = i * 4;

        positions[i3] = (Math.random() - 0.5) * 2;
        positions[i3 + 1] = (Math.random() - 0.5) * 1.5 - 1.0;
        positions[i3 + 2] = (Math.random() - 0.5) * 0.5;

        velocities[i3] = (Math.random() - 0.5) * 0.1;
        velocities[i3 + 1] = Math.random() * 0.4 + 0.2;
        velocities[i3 + 2] = (Math.random() - 0.5) * 0.1;

        const maxLifetime = Math.random() * 3.0 + 1.0;
        lifetimes[i4] = maxLifetime; // maxLifetime
        lifetimes[i4 + 1] = currentTime + Math.random() * maxLifetime; // spawnTime (staggered)
    }

    initStreamParticle(stream) {
        const lifetime = Math.random() * 3.0 + 2.5;
        stream.userData.lifetime = stream.userData.initialLifetime = lifetime;
        stream.position.set((Math.random() - 0.5) * 4.0, -2.5 + (Math.random() - 0.5), (Math.random() - 0.5) * 2.0);
        stream.scale.set(0.01 + Math.random() * 0.01, 0.8 + Math.random() * 1.0, 1);
        stream.userData.velocity.set((Math.random() - 0.5) * 0.1, 0.3 + Math.random() * 0.3, (Math.random() - 0.5) * 0.05);
        stream.rotation.y = (Math.random() - 0.5) * Math.PI;
    }

    createPointTexture() {
        const canvas = document.createElement('canvas'), size = 64; canvas.width = size; canvas.height = size;
        const context = canvas.getContext('2d'), gradient = context.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
        gradient.addColorStop(0, 'rgba(255,255,255,1)'); gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.6, 'rgba(255,255,255,0.5)'); gradient.addColorStop(1, 'rgba(255,255,255,0)');
        context.fillStyle = gradient; context.fillRect(0, 0, size, size);
        return new THREE.CanvasTexture(canvas);
    }
    
    createStreamTexture() {
        const canvas = document.createElement('canvas'), w = 2, h = 128; canvas.width = w; canvas.height = h;
        const context = canvas.getContext('2d'), gradient = context.createLinearGradient(0, 0, 0, h);
        gradient.addColorStop(0, 'rgba(255,255,255,0)'); gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.8, 'rgba(255,255,255,0.8)'); gradient.addColorStop(1, 'rgba(255,255,255,0)');
        context.fillStyle = gradient; context.fillRect(0, 0, w, h);
        return new THREE.CanvasTexture(canvas);
    }
    
    update(deltaTime) {
        if (!this.isReady) return;

        if (this.isStreamType) {
            for (const stream of this.streams) {
                stream.userData.lifetime -= deltaTime;
                if (stream.userData.lifetime <= 0) this.initStreamParticle(stream);
                stream.position.addScaledVector(stream.userData.velocity, deltaTime);
                stream.position.x += Math.sin(stream.position.y * 0.5 + stream.userData.phase) * 0.008;
                stream.material.opacity = Math.sin((1.0 - (stream.userData.lifetime / stream.userData.initialLifetime)) * Math.PI) * 0.6;
            }
        } else if (this.points) {
            const material = this.points.material;
            const currentTime = material.uniforms.uTime.value += deltaTime;

            const lifetimeAttr = this.points.geometry.attributes.aLifetime;
            const positionAttr = this.points.geometry.attributes.position;
            const velocityAttr = this.points.geometry.attributes.velocity;

            let respawned = 0;
            const particlesToRespawn = 5; // Check a few particles per frame to amortize cost

            for (let i = 0; i < particlesToRespawn; i++) {
                const index = (this.respawnCursor + i) % this.particleCount;
                const maxLifetime = lifetimeAttr.getX(index);
                const spawnTime = lifetimeAttr.getY(index);

                if (currentTime - spawnTime > maxLifetime) {
                    this.initPointParticle(index, currentTime, positionAttr.array, velocityAttr.array, lifetimeAttr.array);
                    respawned++;
                }
            }

            if (respawned > 0) {
                lifetimeAttr.needsUpdate = true;
                positionAttr.needsUpdate = true;
                velocityAttr.needsUpdate = true;
            }

            this.respawnCursor = (this.respawnCursor + particlesToRespawn) % this.particleCount;
        }
    }

    dispose() {
        if (this.isStreamType) {
            if (this.streamGroup) {
                if (this.streams.length > 0) {
                    this.streams[0].geometry.dispose();
                    this.streams[0].material.map.dispose();
                }
                this.streams.forEach(stream => stream.material.dispose());
                this.scene.remove(this.streamGroup);
            }
        } else if (this.points) {
            this.scene.remove(this.points);
            this.points.geometry.dispose();
            this.points.material.uniforms.uTexture.value.dispose();
            this.points.material.dispose();
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/CardParticleSystem.js ===


=== FILE: src/client/rendering/EnemyProjectileVisual.js ===
--------------------------------------------------
// src/client/rendering/EnemyProjectileVisual.js

import * as THREE from 'three';

/**
 * Manages the visual representation of an EnemyProjectile.
 * It creates the mesh and syncs its position with the logical entity's physics body.
 */
export class EnemyProjectileVisual {
    constructor(entity, scene) {
        this.entity = entity;
        this.scene = scene;

        const geometry = new THREE.SphereGeometry(0.2, 16, 16);
        const material = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 10 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;

        this.light = new THREE.PointLight(0x00ffff, 200, 20, 2);
        this.mesh.add(this.light);
        
        // Link mesh to entity for sync systems
        this.entity.mesh = this.mesh;
        this.mesh.userData.entity = this.entity;

        this.scene.add(this.mesh);
    }

    /**
     * Updates the visual's position to match its physics body.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    update(deltaTime) {
        if (!this.entity || this.entity.isDead || !this.entity.physics?.body) {
            // The logical entity might be removed before the visual.
            // The VFX system will call dispose() shortly.
            return;
        }
        this.mesh.position.copy(this.entity.physics.body.position);
    }

    /**
     * Cleans up Three.js resources when the visual is no longer needed.
     */
    dispose() {
        if (!this.scene) return; // Already disposed

        if (this.entity) {
            this.entity.mesh = null; // Unlink
        }

        this.scene.remove(this.mesh);
        this.mesh.geometry?.dispose();
        this.mesh.material?.dispose();
        this.light?.dispose();
        this.scene = null;
        this.entity = null;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/EnemyProjectileVisual.js ===


=== FILE: src/client/rendering/FireballVisual.js ===
--------------------------------------------------
// src/client/rendering/FireballVisual.js

import * as THREE from 'three';

/**
 * Manages the visual representation of a Fireball projectile.
 */
export class FireballVisual {
    constructor(fireballEntity, scene) {
        this.entity = fireballEntity;
        this.scene = scene;
        
        const geometry = new THREE.SphereGeometry(this.entity.RADIUS, 16, 16);
        const material = new THREE.MeshStandardMaterial({
            color: 0xff8800, emissive: 0xff4400, emissiveIntensity: 5
        });
        this.mesh = new THREE.Mesh(geometry, material);

        this.light = new THREE.PointLight(0xffaa33, 500, 100, 2);
        this.mesh.add(this.light);
        
        // Link mesh to entity for sync systems
        this.entity.mesh = this.mesh;
        this.mesh.userData.entity = this.entity;

        this.scene.add(this.mesh);
    }

    update(deltaTime) {
        if (!this.entity || (this.entity.isDead && this.entity.state === 'TRAVELING')) {
            // Logical entity was removed before visual could react, clean up.
            // The VFXManager will call dispose.
            return;
        }

        switch (this.entity.state) {
            case 'TRAVELING':
                if (this.entity.body) {
                    this.mesh.position.copy(this.entity.body.position);
                }
                break;
            case 'LINGERING':
                this.handleExplosion(deltaTime);
                break;
            case 'SHRINKING': // This state is now implicitly handled by LINGERING's end
                this.handleExplosion(deltaTime);
                break;
        }
    }

    handleExplosion(deltaTime) {
        this.mesh.position.copy(this.entity.aoeBody.position);

        const GROW_DURATION = 0.2;
        const SHRINK_DURATION = 0.5;
        const FINAL_SCALE = 40;

        // Growing phase
        if (this.entity.stateTimer < GROW_DURATION) {
            const progress = this.entity.stateTimer / GROW_DURATION;
            const scale = THREE.MathUtils.lerp(1, FINAL_SCALE, progress);
            this.mesh.scale.setScalar(scale);
            this.light.intensity = THREE.MathUtils.lerp(500, 2000, progress);
        } 
        // Lingering phase (includes shrinking at the end)
        else {
            const lingerTime = this.entity.stateTimer - GROW_DURATION;
            const lingerProgress = lingerTime / this.entity.LINGER_DURATION;
            
            // Pulse effect
            const pulse = Math.sin(lingerTime * Math.PI * 4) * 0.5 + 0.5;
            this.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(8, 12, pulse);
            
            // Shrink in the last part of the linger duration
            const shrinkStartTime = this.entity.LINGER_DURATION - SHRINK_DURATION;
            if (lingerTime > shrinkStartTime) {
                const shrinkProgress = (lingerTime - shrinkStartTime) / SHRINK_DURATION;
                const scale = THREE.MathUtils.lerp(FINAL_SCALE, 0, shrinkProgress);
                this.mesh.scale.setScalar(scale);
                this.light.intensity = THREE.MathUtils.lerp(2000, 0, shrinkProgress);
            } else {
                 this.mesh.scale.setScalar(FINAL_SCALE);
            }
        }
    }
    
    dispose() {
        if (!this.scene) return; // Already disposed

        if (this.entity) {
            this.entity.mesh = null; // Unlink
        }

        this.scene.remove(this.mesh);
        this.mesh.geometry?.dispose();
        this.mesh.material?.dispose();
        this.light?.dispose();
        this.scene = null;
        this.entity = null;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/FireballVisual.js ===


=== FILE: src/client/rendering/FireflyProjectileVisual.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Manages the visual representation of a FireflyProjectile.
 */
export class FireflyProjectileVisual {
    constructor(entity, scene) {
        this.entity = entity;
        this.scene = scene;

        const geometry = new THREE.SphereGeometry(0.15, 8, 8);
        const material = new THREE.MeshStandardMaterial({
            color: 0xffa500,
            emissive: 0xffa500,
            emissiveIntensity: 5,
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = false;
        
        this.light = new THREE.PointLight(0xffa500, 150, 10, 2);
        this.mesh.add(this.light);
        
        this.entity.mesh = this.mesh;
        this.mesh.userData.entity = this.entity;

        this.scene.add(this.mesh);
    }

    update(deltaTime) {
        if (!this.entity || this.entity.isDead || !this.entity.physics?.body) {
            return;
        }
        // Sync position and rotation from physics body
        this.mesh.position.copy(this.entity.physics.body.position);
        this.mesh.quaternion.copy(this.entity.physics.body.quaternion);
    }

    dispose() {
        if (!this.scene) return;
        if (this.entity) {
            this.entity.mesh = null;
        }
        this.scene.remove(this.mesh);
        this.mesh.geometry?.dispose();
        this.mesh.material?.dispose();
        this.light?.dispose();
        this.scene = null;
        this.entity = null;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/FireflyProjectileVisual.js ===


=== FILE: src/client/rendering/Minimap.js ===
--------------------------------------------------
// ~ src/client/rendering/Minimap.js
import * as THREE from 'three';

/**
 * Renders the minimap onto a 2D canvas, showing the player, enemies, allies, and level geometry.
 */
export class Minimap {
    constructor() {
        this.canvas = document.getElementById('minimap-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.size = this.canvas.width;
        this.worldScale = 30.0; // World units from center to edge of map

        // Style configuration
        this.bgColor = 'rgba(10, 10, 10, 0.7)';
        this.borderColor = 'rgba(255, 255, 255, 0.3)';
        this.playerColor = '#2ed573';
        this.enemyColor = '#ff4757';
        this.allyColor = '#4a90e2'; // Blue for allies
        this.objectColor = 'rgba(255, 255, 255, 0.2)';

        // Reusable vector for performance
        this.playerForward = new THREE.Vector3();
    }

    /**
     * Updates and draws the minimap.
     * @param {Player} player The player instance from the game world.
     * @param {NPC[]} npcs Array of NPC instances.
     * @param {Object[]} levelObjects Array of level object instances.
     */
    update(player, npcs, levelObjects) {
        if (!player || player.isDead || !this.ctx) {
            this.ctx?.clearRect(0, 0, this.size, this.size);
            return;
        }

        const playerPos = player.physics.body.position;
        player.camera.getWorldDirection(this.playerForward);
        this.playerForward.y = 0; // Flatten for 2D rotation
        this.playerForward.normalize();

        // Clear and draw background
        this.ctx.clearRect(0, 0, this.size, this.size);
        this.ctx.fillStyle = this.bgColor;
        this.ctx.beginPath();
        this.ctx.arc(this.size / 2, this.size / 2, this.size / 2, 0, Math.PI * 2);
        this.ctx.fill();

        // --- Transformation Setup ---
        const mapRadius = this.size / 2;
        const scale = mapRadius / this.worldScale;
        const rotationAngle = Math.atan2(this.playerForward.x, this.playerForward.z);

        this.ctx.save();
        this.ctx.translate(mapRadius, mapRadius);
        this.ctx.rotate(-rotationAngle); // Rotate canvas opposite to player's rotation

        // --- Draw Level Geometry ---
        this.ctx.fillStyle = this.objectColor;
        for (const obj of levelObjects) {
            if (!obj.mesh || !obj.definition) continue;

            const dx = obj.mesh.position.x - playerPos.x;
            const dz = obj.mesh.position.z - playerPos.z;

            if (Math.sqrt(dx * dx + dz * dz) > this.worldScale * 1.5) continue;

            const width = obj.definition.size[0] * scale;
            const depth = obj.definition.size[2] * scale;

            this.ctx.save();
            this.ctx.translate(dx * scale, -dz * scale);
            if (obj.definition.rotation) {
                this.ctx.rotate(THREE.MathUtils.degToRad(obj.definition.rotation.y || 0));
            }
            this.ctx.fillRect(-width / 2, -depth / 2, width, depth);
            this.ctx.restore();
        }

        // --- Draw NPCs (Enemies and Allies) ---
        for (const npc of npcs) {
            if (npc.isDead || !npc.physics?.body) continue;

            this.ctx.fillStyle = npc.team === 'enemy' ? this.enemyColor : this.allyColor;

            const dx = npc.physics.body.position.x - playerPos.x;
            const dz = npc.physics.body.position.z - playerPos.z;

            if (Math.sqrt(dx * dx + dz * dz) < this.worldScale) {
                this.ctx.beginPath();
                this.ctx.arc(dx * scale, -dz * scale, 4, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.restore(); // Restore context to pre-rotation state

        // --- Draw Player (always at center, facing up) ---
        this.ctx.save();
        this.ctx.translate(mapRadius, mapRadius);
        this.ctx.fillStyle = this.playerColor;
        this.ctx.strokeStyle = '#FFFFFF';
        this.ctx.lineWidth = 1.5;
        this.ctx.beginPath();
        this.ctx.moveTo(0, -8);
        this.ctx.lineTo(6, 6);
        this.ctx.lineTo(-6, 6);
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.restore();

        // --- Draw Border ---
        this.ctx.strokeStyle = this.borderColor;
        this.ctx.lineWidth = 4;
        this.ctx.beginPath();
        this.ctx.arc(mapRadius, mapRadius, mapRadius - 2, 0, Math.PI * 2);
        this.ctx.stroke();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/Minimap.js ===


=== FILE: src/client/rendering/MuzzleFlash.js ===
--------------------------------------------------
import * as THREE from 'three';

export class MuzzleFlash {
    constructor({ scene, weapon, camera }) {
        this.scene = scene;
        this.lifetime = 0.1;
        this.elapsedTime = 0;
        
        const canvas = this.createCanvas();
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true });
        
        this.sprite = new THREE.Sprite(material);
        const scale = 0.4 + Math.random() * 0.2;
        this.sprite.scale.set(scale, scale, 1.0);
        this.sprite.material.rotation = Math.random() * Math.PI * 2;
        
        // Position it at the end of the weapon's barrel
        const barrelEndPosition = new THREE.Vector3(0, 0, -0.27); // Local offset from weapon mesh center
        weapon.mesh.localToWorld(barrelEndPosition);
        this.sprite.position.copy(barrelEndPosition);
        
        camera.add(this.sprite); // Add to camera to ensure it's always in viewmodel space
    }

    createCanvas() {
        const canvas = document.createElement('canvas');
        const size = 128;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
        gradient.addColorStop(0, 'rgba(255, 220, 180, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 180, 50, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 150, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        return canvas;
    }

    update(deltaTime) {
        this.elapsedTime += deltaTime;
        if (this.elapsedTime >= this.lifetime) {
            this.cleanup();
            return false; // Signal to VFXManager to remove
        }
        
        const progress = this.elapsedTime / this.lifetime;
        this.sprite.material.opacity = 1.0 - progress;
        this.sprite.scale.x = this.sprite.scale.y = (1.0 - progress) * 0.6;

        return true;
    }

    cleanup() {
        this.sprite.removeFromParent();
        this.sprite.material.map.dispose();
        this.sprite.material.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/MuzzleFlash.js ===


=== FILE: src/client/rendering/ParticleExplosion.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * A self-contained, programmatic particle explosion effect.
 * Its lifecycle is managed by the VFXManager.
 */
export class ParticleExplosion {
    constructor({ scene, position }) {
        this.scene = scene;
        this.LIFESPAN = 1.2;
        this.elapsedTime = 0;
        
        const particleCount = 200;
        const positions = new Float32Array(particleCount * 3);
        this.velocities = [];

        for (let i = 0; i < particleCount; i++) {
            const vec = new THREE.Vector3(
                Math.random() - 0.5,
                Math.random() - 0.5,
                Math.random() - 0.5
            ).normalize().multiplyScalar(Math.random() * 15 + 5);
            this.velocities.push(vec);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
            color: 0xff8800,
            size: 0.2,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });

        this.points = new THREE.Points(geometry, material);
        this.points.position.copy(position);
        this.scene.add(this.points);
    }

    /**
     * Updates the particle positions and opacity.
     * @param {number} deltaTime - Time elapsed since the last frame.
     * @returns {boolean} `false` if the effect is finished, otherwise `true`.
     */
    update(deltaTime) {
        this.elapsedTime += deltaTime;
        const progress = this.elapsedTime / this.LIFESPAN;

        if (progress >= 1) {
            this.cleanup();
            return false; // Signal to VFXManager to remove this effect
        }

        const positions = this.points.geometry.attributes.position.array;
        for (let i = 0; i < this.velocities.length; i++) {
            const i3 = i * 3;
            positions[i3] += this.velocities[i].x * deltaTime;
            positions[i3 + 1] += this.velocities[i].y * deltaTime;
            positions[i3 + 2] += this.velocities[i].z * deltaTime;
        }
        this.points.geometry.attributes.position.needsUpdate = true;
        this.points.material.opacity = 1.0 - progress;
        
        return true; // Effect is still active
    }

    /**
     * Removes the effect's assets from the scene and disposes of them.
     */
    cleanup() {
        this.scene.remove(this.points);
        this.points.geometry.dispose();
        this.points.material.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/ParticleExplosion.js ===


=== FILE: src/client/rendering/VFXManager.js ===
--------------------------------------------------
import { ParticleExplosion } from './ParticleExplosion.js';
import { DamageNumber } from '../ui/DamageNumber.js';
import { FireballVisual } from './FireballVisual.js';
import { EnemyProjectileVisual } from './EnemyProjectileVisual.js';
import { FireflyProjectileVisual } from './FireflyProjectileVisual.js';
import { WaveVFX } from './WaveVFX.js';
import { MuzzleFlash } from './MuzzleFlash.js';
import { BulletTracer } from './BulletTracer.js';
import { WaterfallSplashVFX } from './WaterfallSplashVFX.js';

/**
 * Manages the creation and lifecycle of all visual effects,
 * both DOM-based (CSS animations) and WebGL-based (particles).
 */
export class VFXManager {
    constructor(scene) {
        this.scene = scene;
        this.updatableEffects = [];
        this.entityVisuals = new Map(); // Map<entityId, visualComponent>

        this.domElements = {
            damage: document.getElementById('screen-overlay'),
            dashForward: document.getElementById('vfx-dash-forward'),
            dashSideways: document.getElementById('vfx-dash-sideways'),
            jump: document.getElementById('vfx-jump-wind'),
            slam: document.getElementById('vfx-ground-slam'),
            earthBuff: document.getElementById('vfx-earth-buff'),
            channelingGlow: document.getElementById('vfx-channeling-glow'),
        };
        this.setupVFXListeners();
    }

    /**
     * Adds 'animationend' listeners to automatically clean up CSS classes
     * after a DOM-based animation completes.
     */
    setupVFXListeners() {
        Object.values(this.domElements).forEach(element => {
            if (element) {
                element.addEventListener('animationend', () => {
                    // Don't remove 'active' from sustained effects like buffs or glows
                    const sustainedEffects = ['vfx-earth-buff', 'vfx-channeling-glow'];
                    if (!sustainedEffects.includes(element.id)) {
                        element.classList.remove('active', 'right-to-left', 'left-to-right');
                    }
                });
            }
        });
    }

    /**
     * Triggers a DOM-based visual effect by adding CSS classes to an element.
     * @param {string} elementName - The key for the DOM element (e.g., 'damage', 'dashForward').
     * @param {...string} classes - Additional classes to add, like 'left-to-right'.
     */
    trigger(elementName, ...classes) {
        const element = this.domElements[elementName];
        if (!element) return;
        
        // This pattern reliably restarts a CSS animation
        element.classList.remove('active', 'right-to-left', 'left-to-right');
        void element.offsetWidth; // Force browser reflow
        element.classList.add('active', ...classes);
    }
    
    /**
     * Creates a new particle explosion effect at a given position.
     * @param {THREE.Vector3} position - The world position for the explosion.
     */
    createParticleExplosion(position) {
        const explosion = new ParticleExplosion({ scene: this.scene, position });
        this.updatableEffects.push(explosion);
    }

    createWaterfallSplashVFX(data) {
        const splashVFX = new WaterfallSplashVFX(this.scene, data);
        this.updatableEffects.push(splashVFX);
        return splashVFX;
    }

    /**
     * Creates a new wave visual effect.
     * @param {object} data - Data for the effect.
     * @param {THREE.Vector3} data.position - The starting position.
     * @param {THREE.Vector3} data.direction - The direction the wave travels.
     */
    createWaveEffect(data) {
        const wave = new WaveVFX(this.scene, data.position, data.direction);
        this.updatableEffects.push(wave);
    }

    /**
     * Creates a new damage number effect at a given position.
     * @param {object} data - The data for the damage number.
     * @param {THREE.Vector3} data.position - The world position for the effect.
     * @param {string} data.text - The text to display.
     */
    createDamageNumber({ position, text }) {
        const damageNumber = new DamageNumber({ scene: this.scene, position, text });
        this.updatableEffects.push(damageNumber);
    }
    
    /**
     * Creates muzzle flash and tracer effects for a weapon firing.
     * @param {object} data
     */
    createWeaponFireVFX({ weapon, hitPoint, camera }) {
        const muzzleFlash = new MuzzleFlash({ scene: this.scene, weapon, camera });
        this.updatableEffects.push(muzzleFlash);
        const tracer = new BulletTracer({ scene: this.scene, weapon, hitPoint });
        this.updatableEffects.push(tracer);
    }

    /**
     * Activates a sustained DOM-based visual effect by adding a CSS class.
     * @param {string} elementName - The key for the DOM element.
     */
    activateSustained(elementName) {
        const element = this.domElements[elementName];
        if (element && !element.classList.contains('active')) {
            element.classList.add('active');
        }
    }

    /**
     * Deactivates a sustained DOM-based visual effect by removing a CSS class.
     * @param {string} elementName - The key for the DOM element.
     */
    deactivateSustained(elementName) {
        const element = this.domElements[elementName];
        if (element) {
            element.classList.remove('active');
        }
    }

    createVisualForEntity(entity) {
        if (this.entityVisuals.has(entity.id)) return;

        let visual = null;
        switch (entity.constructor.name) {
            case 'Fireball':
                visual = new FireballVisual(entity, this.scene);
                break;
            case 'EnemyProjectile':
                visual = new EnemyProjectileVisual(entity, this.scene);
                break;
            case 'FireflyProjectile':
                visual = new FireflyProjectileVisual(entity, this.scene);
                break;
        }


        if (visual) {
            this.entityVisuals.set(entity.id, visual);
        }
    }

    removeVisualForEntity(entityId) {
        if (this.entityVisuals.has(entityId)) {
            const visual = this.entityVisuals.get(entityId);
            if (visual.dispose) {
                visual.dispose();
            }
            this.entityVisuals.delete(entityId);
        }
    }

    /**
     * Updates all active programmatic effects and removes any that have finished.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    update(deltaTime) {
        // Loop backwards to allow for safe removal of elements from the array
        for (let i = this.updatableEffects.length - 1; i >= 0; i--) {
            const effect = this.updatableEffects[i];
            const isAlive = effect.update(deltaTime);
            if (!isAlive) {
                this.updatableEffects.splice(i, 1);
            }
        }

        // Update persistent entity visuals
        for (const visual of this.entityVisuals.values()) {
            if (visual.update) {
                visual.update(deltaTime);
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/VFXManager.js ===


=== FILE: src/client/rendering/WaterfallSplashVFX.js ===
--------------------------------------------------
import * as THREE from 'three';

const vertexShaderPromise = fetch('./src/client/rendering/shaders/gpu_particle.vert').then(res => res.text());
const fragmentShaderPromise = fetch('./src/client/rendering/shaders/gpu_particle.frag').then(res => res.text());

export class WaterfallSplashVFX {
    constructor(scene, { position, size, normal = new THREE.Vector3(0, 1, 0) }) {
        this.scene = scene;
        this.size = size;
        this.particleCount = 0;
        this.points = null;
        this.isReady = false;
        this.respawnCursor = 0;

        this.init(position, normal);
    }

    async init(position, normal) {
        const particleDensity = 100; // particles per square meter, reduced for performance
        this.particleCount = Math.max(30, Math.floor(particleDensity * this.size.x * this.size.z));

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(this.particleCount * 3);
        const velocities = new Float32Array(this.particleCount * 3);
        const lifetimes = new Float32Array(this.particleCount * 4); // maxLifetime, spawnTime, 0, 0

        for (let i = 0; i < this.particleCount; i++) {
            this.initParticle(i, 0, positions, velocities, lifetimes, this.size);
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
        geometry.setAttribute('aLifetime', new THREE.BufferAttribute(lifetimes, 4));

        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.4, 'rgba(200,220,255,0.7)');
        gradient.addColorStop(1, 'rgba(150,200,255,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        const texture = new THREE.CanvasTexture(canvas);

        const worldGravity = new THREE.Vector3(0, -9.82 * 0.5, 0);
        const localGravity = worldGravity.clone().applyQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal).invert());
        
        const [vertexShader, fragmentShader] = await Promise.all([vertexShaderPromise, fragmentShaderPromise]);

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uTexture: { value: texture },
                uColor: { value: new THREE.Color(0xeeeeff) },
                uScale: { value: 2.5 },
                uGravity: { value: localGravity }
            },
            vertexShader,
            fragmentShader,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
        });

        this.points = new THREE.Points(geometry, material);
        this.points.position.copy(position);
        this.points.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal.normalize());
        
        this.scene.add(this.points);
        this.isReady = true;
    }

    initParticle(i, currentTime, positions, velocities, lifetimes, size) {
        const i3 = i * 3;
        const i4 = i * 4;
        
        positions[i3] = (Math.random() - 0.5) * size.x;
        positions[i3 + 1] = 0;
        positions[i3 + 2] = (Math.random() - 0.5) * size.z;

        const upwardVelocity = Math.random() * 2.5 + 0.5;
        const scatter = new THREE.Vector3(
            (Math.random() - 0.5) * 0.8,
            upwardVelocity,
            (Math.random() - 0.5) * 0.8
        );

        velocities[i3] = scatter.x;
        velocities[i3 + 1] = scatter.y;
        velocities[i3 + 2] = scatter.z;
        
        const maxLifetime = Math.random() * 2.0 + 0.5;
        lifetimes[i4] = maxLifetime; // maxLifetime
        lifetimes[i4 + 1] = currentTime + Math.random() * maxLifetime; // spawnTime
    }

    update(deltaTime) {
        if (!this.isReady || !this.points) return true;

        const material = this.points.material;
        const currentTime = material.uniforms.uTime.value += deltaTime;

        const lifetimeAttr = this.points.geometry.attributes.aLifetime;
        const positionAttr = this.points.geometry.attributes.position;
        const velocityAttr = this.points.geometry.attributes.velocity;

        let respawned = 0;
        const particlesToRespawn = Math.ceil(this.particleCount * 0.05); // Respawn 5% of particles per frame

        for (let i = 0; i < particlesToRespawn; i++) {
            const index = (this.respawnCursor + i) % this.particleCount;
            const maxLifetime = lifetimeAttr.getX(index);
            const spawnTime = lifetimeAttr.getY(index);

            if (currentTime - spawnTime > maxLifetime) {
                this.initParticle(index, currentTime, positionAttr.array, velocityAttr.array, lifetimeAttr.array, this.size);
                respawned++;
            }
        }

        if (respawned > 0) {
            lifetimeAttr.needsUpdate = true;
            positionAttr.needsUpdate = true;
            velocityAttr.needsUpdate = true;
        }

        this.respawnCursor = (this.respawnCursor + particlesToRespawn) % this.particleCount;
        
        return true; // Never self-destructs
    }

    dispose() {
        if (!this.points) return;
        this.scene.remove(this.points);
        this.points.geometry.dispose();
        this.points.material.uniforms.uTexture.value.dispose();
        this.points.material.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/WaterfallSplashVFX.js ===


=== FILE: src/client/rendering/WaveVFX.js ===
--------------------------------------------------
// src/client/rendering/WaveVFX.js
import * as THREE from 'three';
import { GAME_CONFIG } from '../../shared/config.js';

// Asynchronously load shaders once
const vertexShaderPromise = fetch('./src/client/rendering/shaders/wave.vert').then(res => res.text());
const fragmentShaderPromise = fetch('./src/client/rendering/shaders/wave.frag').then(res => res.text());

export class WaveVFX {
    constructor(scene, position, direction) {
        this.scene = scene;
        this.lifetime = 1.0;
        this.elapsedTime = 0;
        this.isReady = false;

        this.init(position, direction);
    }

    async init(position, direction) {
        const config = GAME_CONFIG.WAVE_POWER;
        
        // Geometry is in XY plane by default. Animation (using vUv.y) runs along its height (local Y).
        const geometry = new THREE.PlaneGeometry(config.WIDTH, config.LENGTH, 20, 20);
        // Rotate the geometry itself so it lies flat on the XZ plane.
        // The original local Y-axis now points along the world +Z axis.
        geometry.rotateX(-Math.PI / 2);

        const vertexShader = await vertexShaderPromise;
        const fragmentShader = await fragmentShaderPromise;

        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uProgress: { value: 0 },
                uColor: { value: new THREE.Color(0x00A3FF) },
                uLength: { value: config.LENGTH }
            },
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        this.mesh = new THREE.Mesh(geometry, material);
        
        // Position the mesh's center so its back edge starts at the player.
        this.mesh.position.copy(position).add(direction.clone().multiplyScalar(config.LENGTH / 2));

        // The animation is reversed in the shader to move along local -Z.
        // We align the mesh's local -Z axis with the world 'direction' vector.
        const animationDirectionLocal = new THREE.Vector3(0, 0, -1);
        this.mesh.quaternion.setFromUnitVectors(animationDirectionLocal, direction.clone().setY(0).normalize());
        
        this.scene.add(this.mesh);
        this.isReady = true;
    }

    update(deltaTime) {
        if (!this.isReady) return true;

        this.elapsedTime += deltaTime;
        if (this.elapsedTime >= this.lifetime) {
            this.cleanup();
            return false;
        }
        
        const progress = this.elapsedTime / this.lifetime;
        this.mesh.material.uniforms.uTime.value = this.elapsedTime;
        this.mesh.material.uniforms.uProgress.value = progress;

        return true;
    }

    cleanup() {
        if (!this.mesh) return;
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.mesh = null;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/WaveVFX.js ===


=== FILE: src/client/rendering/shaders/card.frag ===
--------------------------------------------------
uniform float uTime;
uniform vec3 uElementColor;
uniform int uElementId; // 0:Fire, 1:Water, 2:Air, 3:Earth, 4:Utility
uniform sampler2D uTextTexture;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vViewDirection;

// Note: The noise function is prepended in CardObject.js

#define PI 3.14159265359

float circleSDF(vec2 p, float r) { return length(p) - r; }
float boxSDF(vec2 p, vec2 b) { vec2 d = abs(p) - b; return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0); }
float lineSDF(vec2 p, vec2 a, vec2 b) { vec2 pa = p - a, ba = b - a; float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0); return length(pa - ba * h); }

mat2 rotate2d(float angle) { return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); }
float opUnion(float d1, float d2) { return min(d1, d2); }
float opSubtraction(float d1, float d2) { return max(-d1, d2); }

float fireSigil(vec2 p) {
    p.y -= 0.1; float finalShape = 1.0;
    for(int i = 0; i < 3; i++) {
        float angle = (float(i) / 3.0) * (2.0 * PI) + uTime * 0.5;
        vec2 rp = p * rotate2d(angle); rp.y -= 0.35;
        float flame = opUnion(opUnion(circleSDF(rp, 0.08), boxSDF(rp - vec2(0.0, 0.1), vec2(0.02, 0.1))), circleSDF(rp - vec2(0.0, 0.25), 0.03));
        finalShape = opUnion(finalShape, flame);
    }
    return finalShape;
}
float waterSigil(vec2 p) {
    float wave1 = p.y + sin(p.x * 5.0 + uTime * 2.0) * 0.1 - 0.2;
    float wave2 = p.y + cos(p.x * 4.0 - uTime * 1.5) * 0.1;
    float wave3 = p.y + sin(p.x * 6.0 + uTime * 1.0) * 0.1 + 0.2;
    float d = 1.0; d = opUnion(d, abs(wave1) - 0.02); d = opUnion(d, abs(wave2) - 0.02); d = opUnion(d, abs(wave3) - 0.02);
    d = max(d, abs(p.x) - 0.4); d = max(d, abs(p.y) - 0.4);
    return d;
}
float airSigil(vec2 p) {
    float d = 1.0;
    for(int i = 0; i < 5; i++) {
        float fi = float(i); float t = uTime * 0.3 + fi * 0.5; vec2 lp = p * rotate2d(t * 2.0);
        lp.x -= (sin(t) + 1.0) * 0.2;
        d = opUnion(d, boxSDF(lp, vec2(0.2, 0.01)));
    }
    return d;
}

// REWORK: Replaced with an additive construction of four independently trembling squares.
float earthSigil(vec2 p) {
    vec2 b = vec2(0.08); // half-width of each square
    float c = 0.2;       // center offset for each square
    float trembleAmount = 0.02;

    // Unique 2D noise offsets for each square's center
    vec2 offset1 = (vec2(cnoise(vec2(uTime * 5.0, 1.0)), cnoise(vec2(uTime * 5.0, 1.5))) - 0.5) * trembleAmount;
    vec2 offset2 = (vec2(cnoise(vec2(uTime * 5.0, 2.0)), cnoise(vec2(uTime * 5.0, 2.5))) - 0.5) * trembleAmount;
    vec2 offset3 = (vec2(cnoise(vec2(uTime * 5.0, 3.0)), cnoise(vec2(uTime * 5.0, 3.5))) - 0.5) * trembleAmount;
    vec2 offset4 = (vec2(cnoise(vec2(uTime * 5.0, 4.0)), cnoise(vec2(uTime * 5.0, 4.5))) - 0.5) * trembleAmount;

    float d1 = boxSDF(p - (vec2(c, c) + offset1), b);
    float d2 = boxSDF(p - (vec2(-c, c) + offset2), b);
    float d3 = boxSDF(p - (vec2(-c, -c) + offset3), b);
    float d4 = boxSDF(p - (vec2(c, -c) + offset4), b);

    return min(min(d1, d2), min(d3, d4));
}

float utilitySigil(vec2 p) {
    p *= rotate2d(uTime * 0.2); float d = 1.0;
    for(int i=0; i<6; i++) { d = opUnion(d, lineSDF(p * rotate2d(float(i) * PI / 3.0), vec2(0.0), vec2(0.3, 0.0)) - 0.02); }
    return opSubtraction(d, circleSDF(p, 0.15));
}

void main() {
    vec2 p = vUv * 2.0 - 1.0; p.y *= 1.75 / 1.25;
    float noise = cnoise(vUv * vec2(3.0, 4.0) + uTime * 0.1);
    vec3 bgColor = mix(vec3(0.05, 0.06, 0.08), uElementColor * 0.5, smoothstep(0.3, 1.0, noise));

    vec2 sigilP = p; sigilP.y -= 0.2;
    float d;
    if (uElementId == 0) d = fireSigil(sigilP);
    else if (uElementId == 1) d = waterSigil(sigilP);
    else if (uElementId == 2) d = airSigil(sigilP);
    else if (uElementId == 3) d = earthSigil(sigilP);
    else if (uElementId == 4) d = utilitySigil(sigilP);
    else d = circleSDF(sigilP, 0.2);

    vec3 sigilColor = uElementColor * 1.5;
    float sigil = 1.0 - smoothstep(-0.01, 0.01, d);
    float glow = (1.0 - smoothstep(-0.1, 0.1, d)) * (sin(uTime * 2.0) * 0.2 + 0.8);
    vec3 finalColor = mix(mix(bgColor, sigilColor * 0.2, glow), sigilColor, sigil);

    vec4 textColor = texture2D(uTextTexture, vUv);
    finalColor = mix(finalColor, textColor.rgb, textColor.a);
    finalColor += pow(1.0 - dot(vNormal, vViewDirection), 3.0) * uElementColor * 0.3;
    gl_FragColor = vec4(finalColor, 1.0);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/card.frag ===


=== FILE: src/client/rendering/shaders/card.vert ===
--------------------------------------------------
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vViewDirection;

void main() {
    vUv = uv;
    vNormal = normalize(normalMatrix * normal);
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    vViewDirection = normalize(cameraPosition - worldPosition.xyz);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/card.vert ===


=== FILE: src/client/rendering/shaders/card_back.frag ===
--------------------------------------------------
uniform float uTime;
uniform vec3 uElementColor;
varying vec2 vUv;

// Note: The noise function is prepended in CardObject.js

void main() {
    float flowingNoise = cnoise(vUv * vec2(1.5, 6.0) + vec2(0.0, uTime * -0.15));
    float bands = smoothstep(0.4, 0.6, flowingNoise);
    vec3 baseColor = vec3(0.08, 0.09, 0.12);
    vec3 finalColor = mix(baseColor, uElementColor * 0.7, bands);
    float borderX = smoothstep(0.0, 0.15, vUv.x) * smoothstep(1.0, 0.85, vUv.x);
    float borderY = smoothstep(0.0, 0.15, vUv.y) * smoothstep(1.0, 0.85, vUv.y);
    float border = borderX * borderY;
    finalColor = mix(uElementColor * 0.2, finalColor, border);
    gl_FragColor = vec4(finalColor, 1.0);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/card_back.frag ===


=== FILE: src/client/rendering/shaders/card_back.vert ===
--------------------------------------------------
varying vec2 vUv;

void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/card_back.vert ===


=== FILE: src/client/rendering/shaders/gpu_particle.frag ===
--------------------------------------------------
uniform sampler2D uTexture;
uniform vec3 uColor;

varying float vAlpha;

void main() {
    if (vAlpha <= 0.0) discard;

    vec4 texColor = texture2D(uTexture, gl_PointCoord);
    if (texColor.a < 0.1) discard;

    gl_FragColor = vec4(uColor, vAlpha * texColor.a);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/gpu_particle.frag ===


=== FILE: src/client/rendering/shaders/gpu_particle.vert ===
--------------------------------------------------
uniform float uTime;
uniform float uScale;
uniform vec3 uGravity;

attribute vec3 velocity;
attribute vec4 aLifetime; // x: maxLifetime, y: spawnTime

varying float vAlpha;

void main() {
    float maxLifetime = aLifetime.x;
    float spawnTime = aLifetime.y;

    float timeAlive = uTime - spawnTime;

    // If particle is "dead" or not yet born, hide it.
    if (timeAlive > maxLifetime || timeAlive < 0.0) {
        vAlpha = 0.0;
        gl_Position = vec4(1000.0, 1000.0, 1000.0, 1.0); // Move off-screen
        return;
    }
    
    // Standard kinematic equation for position under constant acceleration (gravity)
    vec3 newPosition = position + velocity * timeAlive + 0.5 * uGravity * timeAlive * timeAlive;
    
    vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
    
    // Set point size based on distance to camera
    gl_PointSize = uScale * (1.0 - (timeAlive / maxLifetime)) * (300.0 / -mvPosition.z);
    gl_Position = projectionMatrix * mvPosition;

    // Fade out over lifetime
    vAlpha = 1.0 - (timeAlive / maxLifetime);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/gpu_particle.vert ===


=== FILE: src/client/rendering/shaders/ShaderLib.js ===
--------------------------------------------------
export const ShaderLib = {
    noise: `
    // Classic Perlin 2D Noise by Stefan Gustavson
    vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
    vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
    float cnoise(vec2 P){
        vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
        vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
        Pi = permute(Pi);
        vec4 ix = Pi.xzxz;
        vec4 iy = Pi.yyww;
        vec4 fx = Pf.xzxz;
        vec4 fy = Pf.yyww;
        vec4 i = permute(permute(ix) + iy);
        vec4 gx = 2.0 * fract(i * (1.0 / 41.0)) - 1.0;
        vec4 gy = abs(gx) - 0.5;
        vec4 tx = floor(gx + 0.5);
        gx = gx - tx;
        vec2 g00 = vec2(gx.x,gy.x);
        vec2 g10 = vec2(gx.y,gy.y);
        vec2 g01 = vec2(gx.z,gy.z);
        vec2 g11 = vec2(gx.w,gy.w);
        vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
        g00 *= norm.x;
        g01 *= norm.y;
        g10 *= norm.z;
        g11 *= norm.w;
        float n00 = dot(g00, vec2(fx.x, fy.x));
        float n10 = dot(g10, vec2(fx.y, fy.y));
        float n01 = dot(g01, vec2(fx.z, fy.z));
        float n11 = dot(g11, vec2(fx.w, fy.w));
        vec2 fade_xy = fade(Pf.xy);
        vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
        float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
        return 2.3 * n_xy;
    }
    `
};
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/ShaderLib.js ===


=== FILE: src/client/rendering/shaders/sigil.frag ===
--------------------------------------------------
// + src/client/rendering/shaders/sigil.frag
precision mediump float;

uniform vec3 uElementColor;
uniform int uElementId; // 0:Fire, 1:Water, 2:Air, 3:Earth, 4:Utility
varying vec2 vUv;

#define PI 3.14159265359

// SDF (Signed Distance Function) primitives
float circleSDF(vec2 p, float r) { return length(p) - r; }
float boxSDF(vec2 p, vec2 b) { vec2 d = abs(p) - b; return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0); }
float lineSDF(vec2 p, vec2 a, vec2 b) { vec2 pa = p - a; vec2 ba = b - a; float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0); return length(pa - ba * h); }

mat2 rotate2d(float angle) { return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); }
float opUnion(float d1, float d2) { return min(d1, d2); }
float opSubtraction(float d1, float d2) { return max(-d1, d2); }

// Sigil definitions (static versions)
float fireSigil(vec2 p) {
    p.y -= 0.1; float finalShape = 1.0;
    for(int i = 0; i < 3; i++) {
        float angle = (float(i) / 3.0) * (2.0 * PI);
        vec2 rp = p * rotate2d(angle); rp.y -= 0.35;
        float flame = opUnion(opUnion(circleSDF(rp, 0.08), boxSDF(rp - vec2(0.0, 0.1), vec2(0.02, 0.1))), circleSDF(rp - vec2(0.0, 0.25), 0.03));
        finalShape = opUnion(finalShape, flame);
    }
    return finalShape;
}
float waterSigil(vec2 p) {
    float wave1 = p.y + sin(p.x * 5.0) * 0.1 - 0.2;
    float wave2 = p.y + cos(p.x * 4.0) * 0.1;
    float wave3 = p.y + sin(p.x * 6.0) * 0.1 + 0.2;
    float d = 1.0; d = opUnion(d, abs(wave1) - 0.02); d = opUnion(d, abs(wave2) - 0.02); d = opUnion(d, abs(wave3) - 0.02);
    d = max(d, abs(p.x) - 0.4); d = max(d, abs(p.y) - 0.4);
    return d;
}
float airSigil(vec2 p) {
    float d = 1.0;
    for(int i = 0; i < 5; i++) {
        float fi = float(i); float t = fi * 0.5; vec2 lp = p * rotate2d(t * 2.0);
        lp.x -= (sin(t) + 1.0) * 0.2;
        d = opUnion(d, boxSDF(lp, vec2(0.2, 0.01)));
    }
    return d;
}
float earthSigil(vec2 p) { return opSubtraction(opSubtraction(boxSDF(p, vec2(0.25, 0.25)), circleSDF(p, 0.15)), boxSDF(abs(p) - 0.25, vec2(0.05))); }
float utilitySigil(vec2 p) {
    float d = 1.0;
    for(int i=0; i<6; i++) { d = opUnion(d, lineSDF(p * rotate2d(float(i) * PI / 3.0), vec2(0.0), vec2(0.3, 0.0)) - 0.02); }
    return opSubtraction(d, circleSDF(p, 0.15));
}

void main() {
    vec2 p = vUv * 2.0 - 1.0; // Remap UV from [0,1] to [-1,1]
    
    float d;
    if (uElementId == 0) d = fireSigil(p);
    else if (uElementId == 1) d = waterSigil(p);
    else if (uElementId == 2) d = airSigil(p);
    else if (uElementId == 3) d = earthSigil(p);
    else if (uElementId == 4) d = utilitySigil(p);
    else discard; // If no valid ID, pixel is transparent

    float alpha = 1.0 - smoothstep(-0.02, 0.02, d);
    
    if (alpha < 0.01) {
        discard;
    }

    gl_FragColor = vec4(uElementColor, alpha);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/sigil.frag ===


=== FILE: src/client/rendering/shaders/waterfall.frag ===
--------------------------------------------------
// [ ~ src/client/rendering/shaders/waterfall.frag ]
precision mediump float;

uniform float uTime;
uniform sampler2D uFlowTexture;
uniform sampler2D uNoiseTexture;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vViewDirection;

void main() {
    // --- 1. UV & Time Setup ---
    vec2 flowUv1 = vUv * vec2(1.0, 4.0) + vec2(0.0, uTime * 0.8);
    vec2 flowUv2 = vUv * vec2(1.4, 6.0) + vec2(0.0, uTime * 1.3);
    vec2 distortionUv = vUv * 0.5 + vec2(0.0, uTime * 0.05);

    // --- 2. Texture Sampling for Water Flow ---
    float distortion = texture2D(uNoiseTexture, distortionUv).r * 0.05;
    float flow1 = texture2D(uFlowTexture, flowUv1 + distortion).r;
    float flow2 = texture2D(uFlowTexture, flowUv2 - distortion).r;
    
    float mainFlow = smoothstep(0.1, 0.7, flow1 * flow2);

    // --- 3. Foam Calculation ---
    float foamY = smoothstep(0.0, 0.15, vUv.y) + smoothstep(1.0, 0.85, vUv.y);
    vec2 foamUv = vUv * vec2(3.0, 1.0) + vec2(0.0, uTime * 0.4);
    float foamNoise = texture2D(uNoiseTexture, foamUv).r;
    float foam = smoothstep(0.6, 1.0, foamY * foamNoise);

    // --- 4. Color and Alpha Composition ---
    vec3 waterColor = vec3(0.6, 0.75, 0.9);
    vec3 foamColor = vec3(1.0, 1.0, 1.0);
    vec3 finalColor = mix(waterColor, foamColor, foam);

    float alpha = mainFlow * 0.3 + foam * 0.6;
    float edgeFade = smoothstep(0.0, 0.1, vUv.x) * smoothstep(1.0, 0.9, vUv.x);
    
    // --- 5. Fresnel Sheen ---
    // The vNormal is already normalized in the vertex shader.
    float fresnel = pow(1.0 - dot(vNormal, vViewDirection), 2.0);
    float finalAlpha = clamp(alpha * edgeFade + fresnel * 0.2, 0.0, 1.0);

    // --- 6. Final Output ---
    if (finalAlpha < 0.01) {
        discard;
    }
    gl_FragColor = vec4(finalColor, finalAlpha);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/waterfall.frag ===


=== FILE: src/client/rendering/shaders/waterfall.vert ===
--------------------------------------------------
// src/client/rendering/shaders/waterfall.vert
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vViewDirection;

void main() {
    vUv = uv;
    vNormal = normalize(normalMatrix * normal);

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    vViewDirection = normalize(cameraPosition - worldPosition.xyz);
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/waterfall.vert ===


=== FILE: src/client/rendering/shaders/wave.frag ===
--------------------------------------------------
// src/client/rendering/shaders/wave.frag
precision mediump float;

uniform float uTime;
uniform float uProgress;
uniform vec3 uColor;
uniform float uLength;

varying vec2 vUv;

void main() {
    // Wave animation based on UV and time
    float waveSpeed = 8.0;
    float waveFrequency = 10.0;
    float waveHeight = 0.1;

    float wave = sin(vUv.y * waveFrequency - uTime * waveSpeed) * waveHeight;
    wave = smoothstep(0.05, 0.1, wave);

    // Fade effect based on overall progress
    float fadeIn = smoothstep(0.0, 0.2, uProgress);
    float fadeOut = 1.0 - smoothstep(0.7, 1.0, uProgress);
    float alpha = fadeIn * fadeOut;

    // Foam at the front of the wave
    float foamWidth = 0.1;
    // REVERSED: Animate foam from UV.y=1 down to UV.y=0
    float foamPosition = 1.0 - uProgress;
    float foam = smoothstep(foamWidth, 0.0, abs(vUv.y - foamPosition));
    
    vec3 finalColor = uColor * wave + vec3(1.0) * foam;

    gl_FragColor = vec4(finalColor, (wave + foam) * alpha);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/wave.frag ===


=== FILE: src/client/rendering/shaders/wave.vert ===
--------------------------------------------------
// src/client/rendering/shaders/wave.vert
precision mediump float;

uniform float uTime;
uniform float uProgress;
uniform float uLength;

varying vec2 vUv;

void main() {
    vUv = uv;

    vec3 pos = position;

    // REVERSED: Animate wave crest from one end to the other in reverse.
    // The geometry's original Y-axis is now its local Z-axis.
    // pos.z (in local space) corresponds to the original pos.y.
    float waveFront = (1.0 - uProgress) * uLength - (uLength / 2.0);
    float distToFront = pos.z - waveFront;

    // We now check against local z for the displacement height.
    if (distToFront < 1.0 && distToFront > -2.0) {
        // The displacement itself should be on the Y-axis in world space.
        // After rotation, local Y is world Y, so we displace local Y.
        pos.y += sin(distToFront * 3.14159) * 0.5;
    }

    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/wave.vert ===


=== FILE: src/client/systems/VFXSystem.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';

/**
 * Listens for abstract gameplay events from the World and translates them
 * into concrete visual effects using the VFXManager.
 */

export class VFXSystem {
    constructor(world, vfxManager) {
        this.world = world;
        this.vfxManager = vfxManager;
        this.hitFlashTimers = new Map(); // entity -> timer
        this.waterfallEffects = new Map(); // Map<entityId, splashVFX[]>

        // Bind handlers to ensure `this` is correct
        this._onEntityAdded = this._onEntityAdded.bind(this);
        this._onEntityRemoved = this._onEntityRemoved.bind(this);

        this.registerListeners();
    }

    registerListeners() {
        this.world.on('entityAdded', this._onEntityAdded);
        this.world.on('entityRemoved', this._onEntityRemoved);
        this.world.on('entityTookDamage', data => this.onEntityTookDamage(data));
        this.world.on('playerDashed', data => this.onPlayerDashed(data));
        this.world.on('playerJumped', () => this.vfxManager.trigger('jump'));
        this.world.on('playerGroundSlammed', () => this.vfxManager.trigger('slam'));
        this.world.on('projectileDetonated', data => this.onProjectileDetonated(data));
        this.world.on('playerBuffActivated', data => this.onPlayerBuffActivated(data));
        this.world.on('playerBuffDeactivated', data => this.onPlayerBuffDeactivated(data));
        this.world.on('playerChannelingUpdate', data => this.onPlayerChannelingUpdate(data));
        this.world.on('wavePowerUsed', data => this.onWavePowerUsed(data));
        this.world.on('weaponFired', data => this.onWeaponFired(data));
    }

    _onEntityAdded({ entity }) {
        this.vfxManager.createVisualForEntity(entity);

        if (entity.type === 'Waterfall') {
            this.createSplashesForWaterfall(entity);
        }
    }

    _onEntityRemoved({ entity }) {
        this.vfxManager.removeVisualForEntity(entity.id);

        if (entity.type === 'Waterfall' && this.waterfallEffects.has(entity.id)) {
            const splashes = this.waterfallEffects.get(entity.id);
            splashes.forEach(splash => splash.dispose());
            this.waterfallEffects.delete(entity.id);
        }
    }

    createSplashesForWaterfall(waterfall) {
        const world = this.world;
        const physicsWorld = world.physics.world;
        const waterfallMesh = waterfall.mesh;
        const width = waterfall.definition.size[0];
        const height = waterfall.definition.size[1];

        const downVector = new THREE.Vector3(0, -1, 0).applyQuaternion(waterfallMesh.quaternion);
        
        const basePosition = waterfallMesh.position.clone().addScaledVector(downVector, height / 2);
        const baseSplash = this.vfxManager.createWaterfallSplashVFX({
            position: basePosition,
            size: { x: width, y: 1.0, z: 2.0 },
            normal: new THREE.Vector3(0, 1, 0)
        });
        
        const allSplashes = [baseSplash];

        const localX = new THREE.Vector3(1, 0, 0).applyQuaternion(waterfallMesh.quaternion);
        const upVector = new THREE.Vector3(0, 1, 0).applyQuaternion(waterfallMesh.quaternion);
        const numRays = 15;

        for (let i = 0; i < numRays; i++) {
            const horizontalOffset = (i / (numRays - 1) - 0.5) * width;
            const rayStartPoint = waterfallMesh.position.clone()
                .addScaledVector(upVector, height / 2)
                .addScaledVector(localX, horizontalOffset);
            
            const rayEndPoint = rayStartPoint.clone().addScaledVector(downVector, height);

            const raycastResult = new CANNON.RaycastResult();
            physicsWorld.raycastClosest(
                new CANNON.Vec3().copy(rayStartPoint),
                new CANNON.Vec3().copy(rayEndPoint),
                {
                    collisionFilterGroup: COLLISION_GROUPS.PLAYER_PROJECTILE,
                    collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.WATER,
                    skipBackfaces: true
                },
                raycastResult
            );

            if (raycastResult.hasHit) {
                if (raycastResult.hitPointWorld.distanceTo(basePosition) > 1.5) {
                    const hitPoint = new THREE.Vector3().copy(raycastResult.hitPointWorld);
                    const hitNormal = new THREE.Vector3().copy(raycastResult.hitNormalWorld);

                    const intersectionSplash = this.vfxManager.createWaterfallSplashVFX({
                        position: hitPoint,
                        size: { x: width / numRays * 1.5, y: 1.0, z: 1.5 },
                        normal: hitNormal
                    });
                    allSplashes.push(intersectionSplash);
                }
            }
        }
        
        this.waterfallEffects.set(waterfall.id, allSplashes);
    }

    onEntityTookDamage({ entity, amount }) {
        if (!entity || entity.isDead) return;

        const position = entity.physics.body.position.clone();
        position.y += 1.5; // Offset for damage number
        this.vfxManager.createDamageNumber({
            position,
            text: `${Math.floor(amount)}`,
        });

        // Trigger hit flash
        if (entity.mesh?.material) {
            this.hitFlashTimers.set(entity, entity.health.flashDuration);
            if (entity.originalEmissive) {
                entity.mesh.material.emissive.setHex(0xffffff);
            }
        }
        
        if (entity.type === 'player') {
            this.vfxManager.trigger('damage');
        }
    }

    onPlayerDashed({ forwardDot, rightDot }) {
        if (Math.abs(forwardDot) > Math.abs(rightDot)) {
            this.vfxManager.trigger('dashForward');
        } else {
            const directionClass = rightDot > 0 ? 'right-to-left' : 'left-to-right';
            this.vfxManager.trigger('sideways', directionClass);
        }
    }

    onProjectileDetonated({ type, position }) {
        // Here you could switch on `type` for different explosion effects
        this.vfxManager.createParticleExplosion(position);
    }
    
    onWeaponFired(data) {
        this.vfxManager.createWeaponFireVFX({
            ...data,
            camera: this.world.core.renderer.camera
        });
    }

    onPlayerBuffActivated({ buffName }) {
        if (buffName === 'stonePlating') {
            this.vfxManager.activateSustained('earthBuff');
        }
    }

    onPlayerBuffDeactivated({ buffName }) {
        if (buffName === 'stonePlating') {
            this.vfxManager.deactivateSustained('earthBuff');
        }
    }

    onPlayerChannelingUpdate({ isChanneling, ability }) {
        if (ability?.data?.id === 'UTILITY_001') {
            if (isChanneling) {
                this.vfxManager.activateSustained('channelingGlow');
            } else {
                this.vfxManager.deactivateSustained('channelingGlow');
            }
        }
    }

    onWavePowerUsed({ position, direction }) {
        this.vfxManager.createWaveEffect({ position, direction });
    }
    
    update(deltaTime) {
        if (this.hitFlashTimers.size === 0) return;

        for (const [entity, timer] of this.hitFlashTimers.entries()) {
            let newTimer = timer - deltaTime;
            if (newTimer <= 0) {
                if (entity.mesh && entity.originalEmissive) {
                    entity.mesh.material.emissive.copy(entity.originalEmissive);
                }
                this.hitFlashTimers.delete(entity);
            } else {
                const flashProgress = 1 - (newTimer / entity.health.flashDuration);
                if (entity.mesh && entity.originalEmissive) {
                    entity.mesh.material.emissive.lerpColors(new THREE.Color(0xffffff), entity.originalEmissive, flashProgress);
                }
                this.hitFlashTimers.set(entity, newTimer);
            }
        }
    }
    
    dispose() {
        this.world.off('entityAdded', this._onEntityAdded);
        this.world.off('entityRemoved', this._onEntityRemoved);
        
        // Clean up any remaining managed effects
        for (const splashes of this.waterfallEffects.values()) {
            splashes.forEach(splash => splash.dispose());
        }
        this.waterfallEffects.clear();
        this.hitFlashTimers.clear();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/systems/VFXSystem.js ===


=== FILE: src/client/systems/WorldUISystem.js ===
--------------------------------------------------
// ~ src/client/systems/WorldUISystem.js
import { HealthBar } from '../ui/HealthBar.js';

/**
 * Manages 3D UI elements that exist in the world space, like enemy health bars.
 * It listens to world events to create, update, and destroy these UI elements.
 */
export class WorldUISystem {
    constructor(scene) {
        this.scene = scene;
        this.world = null;
        this.healthBars = new Map(); // Map<entity, HealthBar>
    }

    registerWorld(world) {
        if (this.world) {
            this.dispose(); // Clean up listeners from old world
        }
        this.world = world;
        this._onNPCSpawned = this._onNPCSpawned.bind(this);
        this._onNPCDied = this._onNPCDied.bind(this);

        this.world.on('npcSpawned', this._onNPCSpawned);
        this.world.on('npcDied', this._onNPCDied);
    }
    
    _onNPCSpawned({ npc }) {
        // Create health bars for any NPC (enemy or allied).
        // Player entity is not an NPC, so it will be skipped.
        if ((npc.team === 'enemy' || npc.team === 'player') && !this.healthBars.has(npc)) {
            const healthBar = new HealthBar(this.scene, npc.team);
            this.healthBars.set(npc, healthBar);
        }
    }

    _onNPCDied({ entity }) {
        if (this.healthBars.has(entity)) {
            const healthBar = this.healthBars.get(entity);
            healthBar.dispose();
            this.healthBars.delete(entity);
        }
    }

    update(deltaTime) {
        if (!this.world || !this.world.player) return;

        for (const [entity, healthBar] of this.healthBars.entries()) {
            // Guard against entities that might be disposed but not yet removed from the map
            if (!entity.physics?.body) {
                healthBar.setVisible(false);
                continue;
            }

            if (entity.isDead) {
                healthBar.setVisible(false);
                continue;
            }
            
            const position = entity.physics.body.position.clone();
            position.y += (entity.mesh.geometry.parameters.height || 1.0) + 1.0;

            const isVisible = this.world.player.camera.position.distanceTo(position) < 30;
            healthBar.setVisible(isVisible);

            if (isVisible) {
                healthBar.update(position, entity.health.currentHealth, entity.health.maxHealth);
            }
        }
    }
    
    dispose() {
        if (this.world) {
            this.world.off('npcSpawned', this._onNPCSpawned);
            this.world.off('npcDied', this._onNPCDied);
        }
        for (const healthBar of this.healthBars.values()) {
            healthBar.dispose();
        }
        this.healthBars.clear();
        this.world = null;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/systems/WorldUISystem.js ===


=== FILE: src/client/ui/AbilityIconService.js ===
--------------------------------------------------
// src/client/ui/AbilityIconService.js
import * as THREE from 'three';

/**
 * A reusable service for generating and caching 2D icons of ability sigils.
 */
export class AbilityIconService {
    constructor() {
        this.cache = new Map();
        this.renderer = null;
        this.scene = null;
        this.camera = null;
        this.plane = null;
        this.sigilShader = null;
        this.isInitialized = false;
    }

    /**
     * Sets up the offscreen WebGL context for rendering icons.
     * @private
     */
    async _initialize() {
        if (this.isInitialized) return;

        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        this.scene = new THREE.Scene();
        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        this.camera.position.z = 1;
        this.renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });

        this.plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2));
        this.scene.add(this.plane);

        const fragShaderSource = await fetch('./src/client/rendering/shaders/sigil.frag').then(res => res.text());
        this.sigilShader = {
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
            fragmentShader: fragShaderSource,
        };
        
        this.isInitialized = true;
    }

    /**
     * Generates a data URL for a given ability's sigil icon.
     * @param {object} abilityData - The full data object for the ability.
     * @returns {Promise<string|null>} A promise that resolves to the data URL of the icon.
     */
    async generate(abilityData) {
        if (!this.isInitialized) await this._initialize();
        if (!abilityData || !abilityData.id) return null;

        if (this.cache.has(abilityData.id)) {
            return this.cache.get(abilityData.id);
        }

        const elementMap = { Fire: 0, Water: 1, Air: 2, Earth: 3, Utility: 4 };
        const elementColors = { 
            Fire: new THREE.Color(0xFF771A), 
            Water: new THREE.Color(0x00A3FF), 
            Air: new THREE.Color(0xB3FCFC), 
            Earth: new THREE.Color(0xB39159), 
            Utility: new THREE.Color(0xA16BFF), 
            Default: new THREE.Color(0xFFFFFF)
        };

        const elementId = elementMap[abilityData.element] ?? 5;
        const elementColor = elementColors[abilityData.element] || elementColors.Default;

        this.plane.material = new THREE.ShaderMaterial({
            ...this.sigilShader,
            uniforms: {
                uElementId: { value: elementId },
                uElementColor: { value: elementColor },
            },
            transparent: true,
        });

        this.renderer.render(this.scene, this.camera);
        const dataUrl = this.renderer.domElement.toDataURL();
        
        // Clean up the material
        if (this.plane.material.dispose) {
            this.plane.material.dispose();
        }

        this.cache.set(abilityData.id, dataUrl);
        return dataUrl;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/AbilityIconService.js ===


=== FILE: src/client/ui/card_inspector_main.js ===
--------------------------------------------------
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { LoadoutManager } from './LoadoutManager.js';
import { CardObject } from '../rendering/CardObject.js';
import { CardParticleSystem } from '../rendering/CardParticleSystem.js';

class CardInspectorApp {
    constructor() {
        this.manager = new LoadoutManager();
        this.canvas = document.getElementById('inspector-canvas');
        this.scene = new THREE.Scene();
        this.backgroundScene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(50, this.canvas.clientWidth / this.canvas.clientHeight, 0.1, 100);
        this.backgroundCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: true });
        this.clock = new THREE.Clock();
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.activeCardObject = null;
        this.particleSystem = null;
        this.godRayPlane = null;
        this.elements = {
            title: document.getElementById('card-name-title'),
            exitBtn: document.getElementById('exit-btn'),
            prompt: document.getElementById('inspector-prompt'),
        };
    }

    async init() {
        await this.manager.init();
        this.renderer.setSize(this.canvas.parentElement.clientWidth, this.canvas.parentElement.clientHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.camera.position.set(0, 0, 3.5);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);
        const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
        keyLight.position.set(2, 3, 3);
        this.scene.add(keyLight);

        this.controls.enableDamping = true;
        this.controls.enablePan = false;
        this.controls.minDistance = 2;
        this.controls.maxDistance = 6;
        this.controls.target.set(0, 0, 0);

        this.setupEventListeners();
        window.addEventListener('resize', () => this.onResize());

        const urlParams = new URLSearchParams(window.location.search);
        const cardId = urlParams.get('id');

        if (cardId) {
            const cardData = this.manager.getCardDetails(cardId);
            if (cardData) {
                this.elements.title.textContent = cardData.name;
                await this.displayCard(cardData);
            } else {
                this.elements.prompt.textContent = 'Card not found.';
            }
        } else {
            this.elements.prompt.textContent = 'No card specified.';
        }

        this.animate();
    }

    createGodRayPlane(color) {
        if (this.godRayPlane) {
            this.backgroundScene.remove(this.godRayPlane);
            this.godRayPlane.geometry.dispose();
            if(this.godRayPlane.material.map) this.godRayPlane.material.map.dispose();
            this.godRayPlane.material.dispose();
        }

        const canvas = document.createElement('canvas');
        const size = 512;
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        const centerX = size / 2, centerY = size / 2;
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size / 2);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.2)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1.5;
        for(let i=0; i < 100; i++) {
            const angle = Math.random() * Math.PI * 2;
            const length = size * 0.4 + (Math.random() * size * 0.3);
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + Math.cos(angle) * length, centerY + Math.sin(angle) * length);
            ctx.stroke();
        }
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ map: texture, color, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
        this.godRayPlane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
        this.backgroundScene.add(this.godRayPlane);
    }
    
    async displayCard(cardData) {
        if (this.activeCardObject) {
            this.activeCardObject.dispose();
            this.scene.remove(this.activeCardObject.mesh);
        }
        if (this.particleSystem) this.particleSystem.dispose();
        
        this.activeCardObject = await CardObject.create(cardData);
        this.scene.add(this.activeCardObject.mesh);
        this.particleSystem = new CardParticleSystem(this.scene, cardData.element);
        const elementColors = { Fire: '#FF771A', Water: '#00A3FF', Air: '#B3FCFC', Earth: '#B39159', Utility: '#A16BFF' };
        this.createGodRayPlane(elementColors[cardData.element] || '#FFFFFF');
        this.elements.prompt.style.opacity = '0';
    }

    setupEventListeners() {
        this.elements.exitBtn.onclick = () => { window.location.href = 'loadout.html'; };
    }

    onResize() {
        const { clientWidth, clientHeight } = this.canvas.parentElement;
        this.camera.aspect = clientWidth / clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(clientWidth, clientHeight);
    }
    
    animate() {
        requestAnimationFrame(() => this.animate());
        const deltaTime = this.clock.getDelta();
        
        this.controls.update();
        if (this.activeCardObject) this.activeCardObject.update(deltaTime);
        if (this.particleSystem) this.particleSystem.update(deltaTime);
        if (this.godRayPlane) this.godRayPlane.rotation.z += 0.001;
        
        this.renderer.autoClear = false;
        this.renderer.clear();
        this.renderer.render(this.backgroundScene, this.backgroundCamera);
        this.renderer.clearDepth();
        this.renderer.render(this.scene, this.camera);
    }
}

const app = new CardInspectorApp();
app.init().catch(err => {
    console.error("Failed to initialize Card Inspector:", err);
    document.getElementById('inspector-prompt').textContent = 'Error loading. See console.';
});
--------------------------------------------------
=== END OF FILE: src/client/ui/card_inspector_main.js ===


=== FILE: src/client/ui/DamageNumber.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Creates a floating text sprite that displays damage dealt, moves upwards, and fades out.
 * This is a client-side visual effect.
 */
export class DamageNumber {
    constructor({ scene, text, position }) {
        this.scene = scene;

        this.lifetime = 1.0;
        this.elapsedTime = 0;
        this.upwardSpeed = 2.0;

        const canvas = this._createCanvas(text);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;

        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
        this.sprite = new THREE.Sprite(material);
        this.sprite.renderOrder = 1000;
        this.sprite.scale.set(canvas.width / 100, canvas.height / 100, 1.0);
        this.sprite.position.copy(position);
        this.sprite.position.x += (Math.random() - 0.5) * 0.5;

        this.scene.add(this.sprite);
    }

    _createCanvas(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const fontSize = 48;
        context.font = `bold ${fontSize}px Arial`;
        
        const textMetrics = context.measureText(text);
        canvas.width = textMetrics.width + 10;
        canvas.height = fontSize + 10;

        context.font = `bold ${fontSize}px Arial`;
        context.fillStyle = 'rgba(255, 255, 100, 1)';
        context.strokeStyle = 'rgba(0, 0, 0, 1)';
        context.lineWidth = 5;
        context.textAlign = 'center';
        
        const x = canvas.width / 2;
        const y = canvas.height / 2 + fontSize / 3;

        context.strokeText(text, x, y);
        context.fillText(text, x, y);

        return canvas;
    }

    update(deltaTime) {
        this.elapsedTime += deltaTime;
        if (this.elapsedTime >= this.lifetime) {
            this.cleanup();
            return false; // Indicate that this object should be removed
        }

        this.sprite.position.y += this.upwardSpeed * deltaTime;
        this.sprite.material.opacity = 1.0 - (this.elapsedTime / this.lifetime);
        return true; // Still active
    }

    cleanup() {
        this.scene.remove(this.sprite);
        this.sprite.material.map.dispose();
        this.sprite.material.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/DamageNumber.js ===


=== FILE: src/client/ui/HealthBar.js ===
--------------------------------------------------
// ~ src/client/ui/HealthBar.js
import * as THREE from 'three';
import { RENDERING_LAYERS } from '../../shared/CollisionGroups.js';

/**
 * A client-side visual component representing an entity's health.
 * It is positioned and managed by a client-side system.
 */
export class HealthBar {
    constructor(scene, team = 'enemy') {
        this.scene = scene;
        this.team = team;
        
        const healthBarGroup = new THREE.Group();
        // Give the group a high renderOrder so it draws on top of most 3D geometry
        healthBarGroup.renderOrder = 999; 

        // Determine colors based on team
        const bgColor = this.team === 'enemy' ? 0x551111 : 0x112255; // Dark red for enemy, dark blue for ally
        const fgColor = this.team === 'enemy' ? 0xff4757 : 0x4a90e2; // Bright red for enemy, bright blue for ally

        // Background
        const bgMaterial = new THREE.SpriteMaterial({ color: bgColor, sizeAttenuation: false, depthTest: false });
        const bgSprite = new THREE.Sprite(bgMaterial);
        bgSprite.scale.set(0.25, 0.025, 1.0);
        bgSprite.renderOrder = 0; // Render background first
        healthBarGroup.add(bgSprite);

        // Foreground
        const fgMaterial = new THREE.SpriteMaterial({ color: fgColor, sizeAttenuation: false, depthTest: false });
        this.fgSprite = new THREE.Sprite(fgMaterial);
        this.fgSprite.scale.set(0.25, 0.025, 1.0);
        this.fgSprite.renderOrder = 1; // Render foreground on top
        healthBarGroup.add(this.fgSprite);

        this.group = healthBarGroup;
        this.group.layers.enable(RENDERING_LAYERS.NO_REFLECTION);
        this.group.visible = false;
        this.scene.add(this.group);
    }

    update(position, currentHealth, maxHealth) {
        const percent = Math.max(0, currentHealth / maxHealth);
        this.fgSprite.scale.x = 0.25 * percent;
        // Adjust the position of the foreground sprite so it drains from the right
        this.fgSprite.position.x = -0.5 * (0.25 * (1 - percent));
        
        // Color is now set in the constructor and doesn't change based on percentage,
        // which provides a clear and consistent visual language (red=enemy, blue=ally).

        this.group.position.copy(position);
    }

    setVisible(visible) {
        this.group.visible = visible;
    }

    dispose() {
        this.scene.remove(this.group);
        this.fgSprite.material.dispose();
        this.group.children[0].material.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/HealthBar.js ===


=== FILE: src/client/ui/HUD.js ===
--------------------------------------------------
// src/client/ui/HUD.js
import * as THREE from 'three';

/**
 * Manages the DOM elements for the in-game Heads-Up Display.
 * This class is a "dumb" view component, updated by the UIManager.
 */
export class HUD {
    constructor(abilityIconService) {
        this.abilityIconService = abilityIconService;
        this.loadedIconUrls = new Map();

        this.elements = {
            healthBar: document.getElementById('health-bar'),
            energyBar: document.getElementById('energy-bar'),
            oxygenBar: document.getElementById('oxygen-bar'),
            oxygenBarContainer: document.getElementById('oxygen-bar-container'),
            healthText: document.getElementById('health-text'),
            energyText: document.getElementById('energy-text'),
            oxygenText: document.getElementById('oxygen-text'),
            
            jumpCooldownIndicator: document.getElementById('jump-cooldown-indicator'),
            jumpCooldownProgress: document.getElementById('jump-cooldown-indicator')?.querySelector('.cooldown-progress'),
            dashCooldownIndicator: document.getElementById('dash-cooldown-indicator'),
            dashCooldownProgress: document.getElementById('dash-cooldown-indicator')?.querySelector('.cooldown-progress'),

            abilitySlots: Array.from({ length: 4 }, (_, i) => ({
                element: document.getElementById(`ability-${i}`),
                icon: document.getElementById(`ability-${i}`).querySelector('.ability-icon'),
                cooldownRing: document.getElementById(`ability-${i}`).querySelector('.cooldown-ring-circle'),
                currentElementClass: null,
                isFlashing: false, // State to prevent updates during error animation
            })),
            
            targetFrame: document.getElementById('target-frame'),
            crosshair: document.getElementById('crosshair'),
            tutorialContainer: document.getElementById('tutorial-text-container'),
            tutorialText: document.getElementById('tutorial-text'),
            minimapCanvas: document.getElementById('minimap-canvas'),
            enemyCounter: document.getElementById('enemy-counter'),
            ammoCounter: document.getElementById('ammo-counter'),
            ammoMag: document.getElementById('ammo-mag'),
            ammoReserve: document.getElementById('ammo-reserve'),
        };
        
        this.targetVector = new THREE.Vector3();
        this.RING_CIRCUMFERENCE = 100; // For ability slots
        this.HALF_RING_CIRCUMFERENCE = 157; // For movement cooldowns
    }

    updateResources(health, maxHealth, energy, maxEnergy) {
        const healthPercent = (health / maxHealth) * 100;
        this.elements.healthBar.style.width = `${healthPercent}%`;
        this.elements.healthText.textContent = Math.floor(health);

        const energyPercent = (energy / maxEnergy) * 100;
        this.elements.energyBar.style.width = `${energyPercent}%`;
        this.elements.energyText.textContent = Math.floor(energy);
    }

    updateOxygen(current, max) {
        if (!this.elements.oxygenBar) return;
        const oxygenPercent = (current / max) * 100;
        this.elements.oxygenBar.style.width = `${oxygenPercent}%`;
        this.elements.oxygenText.textContent = Math.floor(current);
    }

    updateMovementCooldowns(jumpTimer, jumpCooldown, dashTimer, dashCooldown, isDoubleJumpOnCooldown, isDashOnCooldown) {
        if (this.elements.jumpCooldownIndicator) {
            const jumpProgress = Math.min(jumpTimer / jumpCooldown, 1.0);
            this.elements.jumpCooldownIndicator.classList.toggle('on-cooldown', isDoubleJumpOnCooldown);
            const offset = this.HALF_RING_CIRCUMFERENCE * (1 - jumpProgress);
            this.elements.jumpCooldownProgress.style.strokeDashoffset = offset;
        }

        if (this.elements.dashCooldownIndicator) {
            const dashProgress = Math.min(dashTimer / dashCooldown, 1.0);
            this.elements.dashCooldownIndicator.classList.toggle('on-cooldown', isDashOnCooldown);
            const offset = this.HALF_RING_CIRCUMFERENCE * (1 - dashProgress);
            this.elements.dashCooldownProgress.style.strokeDashoffset = offset;
        }
    }
    
    _applyIconStyle(element, url) {
        element.style.backgroundImage = `url(${url})`;
        element.style.backgroundColor = 'transparent';
        element.innerHTML = '';
    }

    updateAbilities(abilities, selectedIndex) {
        this.elements.abilitySlots.forEach((slotUI, i) => {
            const ability = abilities[i];

            // Safely manage element-specific class without resetting others
            const newElementClass = ability ? `element-${ability.data.element.toLowerCase()}` : null;
            if (slotUI.currentElementClass && slotUI.currentElementClass !== newElementClass) {
                slotUI.element.classList.remove(slotUI.currentElementClass);
            }
            if (newElementClass && !slotUI.element.classList.contains(newElementClass)) {
                slotUI.element.classList.add(newElementClass);
            }
            slotUI.currentElementClass = newElementClass;

            if (ability) {
                if (!this.loadedIconUrls.has(ability.data.id)) {
                    slotUI.icon.innerHTML = '...';
                    this.loadedIconUrls.set(ability.data.id, 'loading');
                    
                    this.abilityIconService.generate(ability.data).then(iconUrl => {
                        if (iconUrl) {
                            this.loadedIconUrls.set(ability.data.id, iconUrl);
                            // Verify the ability in the slot hasn't changed while the icon was loading
                            if (abilities[i]?.data.id === ability.data.id) {
                                this._applyIconStyle(slotUI.icon, iconUrl);
                            }
                        }
                    });
                } else {
                    const iconUrl = this.loadedIconUrls.get(ability.data.id);
                    if (iconUrl && iconUrl !== 'loading') {
                        this._applyIconStyle(slotUI.icon, iconUrl);
                    } else {
                        slotUI.icon.innerHTML = '...';
                    }
                }

                const cooldownProgress = ability.getCooldownProgress();
                const isReady = cooldownProgress >= 1.0;
                slotUI.element.classList.toggle('ready', isReady);

                // Freeze cooldown progress animation during error flash
                if (!slotUI.isFlashing) {
                    const offset = this.RING_CIRCUMFERENCE * (1 - cooldownProgress);
                    slotUI.cooldownRing.style.strokeDashoffset = offset;
                }
            } else {
                slotUI.icon.style.backgroundImage = 'none';
                slotUI.icon.style.backgroundColor = '';
                slotUI.icon.innerHTML = '';
                slotUI.cooldownRing.style.strokeDashoffset = this.RING_CIRCUMFERENCE;
                slotUI.element.classList.remove('ready');
            }
            
            slotUI.element.classList.toggle('selected', i === selectedIndex);
        });
    }

    updateAmmo(weapon) {
        const ammoCounter = this.elements.ammoCounter;
        if (!ammoCounter) return;

        if (weapon && typeof weapon.magazineAmmo !== 'undefined') {
            ammoCounter.style.display = 'block';
            this.elements.ammoMag.textContent = weapon.magazineAmmo;
            this.elements.ammoReserve.textContent = weapon.reserveAmmo;
            ammoCounter.classList.toggle('reloading', weapon.isReloading);
        } else {
            ammoCounter.style.display = 'none';
        }
    }
    
    updateTargeting(isLockOn, target, camera) {
        this.elements.crosshair.style.opacity = isLockOn ? '0.2' : '1';

        if (isLockOn && target && target.physics?.body) {
            const targetPosition = this.targetVector.copy(target.physics.body.position);
            targetPosition.y += (target.mesh.geometry?.parameters?.height || 2) / 2;
            targetPosition.project(camera);
            
            if (targetPosition.z < 1) {
                const x = (targetPosition.x * 0.5 + 0.5) * window.innerWidth;
                const y = (targetPosition.y * -0.5 + 0.5) * window.innerHeight;
                this.elements.targetFrame.style.display = 'block';
                this.elements.targetFrame.style.left = `${x}px`;
                this.elements.targetFrame.style.top = `${y}px`;
                const distance = camera.position.distanceTo(target.physics.body.position);
                const frameSize = Math.max(30, Math.min(150, 4000 / distance));
                this.elements.targetFrame.style.width = `${frameSize}px`;
                this.elements.targetFrame.style.height = `${frameSize}px`;
            } else {
                this.elements.targetFrame.style.display = 'none';
            }
        } else {
            this.elements.targetFrame.style.display = 'none';
        }
    }
    
    updateEnemyCount(killed, total) {
        if (this.elements.enemyCounter) {
            if (total > 0) {
                this.elements.enemyCounter.style.display = 'block';
                this.elements.enemyCounter.textContent = `ENEMIES: ${total - killed}`;
            } else {
                this.elements.enemyCounter.style.display = 'none';
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/HUD.js ===


=== FILE: src/client/ui/LoadoutManager.js ===
--------------------------------------------------
export class LoadoutManager {
    constructor() {
        this.allAbilities = new Map();
        this.playerProfile = null;
        this.activeLoadout = {
            name: 'Default',
            weapon: null,
            cards: [null, null, null, null]
        };
        this.currentSynergy = { isValid: false, synergyName: 'No Synergy', description: 'Fill all slots to see Synergy.' };
    }

    async init() {
        try {
            const [abilitiesResponse, profileResponse] = await Promise.all([
                fetch('./data/abilities.json'),
                fetch('./data/player-profile.json')
            ]);
            const abilitiesData = await abilitiesResponse.json();
            this.playerProfile = await profileResponse.json();

            for (const [id, data] of Object.entries(abilitiesData)) {
                this.allAbilities.set(id, { id, ...data });
            }

            this.switchActiveLoadout(this.playerProfile.activeLoadoutName);

        } catch (error) {
            console.error("Failed to initialize LoadoutManager:", error);
        }
    }

    getCardDetails(cardId) {
        return this.allAbilities.get(cardId);
    }
    
    getInventoryItems(type = 'all') {
        return this.playerProfile.inventory
            .map(id => this.getCardDetails(id))
            .filter(item => {
                if (!item) return false;
                const isEquipped = this.activeLoadout.cards.includes(item.id) || this.activeLoadout.weapon === item.id;
                if (isEquipped) return false;
                
                if (type === 'all') return true;
                return item.type.toLowerCase() === type.toLowerCase();
            });
    }
    
    getActiveLoadoutCards() {
        return this.activeLoadout.cards.map(id => id ? this.getCardDetails(id) : null);
    }

    getActiveWeapon() {
        return this.activeLoadout.weapon ? this.getCardDetails(this.activeLoadout.weapon) : null;
    }
    
    equipCard(cardId, slotIndex) {
        if (!cardId || slotIndex < 0 || slotIndex >= 4) return;
        
        const existingIndex = this.activeLoadout.cards.indexOf(cardId);
        if (existingIndex !== -1) {
            this.activeLoadout.cards[existingIndex] = null;
        }

        this.activeLoadout.cards[slotIndex] = cardId;
        this._checkSynergy();
    }
    
    unequipCard(slotIndex) {
        if (slotIndex >= 0 && slotIndex < this.activeLoadout.cards.length) {
            this.activeLoadout.cards[slotIndex] = null;
        }
        this._checkSynergy();
    }

    equipWeapon(weaponId) {
        this.activeLoadout.weapon = weaponId;
    }

    unequipWeapon() {
        this.activeLoadout.weapon = null;
    }

    swapCards(slotIndexA, slotIndexB) {
        if (slotIndexA < 0 || slotIndexA >= 4 || slotIndexB < 0 || slotIndexB >= 4) return;
        const temp = this.activeLoadout.cards[slotIndexA];
        this.activeLoadout.cards[slotIndexA] = this.activeLoadout.cards[slotIndexB];
        this.activeLoadout.cards[slotIndexB] = temp;
        this._checkSynergy();
    }
    
    _checkSynergy() {
        const cards = this.getActiveLoadoutCards().filter(Boolean);
        if (cards.length < 4) {
            this.currentSynergy = { isValid: false, synergyName: 'Incomplete Build', description: 'Fill all 4 ability slots to activate a Synergy.' };
            return;
        }

        const counts = cards.reduce((acc, card) => {
            acc[card.element] = (acc[card.element] || 0) + 1;
            return acc;
        }, {});
        const elements = Object.keys(counts);

        if (elements.length === 1 && counts[elements[0]] === 4) {
            const el = elements[0];
            this.currentSynergy = { isValid: true, synergyName: `${el.toUpperCase()} MASTER`, description: `Energy costs for ${el} abilities are halved. Casting two ${el} abilities in quick succession triggers an Overload effect.`};
            return;
        }
        if (elements.length === 2 && counts[elements[0]] === 2 && counts[elements[1]] === 2) {
             const [el1, el2] = elements;
             this.currentSynergy = { isValid: true, synergyName: `ADEPT: ${el1.toUpperCase()}/${el2.toUpperCase()}`, description: `Unlocks a unique passive bonus based on the fusion of ${el1} and ${el2}.`};
             return;
        }
        if (elements.length === 2 && counts['Utility'] === 1) {
            const mainEl = elements.find(el => el !== 'Utility');
            if (mainEl && counts[mainEl] === 3) {
                 this.currentSynergy = { isValid: true, synergyName: `${mainEl.toUpperCase()} SPECIALIST`, description: `Cooldowns for your ${mainEl} abilities are reduced by 15%.`};
                 return;
            }
        }
        this.currentSynergy = { isValid: false, synergyName: 'Invalid Synergy', description: 'Builds must follow a 4, 2+2, or 3+1 (Utility) elemental pattern.' };
    }
    
    saveActiveLoadout(newName) {
        const name = newName.trim();
        if (!name) return;
        
        this.activeLoadout.name = name;
        this.playerProfile.savedLoadouts[name] = {
            name: name,
            weapon: this.activeLoadout.weapon,
            cards: [...this.activeLoadout.cards]
        };
    }
    
    switchActiveLoadout(loadoutName) {
        const saved = this.playerProfile.savedLoadouts[loadoutName];
        if (saved) {
            this.activeLoadout = {
                name: saved.name,
                weapon: saved.weapon,
                cards: [...saved.cards]
            };
            this.playerProfile.activeLoadoutName = loadoutName;
            this._checkSynergy();
        }
    }
    
    saveActiveLoadoutToLocalStorage() {
        const dataToSave = {
            name: this.activeLoadout.name,
            weapon: this.activeLoadout.weapon,
            cards: this.activeLoadout.cards
        };
        localStorage.setItem('activeLoadout', JSON.stringify(dataToSave));
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/LoadoutManager.js ===


=== FILE: src/client/ui/LoadoutUI.js ===
--------------------------------------------------
 import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { CardObject } from '../rendering/CardObject.js';
    import { CardParticleSystem } from '../rendering/CardParticleSystem.js';
    import { WeaponFactory } from '../../game/weapons/WeaponFactory.js';
    
    export class LoadoutUI {
        constructor(manager, abilityIconService) {
            this.manager = manager;
            this.abilityIconService = abilityIconService;
            this.elements = {
                inventoryPanel: document.getElementById('inventory-panel'),
                inventoryGrid: document.getElementById('inventory-grid'),
                
                playerPanel: document.getElementById('player-panel'),
                playerPreviewCanvas: document.getElementById('player-preview-canvas'),
                equippedSlotsContainer: document.getElementById('equipped-slots-container'),
                equippedSlots: document.querySelectorAll('.equipped-slot'),
                
                synergyName: document.getElementById('synergy-name'),
                synergyDescription: document.getElementById('synergy-description'),
                synergyDisplay: document.getElementById('synergy-display'),
    
                cardDetailsPanel: document.getElementById('card-details-panel'),
                detailsView2D: document.getElementById('details-view-2d'),
                detailsName: document.getElementById('details-name'),
                detailsElementTier: document.getElementById('details-element-tier'),
                detailsCost: document.getElementById('details-cost'),
                detailsCooldown: document.getElementById('details-cooldown'),
                detailsDescription: document.getElementById('details-description'),
                detailsFlavor: document.getElementById('details-flavor-text'),
                inspectBtn: document.getElementById('inspect-card-btn'),
    
                inspectorModal: document.getElementById('inspector-modal'),
                inspectionCanvas: document.getElementById('inspection-canvas'),
                inspectorModalCloseBtn: document.getElementById('inspector-modal-close-btn'),
    
                loadoutSelect: document.getElementById('loadout-select-dropdown'),
                loadoutNameInput: document.getElementById('loadout-name-input'),
                saveBtn: document.getElementById('save-loadout-btn'),
                backBtn: document.getElementById('back-to-menu-btn'),
                playBtn: document.getElementById('play-game-btn'),
            };
            this.selectedCardForInspect = null;
    
            this.inspector = {
                isActive: false,
                clock: new THREE.Clock(),
                scene: null, camera: null, renderer: null, controls: null,
                backgroundScene: null, backgroundCamera: null,
                activeMesh: null,
                activeCardObject: null, 
                particleSystem: null, 
                godRayPlane: null,
                tierLight: null,
                resizeObserver: null,
            };
        }
    
        init() {
            this.initPlayerPreview();
            this.initCardInspector();
            this.renderInventory();
            this.renderLoadout();
            this.renderLoadoutSelector();
            this.bindEventListeners();
        }
    
        initPlayerPreview() {
            const canvas = this.elements.playerPreviewCanvas;
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            camera.position.z = 3;
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 2, 3);
            scene.add(directionalLight);
            const playerGeo = new THREE.CapsuleGeometry(0.5, 1.0, 4, 8);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5 });
            const playerMesh = new THREE.Mesh(playerGeo, playerMat);
            playerMesh.position.y = -0.5;
            scene.add(playerMesh);
    
            const onResize = () => {
                if (!canvas.parentElement) return;
                const { clientWidth, clientHeight } = canvas.parentElement;
                renderer.setSize(clientWidth, clientHeight);
                camera.aspect = clientWidth / clientHeight;
                camera.updateProjectionMatrix();
            };
            onResize();
            new ResizeObserver(onResize).observe(canvas.parentElement);
            const animate = () => {
                requestAnimationFrame(animate);
                playerMesh.rotation.y += 0.005;
                renderer.render(scene, camera);
            };
            animate();
        }
    
        initCardInspector() {
            const canvas = this.elements.inspectionCanvas;
            this.inspector.scene = new THREE.Scene();
            this.inspector.backgroundScene = new THREE.Scene();
            this.inspector.camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
            this.inspector.backgroundCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            this.inspector.renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            this.inspector.renderer.setPixelRatio(window.devicePixelRatio);
            this.inspector.renderer.autoClear = false;
    
            this.inspector.camera.position.set(0, 0, 3.5);
            this.inspector.scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
            keyLight.position.set(2, 3, 3);
            this.inspector.scene.add(keyLight);
    
            this.inspector.controls = new OrbitControls(this.inspector.camera, this.inspector.renderer.domElement);
            this.inspector.controls.enableDamping = true;
            this.inspector.controls.enablePan = false;
            this.inspector.controls.minDistance = 2;
            this.inspector.controls.maxDistance = 6;
            this.inspector.controls.target.set(0,0,0); // Ensure target is reset for each new item
            
            this._animateInspector();
        }
    
        _animateInspector() {
            requestAnimationFrame(() => this._animateInspector());
            if (!this.inspector.isActive) return;
    
            const deltaTime = this.inspector.clock.getDelta();
            this.inspector.controls.update();
            this.inspector.activeCardObject?.update(deltaTime);
            this.inspector.particleSystem?.update(deltaTime);
            if (this.inspector.godRayPlane) this.inspector.godRayPlane.rotation.z += 0.001;
    
            const { renderer, backgroundScene, backgroundCamera, scene, camera } = this.inspector;
            renderer.clear();
            renderer.render(backgroundScene, backgroundCamera);
            renderer.clearDepth();
            renderer.render(scene, camera);
        }
        
        async showInspectorView(cardId) {
            if (!cardId) return;
            const cardData = this.manager.getCardDetails(cardId);
            if (!cardData) return;
    
            this._cleanupInspectorAssets();
            
            const tierColors = {
                1: new THREE.Color(0x3399ff),
                2: new THREE.Color(0xcc66ff),
                3: new THREE.Color(0xff6633),
                default: new THREE.Color(0xffffff)
            };
            const tierColor = tierColors[cardData.tier] || tierColors.default;
    
            if (cardData.type === 'Weapon') {
                const weapon = WeaponFactory.create(cardId);
                if (weapon?.mesh) {
                    this.inspector.activeMesh = weapon.mesh;
                }
            } else {
                this.inspector.activeCardObject = await CardObject.create(cardData);
                this.inspector.activeMesh = this.inspector.activeCardObject.mesh;
                this.inspector.particleSystem = new CardParticleSystem(this.inspector.scene, cardData.element);
            }
            
            if (this.inspector.activeMesh) {
                this.inspector.scene.add(this.inspector.activeMesh);
            }
    
            this._createGodRayPlane(tierColor);
            this.inspector.tierLight = new THREE.PointLight(tierColor, 10, 20, 1.5);
            this.inspector.tierLight.position.set(0, 0, -4);
            this.inspector.scene.add(this.inspector.tierLight);
            
            this.elements.inspectorModal.classList.add('active');
            this.inspector.isActive = true;
    
            const canvas = this.elements.inspectionCanvas;
            const { clientWidth, clientHeight } = canvas.parentElement;
            this.inspector.renderer.setSize(clientWidth, clientHeight);
            this.inspector.camera.aspect = clientWidth / clientHeight;
            this.inspector.camera.updateProjectionMatrix();

            // Reset controls target to center of new object
            this.inspector.controls.target.set(0,0,0);
            this.inspector.controls.update();
    
            if (!this.inspector.resizeObserver) {
                const onResize = () => {
                    if (!this.inspector.isActive || !canvas.parentElement) return;
                    const { clientWidth, clientHeight } = canvas.parentElement;
                    this.inspector.renderer.setSize(clientWidth, clientHeight);
                    this.inspector.camera.aspect = clientWidth / clientHeight;
                    this.inspector.camera.updateProjectionMatrix();
                };
                this.inspector.resizeObserver = new ResizeObserver(onResize);
                this.inspector.resizeObserver.observe(canvas.parentElement);
            }
        }
    
        hideInspectorView() {
            this.inspector.isActive = false;
            this._cleanupInspectorAssets();
            this.elements.inspectorModal.classList.remove('active');
    
            if (this.inspector.resizeObserver) {
                this.inspector.resizeObserver.disconnect();
                this.inspector.resizeObserver = null;
            }
        }
    
        _cleanupInspectorAssets() {
            if (this.inspector.activeMesh) {
                this.inspector.scene.remove(this.inspector.activeMesh);
                this.inspector.activeMesh = null;
            }
            if (this.inspector.activeCardObject) {
                this.inspector.activeCardObject.dispose();
                this.inspector.activeCardObject = null;
            }
            if (this.inspector.particleSystem) {
                this.inspector.particleSystem.dispose();
                this.inspector.particleSystem = null;
            }
            if (this.inspector.godRayPlane) {
                 this.inspector.backgroundScene.remove(this.inspector.godRayPlane);
                 this.inspector.godRayPlane.geometry.dispose();
                 this.inspector.godRayPlane.material.map?.dispose();
                 this.inspector.godRayPlane.material.dispose();
                 this.inspector.godRayPlane = null;
            }
            if (this.inspector.tierLight) {
                this.inspector.scene.remove(this.inspector.tierLight);
                this.inspector.tierLight.dispose();
                this.inspector.tierLight = null;
            }
        }
    
        _createGodRayPlane(color) {
            if (this.inspector.godRayPlane) {
                this.inspector.backgroundScene.remove(this.inspector.godRayPlane);
                this.inspector.godRayPlane.geometry.dispose();
                this.inspector.godRayPlane.material.map?.dispose();
                this.inspector.godRayPlane.material.dispose();
            }
    
            const canvas = document.createElement('canvas');
            const size = 512;
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d'), centerX = size / 2, centerY = size / 2;
            
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size / 2);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
    
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1.5;
            for(let i=0; i < 100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const length = size * 0.4 + (Math.random() * size * 0.3);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * length, centerY + Math.sin(angle) * length);
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, color, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
            this.inspector.godRayPlane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
            this.inspector.backgroundScene.add(this.inspector.godRayPlane);
        }
        
        renderInventory() {
            this.elements.inventoryGrid.innerHTML = '';
            const inventoryItems = this.manager.getInventoryItems('all');
            inventoryItems.forEach(item => {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.appendChild(this.createCardElement(item));
                this.elements.inventoryGrid.appendChild(slot);
            });
        }
    
        renderLoadout() {
            const loadoutCards = this.manager.getActiveLoadoutCards();
            const equippedWeapon = this.manager.getActiveWeapon();
    
            this.elements.equippedSlots.forEach((slot) => {
                slot.innerHTML = '';
                const slotType = slot.dataset.slotType;
                if (slotType === 'ability') {
                    const index = parseInt(slot.dataset.slotIndex, 10);
                    const card = loadoutCards[index];
                    if (card) slot.appendChild(this.createCardElement(card));
                } else if (slotType === 'weapon') {
                    if (equippedWeapon) slot.appendChild(this.createCardElement(equippedWeapon));
                }
            });
            this.renderSynergy();
        }
    
        renderSynergy() {
            const { isValid, synergyName, description } = this.manager.currentSynergy;
            this.elements.synergyName.textContent = synergyName;
            this.elements.synergyDescription.textContent = description;
            this.elements.synergyDisplay.className = 'synergy-display ' + (isValid ? 'synergy-valid' : 'synergy-invalid');
            this.elements.playBtn.disabled = false;
        }
    
        renderLoadoutSelector() {
            this.elements.loadoutSelect.innerHTML = '';
            Object.keys(this.manager.playerProfile.savedLoadouts).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                this.elements.loadoutSelect.appendChild(option);
            });
            this.elements.loadoutSelect.value = this.manager.activeLoadout.name;
            this.elements.loadoutNameInput.value = this.manager.activeLoadout.name;
        }
    
        createCardElement(cardData) {
            const el = document.createElement('div');
            el.className = `card-item tier-${cardData.tier}`;
            el.draggable = true;
            el.dataset.cardId = cardData.id;
            el.dataset.cardType = cardData.type || 'Ability';
    
            const iconContainer = document.createElement('div');
            iconContainer.className = 'card-item-icon';
            el.appendChild(iconContainer);
            
            if (cardData.type === 'Weapon') {
                el.classList.add('type-weapon');
            } else {
                el.classList.add(`element-${cardData.element.toLowerCase()}`);
                this.abilityIconService.generate(cardData).then(iconUrl => {
                    if (iconUrl) iconContainer.style.backgroundImage = `url(${iconUrl})`;
                }).catch(err => console.error(`Failed to generate icon for ${cardData.name}:`, err));
            }
    
            const textWrapper = document.createElement('div');
            textWrapper.className = 'card-item-text';
            textWrapper.innerHTML = `
                <span class="card-item-name">${cardData.name}</span>
                <span class="card-item-type">${cardData.type}</span>
            `;
            el.appendChild(textWrapper);
            
            el.onclick = (e) => {
                e.stopPropagation();
                this.selectForInspect(cardData.id);
            };
            return el;
        }
        
        selectForInspect(cardId) {
            document.querySelectorAll('.card-item.selected').forEach(el => el.classList.remove('selected'));
            if (!cardId) {
                this.selectedCardForInspect = null;
                this.elements.inspectBtn.disabled = true;
                this.renderCardDetails(null);
                return;
            }
    
            const cardData = this.manager.getCardDetails(cardId);
            this.renderCardDetails(cardData);
            
            document.querySelectorAll(`.card-item[data-card-id="${cardId}"]`).forEach(el => el.classList.add('selected'));
            
            this.selectedCardForInspect = cardId;
            this.elements.inspectBtn.disabled = false;
        }
    
        renderCardDetails(card) {
            if (card) {
                this.elements.detailsName.textContent = card.name;
                this.elements.detailsElementTier.textContent = `${card.element} - Tier ${card.tier}`;
                this.elements.detailsCost.textContent = card.energyCost ? `Cost: ${card.energyCost}` : '';
                this.elements.detailsCooldown.textContent = card.cooldown ? `CD: ${card.cooldown}s` : '';
                this.elements.detailsDescription.textContent = card.description;
                this.elements.detailsFlavor.textContent = `"${card.flavor}"`;
            } else {
                this.elements.detailsName.textContent = 'SELECT A CARD';
                this.elements.detailsElementTier.textContent = 'Click a card to see its details.';
                this.elements.detailsCost.textContent = '';
                this.elements.detailsCooldown.textContent = '';
                this.elements.detailsDescription.textContent = '';
                this.elements.detailsFlavor.textContent = '';
            }
        }
    
        bindEventListeners() {
            this.elements.inspectBtn.onclick = () => this.showInspectorView(this.selectedCardForInspect);
            this.elements.inspectorModalCloseBtn.onclick = () => this.hideInspectorView();
            this.elements.inspectorModal.onclick = (e) => {
                if (e.target === this.elements.inspectorModal) this.hideInspectorView();
            };
    
            let draggedElement = null;
            document.body.addEventListener('dragstart', e => {
                if (e.target.matches('.card-item')) {
                    draggedElement = e.target;
                    setTimeout(() => e.target.classList.add('dragging'), 0);
                    const data = { cardId: e.target.dataset.cardId, cardType: e.target.dataset.cardType };
                    const sourceSlotEl = e.target.closest('.equipped-slot');
                    if (sourceSlotEl) data.sourceType = sourceSlotEl.dataset.slotType;
                    if (sourceSlotEl?.dataset.slotIndex) data.sourceIndex = sourceSlotEl.dataset.slotIndex;
                    e.dataTransfer.setData('application/json', JSON.stringify(data));
                    e.dataTransfer.effectAllowed = 'move';
                }
            });
            document.body.addEventListener('dragend', () => {
                draggedElement?.classList.remove('dragging');
                draggedElement = null;
                this.elements.inventoryPanel.classList.remove('inventory-drag-over');
            });
    
            this.elements.equippedSlots.forEach(slot => {
                slot.addEventListener('dragover', e => { e.preventDefault(); slot.classList.add('drag-over'); });
                slot.addEventListener('dragleave', () => slot.classList.remove('drag-over'));
                slot.addEventListener('drop', e => {
                    e.preventDefault();
                    slot.classList.remove('drag-over');
                    try {
                        const data = JSON.parse(e.dataTransfer.getData('application/json'));
                        if (!data.cardId) return;
    
                        const targetSlotType = slot.dataset.slotType;
                        if (data.cardType.toLowerCase() !== targetSlotType) return;
    
                        if (targetSlotType === 'weapon') {
                            this.manager.equipWeapon(data.cardId);
                        } else if (targetSlotType === 'ability') {
                            const targetIndex = parseInt(slot.dataset.slotIndex, 10);
                            if (data.sourceType === 'ability') {
                                const sourceIndex = parseInt(data.sourceIndex, 10);
                                this.manager.swapCards(sourceIndex, targetIndex);
                            } else {
                                this.manager.equipCard(data.cardId, targetIndex);
                            }
                        }
                        this.renderLoadout();
                        this.renderInventory();
                    } catch (err) { console.warn("Drop on slot failed.", err); }
                });
            });
    
            const inventoryPanel = this.elements.inventoryPanel;
            inventoryPanel.addEventListener('dragover', e => {
                e.preventDefault();
                inventoryPanel.classList.add('inventory-drag-over');
            });
            inventoryPanel.addEventListener('dragleave', () => inventoryPanel.classList.remove('inventory-drag-over'));
            inventoryPanel.addEventListener('drop', e => {
                e.preventDefault();
                inventoryPanel.classList.remove('inventory-drag-over');
                try {
                    const data = JSON.parse(e.dataTransfer.getData('application/json'));
                    if (data.sourceType === 'ability') {
                        this.manager.unequipCard(parseInt(data.sourceIndex, 10));
                    } else if (data.sourceType === 'weapon') {
                        this.manager.unequipWeapon();
                    }
                    this.renderLoadout();
                    this.renderInventory();
                } catch (err) { console.warn("Drop on inventory failed.", err); }
            });
    
            this.elements.saveBtn.onclick = () => { this.manager.saveActiveLoadout(this.elements.loadoutNameInput.value); this.renderLoadoutSelector(); };
            this.elements.loadoutSelect.onchange = (e) => { this.manager.switchActiveLoadout(e.target.value); this.elements.loadoutNameInput.value = e.target.value; this.renderLoadout(); this.renderInventory(); };
            this.elements.backBtn.onclick = () => window.location.href = 'index.html';
            this.elements.playBtn.onclick = () => { this.manager.saveActiveLoadoutToLocalStorage(); window.location.href = 'index.html?showLevelSelect=true'; };
            document.body.addEventListener('click', () => { if(!this.inspector.isActive) this.selectForInspect(null); });
        }
    }
--------------------------------------------------
=== END OF FILE: src/client/ui/LoadoutUI.js ===


=== FILE: src/client/ui/loadout_main.js ===
--------------------------------------------------
// src/client/ui/loadout_main.js
import { LoadoutManager } from './LoadoutManager.js';
import { LoadoutUI } from './LoadoutUI.js';
import { AbilityIconService } from './AbilityIconService.js';

class LoadoutApplication {
    constructor() {
        this.manager = new LoadoutManager();
        this.abilityIconService = new AbilityIconService();
        this.ui = new LoadoutUI(this.manager, this.abilityIconService);
    }

    async init() {
        try {
            await this.manager.init();
            this.ui.init();
        } catch(error) {
            console.error("Failed to initialize Loadout Application:", error);
            document.body.innerHTML = `<div style="color:red; text-align:center; margin-top: 50px;">
                <h1>Loadout Failed to Start</h1>
                <p>Could not load card or player data. Please check console.</p>
            </div>`;
        }
    }
}

const app = new LoadoutApplication();
app.init();
--------------------------------------------------
=== END OF FILE: src/client/ui/loadout_main.js ===


=== FILE: src/client/ui/TutorialManager.js ===
--------------------------------------------------
/**
 * Handles the display of tutorial messages.
 * In the new architecture, this class is simplified to be a pure view-layer component.
 * It receives events and displays text via the UIManager/HUD.
 */
export class TutorialManager {
    constructor() {
        this.hudElements = null;
        this.tutorialTimer = null;
    }

    registerHud(hud) {
        this.hudElements = hud.elements;
    }

    // Called by an event listener when a tutorial trigger is activated in the game world.
    onTriggerActivated(data) {
        if (!this.hudElements) return;

        this.showTutorialText(data.message, data.duration);
    }
    
    showTutorialText(message, duration) {
        if (this.tutorialTimer) clearTimeout(this.tutorialTimer);
        
        const container = this.hudElements.tutorialContainer;
        container.classList.remove('level-complete');
        
        this.hudElements.tutorialText.innerHTML = message;
        container.style.opacity = '1';
        container.style.display = 'block';
        
        if (duration > 0) {
            this.tutorialTimer = setTimeout(() => {
                this.hideTutorialText();
            }, duration * 1000);
        }
    }

    hideTutorialText() {
        const container = this.hudElements.tutorialContainer;
        container.style.opacity = '0';
        setTimeout(() => {
            if (!container.classList.contains('level-complete')) {
                 container.style.display = 'none';
            }
        }, 500); // Must match the CSS transition duration
    }
    
    showLevelCompleted() {
        if (this.tutorialTimer) clearTimeout(this.tutorialTimer);
        const container = this.hudElements.tutorialContainer;
        this.hudElements.tutorialText.textContent = 'LEVEL COMPLETE';
        container.classList.add('level-complete');
        container.style.opacity = '1';
        container.style.display = 'block';
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/TutorialManager.js ===


=== FILE: src/client/ui/UIManager.js ===
--------------------------------------------------
// src/client/ui/UIManager.js
import { HUD } from './HUD.js';
import { Minimap } from '../rendering/Minimap.js';
import { TutorialManager } from './TutorialManager.js';
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Central controller for all UI interactions, screens, and HUD elements.
 * It acts as the bridge between the game state and the DOM.
 */
export class UIManager {
    constructor(abilityIconService) {
        this.screens = {
            mainMenu: document.getElementById('main-menu'),
            levelSelect: document.getElementById('level-select-menu'),
            pauseMenu: document.getElementById('pause-menu'),
            deathScreen: document.getElementById('death-screen'),
        };

        this.elements = {
            levelList: document.getElementById('level-list'),
            respawnTimerText: document.getElementById('respawn-timer-text'),
            loadCustomLevelBtn: document.getElementById('load-custom-level-btn'),
            customLevelInput: document.getElementById('custom-level-input'),
            resumeBtn: document.getElementById('resume-btn'),
            pauseQuitBtn: document.getElementById('pause-quit-btn'),
            deathQuitBtn: document.getElementById('death-quit-btn'),
            energyBarContainer: document.getElementById('energy-bar-container'),
            abilitySlots: document.querySelectorAll('.ability-slot'), // Direct access for flashing
            underwaterOverlay: document.getElementById('vfx-underwater-overlay'),
        };

        this.hud = new HUD(abilityIconService);
        this.minimap = new Minimap();
        this.tutorialManager = new TutorialManager();
        this.tutorialManager.registerHud(this.hud);

        this.customLevelPlayBtn = null;
    }

    _getLoadout() {
        const saved = localStorage.getItem('activeLoadout');
        return saved ? JSON.parse(saved) : { cards: [null, null, null, null], weapon: null };
    }
    
    showScreen(screenName) {
        Object.values(this.screens).forEach(screen => { if (screen) screen.style.display = 'none' });
        if (this.screens[screenName]) {
            this.screens[screenName].style.display = 'flex';
        }
    }

    setLoading(isLoading) {
        if (isLoading) {
            this.showScreen('mainMenu');
            this.screens.mainMenu.innerHTML = '<h2>Loading...</h2>';
        } else {
            this.screens.mainMenu.innerHTML = `
                <h1>ELEMENTALS</h1>
                <div class="menu-options">
                    <button id="play-btn">Play</button>
                    <button id="loadout-btn">Loadout</button>
                    <button id="editor-btn">Level Editor</button>
                </div>`;
        }
    }

    bindGame(game) {
        const setupMainMenuListeners = () => {
            const playBtn = document.getElementById('play-btn');
            const loadoutBtn = document.getElementById('loadout-btn');
            const editorBtn = document.getElementById('editor-btn');

            if (playBtn) playBtn.onclick = () => {
                this.populateLevelList(game);
                this.showScreen('levelSelect');
            };
            if (loadoutBtn) loadoutBtn.onclick = () => { window.location.href = 'loadout.html'; };
            if (editorBtn) editorBtn.onclick = () => { window.location.href = 'editor.html'; };
        };
        
        setupMainMenuListeners();
        game.on('mainMenuRendered', setupMainMenuListeners);
        game.on('abilityCastFailed', (data) => this.onAbilityCastFailed(data));

        this.elements.loadCustomLevelBtn.onclick = () => this.elements.customLevelInput.click();
        this.elements.customLevelInput.onchange = (e) => this.handleCustomLevelSelect(e, game);
        document.querySelectorAll('.back-button').forEach(btn => 
            btn.onclick = () => this.showScreen(btn.dataset.target.replace('-',''))
        );

        this.elements.resumeBtn.onclick = () => game.requestPointerLock();
        this.elements.pauseQuitBtn.onclick = () => game.returnToMenu();
        this.elements.deathQuitBtn.onclick = () => game.returnToMenu();
    }

    async populateLevelList(game) {
        try {
            const response = await fetch('./levels/manifest.json');
            const levels = await response.json();
            this.elements.levelList.innerHTML = '';
            
            for (const level of levels) {
                const btn = document.createElement('button');
                btn.textContent = level.name;
                btn.onclick = () => game.startLevel({ 
                    url: level.path,
                    loadout: this._getLoadout() 
                });
                this.elements.levelList.appendChild(btn);
            }
        } catch (error) {
            console.error("Could not load level manifest:", error);
            this.elements.levelList.innerHTML = '<p style="color: #ff4757;">Could not load levels.</p>';
        }
    }

    handleCustomLevelSelect(event, game) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const levelData = JSON.parse(e.target.result);
                this.prepareCustomLevel(levelData, game);
            } catch (err) {
                alert("Invalid or corrupt level file.");
            } finally {
                event.target.value = ''; 
            }
        };
        reader.readAsText(file);
    }

    prepareCustomLevel(data, game) {
        if (this.customLevelPlayBtn && this.customLevelPlayBtn.parentElement) {
            this.customLevelPlayBtn.parentElement.removeChild(this.customLevelPlayBtn);
        }
        const levelName = data.name || 'Custom Level';
        this.customLevelPlayBtn = document.createElement('button');
        this.customLevelPlayBtn.textContent = `Play: ${levelName}`;
        this.customLevelPlayBtn.style.borderColor = '#2ed573';
        this.customLevelPlayBtn.onclick = () => game.startLevel({ data, loadout: this._getLoadout() });
        this.screens.levelSelect.appendChild(this.customLevelPlayBtn);
    }

    onAbilityCastFailed(data) {
        if (data.reasons.includes('insufficient_energy')) {
            this.flashEnergyBar();
        }
        if (data.reasons.includes('on_cooldown') && data.ability) {
            const player = data.entity;
            const abilityIndex = player.abilities.abilities.indexOf(data.ability);
            if (abilityIndex !== -1) {
                this.flashAbilitySlotError(abilityIndex);
            }
        }
    }

    flashEnergyBar() {
        const container = this.elements.energyBarContainer;
        if (!container || container.classList.contains('flash-error')) return;
        container.classList.add('flash-error');
        container.addEventListener('animationend', () => {
            container.classList.remove('flash-error');
        }, { once: true });
    }

    flashAbilitySlotError(index) {
        const slotUI = this.hud.elements.abilitySlots[index];
        if (!slotUI || slotUI.isFlashing) return;

        const slotElement = slotUI.element;
        slotElement.classList.add('flash-cooldown-error');
        slotUI.isFlashing = true;
        
        slotElement.addEventListener('animationend', () => {
            slotElement.classList.remove('flash-cooldown-error');
            slotUI.isFlashing = false;
        }, { once: true });
    }

    update(game) {
        if (!game || !game.world) return;
        
        const player = game.world.player;
        if (!player) return;

        this.hud.updateResources(
            player.health.currentHealth, player.health.maxHealth, 
            player.abilities.currentEnergy, player.abilities.maxEnergy
        );
        this.hud.updateOxygen(player.currentOxygen, player.maxOxygen);
        this.hud.updateMovementCooldowns(
            player.doubleJumpCooldownTimer, GAME_CONFIG.PLAYER.DOUBLE_JUMP_COOLDOWN,
            player.dashCooldownTimer, GAME_CONFIG.PLAYER.DASH_COOLDOWN,
            player.doubleJumpOnCooldown,
            player.dashOnCooldown
        );
        this.hud.updateAbilities(player.abilities.abilities, player.abilities.selectedAbilityIndex);
        this.hud.updateAmmo(player.weapon);
        this.hud.updateTargeting(
            player.abilities.abilities[player.abilities.selectedAbilityIndex]?.requiresLockOn, 
            player.lockedTarget,
            game.core.renderer.camera
        );
        this.hud.updateEnemyCount(game.world.enemiesKilled, game.world.initialEnemyCount);
        this.minimap.update(player, game.world.getNPCs(), game.world.getLevelObjects());
        
        // Update underwater overlay
        this.elements.underwaterOverlay.classList.toggle('active', player.isSwimming);

        // Update oxygen bar visibility
        if (this.hud.elements.oxygenBarContainer) {
            const isConsumingOxygen = player.isSwimming && !player.isWaterSpecialist;
            const isRegeneratingOxygen = !player.isSwimming && player.currentOxygen < player.maxOxygen;
            const shouldShowOxygenBar = isConsumingOxygen || isRegeneratingOxygen;
            this.hud.elements.oxygenBarContainer.style.display = shouldShowOxygenBar ? 'block' : 'none';
        }

        if (game.gameState === 'DEAD') {
            this.elements.respawnTimerText.textContent = `Respawning in ${Math.ceil(game.respawnTimer)}...`;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/UIManager.js ===


=== FILE: src/core/AssetManager.js ===
--------------------------------------------------
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

export class AssetManager {
    constructor() {
        this.textureLoader = new THREE.TextureLoader();
        this.gltfLoader = new GLTFLoader();
        
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
        this.gltfLoader.setDRACOLoader(dracoLoader);
        
        this.cache = new Map();
        this.loadingPromises = [];
    }

    _loadTexture(name, path) {
        const promise = new Promise((resolve, reject) => {
            if (this.cache.has(name)) {
                resolve(this.cache.get(name));
                return;
            }
            this.textureLoader.load(
                path,
                (texture) => {
                    this.cache.set(name, texture);
                    resolve(texture);
                },
                undefined, // onProgress
                (error) => {
                    console.error(`Failed to load texture: ${name} from ${path}`, error);
                    reject(error);
                }
            );
        });
        this.loadingPromises.push(promise);
    }
    
    _loadGLTF(name, path) {
        const promise = new Promise((resolve, reject) => {
            if (this.cache.has(name)) {
                resolve(this.cache.get(name));
                return;
            }
            this.gltfLoader.load(
                path,
                (gltf) => {
                    this.cache.set(name, gltf);
                    resolve(gltf);
                },
                undefined, // onProgress
                (error) => {
                    console.error(`Failed to load GLTF model: ${name} from ${path}`, error);
                    reject(error);
                }
            );
        });
        this.loadingPromises.push(promise);
    }
    
    _loadAudio(name, path) {
        const promise = new Promise((resolve, reject) => {
             if (this.cache.has(name)) {
                resolve(this.cache.get(name));
                return;
            }
            const audio = new Audio(path);
            audio.addEventListener('canplaythrough', () => {
                this.cache.set(name, audio);
                resolve(audio);
            }, { once: true });
            audio.addEventListener('error', (e) => {
                console.error(`Failed to load audio: ${name} from ${path}`, e);
                reject(e);
            });
        });
        this.loadingPromises.push(promise);
    }

    queue(assets) {
        for (const asset of assets) {
            switch(asset.type) {
                case 'texture':
                    this._loadTexture(asset.name, asset.path);
                    break;
                case 'gltf':
                    this._loadGLTF(asset.name, asset.path);
                    break;
                case 'audio':
                    this._loadAudio(asset.name, asset.path);
                    break;
                default:
                    console.warn(`Unknown asset type: ${asset.type}`);
            }
        }
    }

    async loadAll() {
        try {
            await Promise.all(this.loadingPromises);
        } catch (error) {
            console.error("An error occurred during asset loading.", error);
        } finally {
            this.loadingPromises = [];
        }
    }

    get(name) {
        if (!this.cache.has(name)) {
            throw new Error(`Asset not found in cache: ${name}`);
        }
        return this.cache.get(name);
    }
}
--------------------------------------------------
=== END OF FILE: src/core/AssetManager.js ===


=== FILE: src/core/InputManager.js ===
--------------------------------------------------
import { EventEmitter } from '../shared/EventEmitter.js';

export class InputManager extends EventEmitter {
    constructor() {
        super();
        this.keys = {};
        this.mouse = {
            movementX: 0,
            movementY: 0,
            leftClick: false,
            rightClick: false,
            screenX: 0,
            screenY: 0,
        };
        this.enabled = true;

        this.mousePreviousState = {};

        this._onKeyDown = this._onKeyDown.bind(this);
        this._onKeyUp = this._onKeyUp.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseDown = this._onMouseDown.bind(this);
        this._onMouseUp = this._onMouseUp.bind(this);
        this._onWheel = this._onWheel.bind(this);
        this._onContextMenu = this._onContextMenu.bind(this);
        
        this.addEventListeners();
    }

    addEventListeners() {
        document.addEventListener('keydown', this._onKeyDown);
        document.addEventListener('keyup', this._onKeyUp);
        document.addEventListener('mousemove', this._onMouseMove);
        document.addEventListener('mousedown', this._onMouseDown);
        document.addEventListener('mouseup', this._onMouseUp);
        document.addEventListener('wheel', this._onWheel, { passive: false });
        document.addEventListener('contextmenu', this._onContextMenu);
    }

    _onKeyDown(e) {
        // Emit a singlePress event only on the initial press
        if (!this.keys[e.code]) {
            this.emit('singlePress', { code: e.code });
        }
        this.keys[e.code] = true;
    }
    _onKeyUp(e) { this.keys[e.code] = false; }
    
    _onMouseDown(e) {
        if (e.button === 0) this.mouse.leftClick = true;
        if (e.button === 2) this.mouse.rightClick = true;
        
        if (!this.mousePreviousState[e.button]) {
            this.emit('singlePress', { button: e.button });
        }
        this.mousePreviousState[e.button] = true;
    }

    _onMouseUp(e) {
        if (e.button === 0) this.mouse.leftClick = false;
        if (e.button === 2) this.mouse.rightClick = false;
        this.mousePreviousState[e.button] = false;
    }

    _onMouseMove(e) {
        this.mouse.screenX = e.clientX;
        this.mouse.screenY = e.clientY;
        this.mouse.movementX = e.movementX;
        this.mouse.movementY = e.movementY;
    }

    _onWheel(e) {
        if (this.enabled) {
            e.preventDefault(); // Prevent page scrolling during gameplay
            this.emit('scroll', { deltaY: e.deltaY });
        }
    }

    _onContextMenu(e) {
        e.preventDefault();
    }

    update() {
        this.mouse.movementX = 0;
        this.mouse.movementY = 0;
    }
    
    dispose() {
        document.removeEventListener('keydown', this._onKeyDown);
        document.removeEventListener('keyup', this._onKeyUp);
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mousedown', this._onMouseDown);
        document.removeEventListener('mouseup', this._onMouseUp);
        document.removeEventListener('wheel', this._onWheel);
        document.removeEventListener('contextmenu', this._onContextMenu);
    }
}
--------------------------------------------------
=== END OF FILE: src/core/InputManager.js ===


=== FILE: src/core/Physics.js ===
--------------------------------------------------
// src/core/Physics.js

import * as CANNON from 'cannon-es';

export class Physics {
    constructor() {
        this.world = new CANNON.World({
            gravity: new CANNON.Vec3(0, -9.82, 0),
            allowSleep: true,
        });

        // ЗАМЕНА АЛГОРИТМА НА БОЛЕЕ НАДЕЖНЫЙ ДЛЯ СТАТИЧЕСКИХ МИРОВ
        this.world.broadphase = new CANNON.NaiveBroadphase();

        this.bodiesToRemove = new Set();
    }

    addContactMaterial(material) {
        this.world.addContactMaterial(material);
    }

    addBody(body) {
        this.world.addBody(body);
    }

    queueForRemoval(body) {
        if (body) {
            this.bodiesToRemove.add(body);
        }
    }
    
    _removeQueuedBodies() {
        if (this.bodiesToRemove.size > 0) {
            for (const body of this.bodiesToRemove) {
                this.world.removeBody(body);
            }
            this.bodiesToRemove.clear();
        }
    }

    update(deltaTime) {
        this.world.step(1 / 60, deltaTime, 3);
        this._removeQueuedBodies();
    }
}
--------------------------------------------------
=== END OF FILE: src/core/Physics.js ===


=== FILE: src/core/Renderer.js ===
--------------------------------------------------
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

export class Renderer {
    constructor(canvasElement) {
        if (!canvasElement) {
            throw new Error('Renderer requires a canvas element.');
        }

        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            canvas: canvasElement,
            powerPreference: 'high-performance'
        });
        
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        
        this.composer = null;
        this.bloomPass = null;

        this._onWindowResize = this._onWindowResize.bind(this);
        window.addEventListener('resize', this._onWindowResize);
    }
    
    setupPostProcessing(mainScene, camera, viewModelScene = null) {
        this.composer = new EffectComposer(this.renderer);
        this.composer.addPass(new RenderPass(mainScene, camera));

        if (viewModelScene) {
            const viewModelPass = new RenderPass(viewModelScene, camera);
            viewModelPass.clear = false;
            viewModelPass.clearDepth = true;
            this.composer.addPass(viewModelPass);
        }
        
        this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        this.bloomPass.threshold = 0.9;
        this.bloomPass.strength = 0.7;
        this.bloomPass.radius = 0.5;
        this.composer.addPass(this.bloomPass);
    }
    
    _onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        if (this.composer) {
            this.composer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    render() {
        if (this.composer) {
            this.composer.render();
        } else {
            this.renderer.render(this.scene, this.camera);
        }
    }
    
    dispose() {
        window.removeEventListener('resize', this._onWindowResize);
        this.renderer.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/core/Renderer.js ===


=== FILE: src/editor/EditorActions.js ===
--------------------------------------------------
// src/editor/EditorActions.js

 import * as THREE from 'three';
    import { StateChangeCommand } from './UndoManager.js';
    
    export class EditorActions {
        constructor(editor) {
            this.editor = editor;
            this.app = editor.app;
            this.camera = editor.camera;
        }
    
        _createAndExecuteCreationCommand(entity) {
            const command = {
                execute: () => {
                    this.app.add(entity);
                    this.editor.select(entity);
                },
                undo: () => {
                    // Remove without disposing so it can be redone
                    this.app.remove(entity, false);
                    this.editor.deselect();
                }
            };
            this.editor.undoManager.execute(command);
        }
    
        addBox() {
            const lookDir = new THREE.Vector3();
            this.camera.getWorldDirection(lookDir);
            const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
            const boxData = {
                type: "Box", name: `Box_${Date.now()}`, size: [2, 2, 2],
                position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
                rotation: { x: 0, y: 0, z: 0 }, // Keep for initial creation
                material: { color: "0xcccccc" }, physics: { mass: 0 }
            };
            const newObj = this.app.levelManager.createObject(boxData);
            this._createAndExecuteCreationCommand(newObj);
        }
    
        addWaterVolume() {
            const lookDir = new THREE.Vector3();
            this.camera.getWorldDirection(lookDir);
            const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(15));
            const waterData = {
                type: "Water",
                name: `WaterVolume_${Date.now()}`,
                size: [20, 5, 20],
                position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
                rotation: { x: 0, y: 0, z: 0 }
            };
            const newWater = this.app.levelManager.createObject(waterData);
            this._createAndExecuteCreationCommand(newWater);
        }
        
        addWaterfall() {
            const lookDir = new THREE.Vector3();
            this.camera.getWorldDirection(lookDir);
            const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(15));
            const waterfallData = {
                type: "Waterfall",
                name: `Waterfall_${Date.now()}`,
                size: [10, 20],
                position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
                rotation: { x: 0, y: 0, z: 0 }
            };
            const newWaterfall = this.app.levelManager.createObject(waterfallData);
            this._createAndExecuteCreationCommand(newWaterfall);
        }
    
        _addNPC(team, attackType) {
            const lookDir = new THREE.Vector3();
            this.camera.getWorldDirection(lookDir);
            const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
            const npcData = {
                type: "Dummy", // This is just a placeholder type for the level data, NPCPrefab handles the rest
                team: team,
                attackType: attackType,
                position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z }
            };
            const newNPC = this.app.levelManager.createNPC(npcData);
            this._createAndExecuteCreationCommand(newNPC);
        }
    
        addEnemyRanged() { this._addNPC('enemy', 'ranged'); }
        addEnemyMelee() { this._addNPC('enemy', 'melee'); }
        addAllyRanged() { this._addNPC('player', 'ranged'); }
        addAllyMelee() { this._addNPC('player', 'melee'); }
    
        addMessageTrigger() {
            const lookDir = new THREE.Vector3();
            this.camera.getWorldDirection(lookDir);
            const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
            const triggerData = {
                type: "Trigger", name: `MessageTrigger_${Date.now()}`, size: [5, 5, 5],
                position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
                rotation: { x: 0, y: 0, z: 0 },
                message: "This is a test message.",
                duration: 5,
                color: "0x00ff00"
            };
            const newTrigger = this.app.levelManager.createTrigger(triggerData, 'Trigger');
            this._createAndExecuteCreationCommand(newTrigger);
        }
    
        addDeathTrigger() {
            const lookDir = new THREE.Vector3();
            this.camera.getWorldDirection(lookDir);
            const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
            const triggerData = {
                type: "DeathTrigger", name: `DeathZone_${Date.now()}`, size: [10, 2, 10],
                position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
                rotation: { x: 0, y: 0, z: 0 },
            };
            const newTrigger = this.app.levelManager.createTrigger(triggerData, 'DeathTrigger');
            this._createAndExecuteCreationCommand(newTrigger);
        }
    
        addDirectionalLight() {
            const lookDir = new THREE.Vector3();
            this.camera.getWorldDirection(lookDir);
            const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(20));
    
            const lightData = {
                color: "0xffffff",
                intensity: 1,
                position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
                targetPosition: { x: 0, y: 0, z: 0 }
            };
            
            const newLight = this.app.levelManager.createDirectionalLight(lightData);
            const newLightObject = this.app.createDirectionalLightWithHelper(newLight);
            this._createAndExecuteCreationCommand(newLightObject);
        }
    
        deleteSelected() {
            if (this.editor.selectedObjects.size === 0) return;
    
            const entitiesToDelete = [...this.editor.selectedObjects].filter(entity => {
                const entityType = entity.userData.gameEntity.type;
                return !['SpawnPoint', 'DeathSpawnPoint'].includes(entityType);
            });
        
            if (entitiesToDelete.length === 0) return;
        
            const definitions = entitiesToDelete.map(entity => JSON.parse(JSON.stringify(entity.definition)));
            let recreatedEntities = [];
        
            const command = {
                execute: () => {
                    const targets = recreatedEntities.length > 0 ? recreatedEntities : entitiesToDelete;
                    targets.forEach(entity => this.app.remove(entity));
                    this.editor.deselect();
                    recreatedEntities = [];
                },
                undo: () => {
                    this.editor.deselect();
                    definitions.forEach(def => {
                        const newEntity = this.app.levelManager.recreateEntity(def);
                        if (newEntity) {
                            recreatedEntities.push(newEntity);
                            this.app.add(newEntity);
                            this.editor.addToSelection(newEntity);
                        }
                    });
                }
            };
            this.editor.undoManager.execute(command);
        }
        
        _bakeScaleIntoDefinition(entity) {
            const transformSource = entity.helperMesh || entity.mesh || entity.picker || entity;
            if (entity && transformSource && entity.definition?.size) {
                const scale = transformSource.scale;
                if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
                    if (entity.definition.type === 'Plane' || entity.definition.type === 'Waterfall') {
                        entity.definition.size[0] *= scale.x;
                        entity.definition.size[1] *= scale.y;
                    } else {
                        entity.definition.size[0] *= scale.x;
                        entity.definition.size[1] *= scale.y;
                        entity.definition.size[2] *= scale.z;
                    }
                    scale.set(1, 1, 1);
                    this.editor.applyDefinition(entity);
                }
            }
        }
        
        copySelected() {
            if (this.editor.selectedObjects.size === 0) return;
        
            const clipboardData = {
                centroid: new THREE.Vector3(),
                definitions: []
            };
            const tempCentroid = new THREE.Vector3();
            let validObjects = 0;
        
            this.editor.selectedObjects.forEach(entity => {
                const entityType = entity.userData?.gameEntity?.type;
                const validTypes = ['Object', 'NPC', 'Trigger', 'DeathTrigger', 'Water', 'Waterfall'];
        
                if (validTypes.includes(entityType)) {
                    this._bakeScaleIntoDefinition(entity);
                    this.editor.syncObjectTransforms(entity);
        
                    const mesh = entity.helperMesh || entity.mesh || entity.picker || entity;
                    tempCentroid.add(mesh.position);
                    validObjects++;
                    
                    if (entity.definition.quaternion !== undefined) {
                        entity.definition.quaternion = {
                            x: mesh.quaternion.x,
                            y: mesh.quaternion.y,
                            z: mesh.quaternion.z,
                            w: mesh.quaternion.w
                        };
                        delete entity.definition.rotation;
                    } else if (entity.definition.rotation) { // Fallback for older format if needed
                        const rot = new THREE.Euler().setFromQuaternion(mesh.quaternion, 'YXZ');
                        entity.definition.rotation = {
                            x: THREE.MathUtils.radToDeg(rot.x),
                            y: THREE.MathUtils.radToDeg(rot.y),
                            z: THREE.MathUtils.radToDeg(rot.z)
                        };
                    }
        
                    clipboardData.definitions.push(JSON.parse(JSON.stringify(entity.definition)));
                }
            });
        
            if (validObjects > 0) {
                tempCentroid.divideScalar(validObjects);
                clipboardData.centroid = tempCentroid.toArray();
                this.editor.clipboard = clipboardData;
            } else {
                this.editor.clipboard = null;
            }
        }
    
        pasteFromClipboard() {
            if (!this.editor.clipboard || !this.editor.clipboard.definitions || this.editor.clipboard.definitions.length === 0) return;
        
            const lookDir = new THREE.Vector3();
            this.camera.getWorldDirection(lookDir);
            const newCenter = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(15));
            
            const originalCenter = new THREE.Vector3().fromArray(this.editor.clipboard.centroid);
            const createdEntities = [];
            const definitionsToCreate = this.editor.clipboard.definitions;
        
            const command = {
                execute: () => {
                    this.editor.deselect();
                    definitionsToCreate.forEach(def => {
                        const newDef = JSON.parse(JSON.stringify(def));
                        const originalPos = new THREE.Vector3().copy(newDef.position);
                        const offset = new THREE.Vector3().subVectors(originalPos, originalCenter);
                        
                        newDef.position = { x: newCenter.x + offset.x, y: newCenter.y + offset.y, z: newCenter.z + offset.z };
                        newDef.name = `${newDef.name || newDef.type}_copy_${Math.floor(Math.random() * 1000)}`;
                        
                        let newEntity;
                        switch(newDef.type) {
                            case 'Dummy': newEntity = this.app.levelManager.createNPC(newDef); break;
                            case 'Trigger': newEntity = this.app.levelManager.createTrigger(newDef, 'Trigger'); break;
                            case 'DeathTrigger': newEntity = this.app.levelManager.createTrigger(newDef, 'DeathTrigger'); break;
                            case 'Water':
                            case 'Waterfall':
                            default: newEntity = this.app.levelManager.createObject(newDef); break;
                        }
        
                        if (newEntity) {
                            this.app.add(newEntity);
                            this.editor.addToSelection(newEntity);
                            createdEntities.push(newEntity);
                        }
                    });
                },
                undo: () => {
                    createdEntities.forEach(entity => this.app.remove(entity));
                    createdEntities.length = 0;
                    this.editor.deselect();
                }
            };
        
            this.editor.undoManager.execute(command);
        }
    
        async newLevel() {
            const newLevelData = {
                name: "New Level",
                spawnPoint: { x: 0, y: 3, z: 0 },
                deathSpawnPoint: { x: 0, y: 3, z: 0 },
                settings: {
                    backgroundColor: "0x1d2938",
                    fogColor: "0x1d2938",
                    fogNear: 20,
                    fogFar: 150,
                    ambientLight: {
                        color: "0x607080",
                        intensity: 0.7
                    },
                    directionalLights: [
                        {
                            color: "0xffffff",
                            intensity: 1.5,
                            position: { x: -0.19, y: 100, z: 94.33 },
                            targetPosition: { x: 0, y: 0, z: 0 }
                        }
                    ]
                },
                objects: [
                    {
                        "type": "Plane",
                        "name": "Ground Plane",
                        "size": [200, 200],
                        "position": { "x": 0, "y": 0, "z": 0 },
                        "rotation": { "x": -90, "y": 0, "z": 0 },
                        "material": { "color": "0x334455", "roughness": 0.9 },
                        "physics": { "mass": 0 },
                        "editorSelectable": false
                    }
                ],
                npcs: [],
                triggers: [],
                deathTriggers: []
            };
            await this.app.loadLevel(newLevelData);
        }
    
        loadFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                try { 
                    await this.app.loadLevel(JSON.parse(e.target.result)); 
                } 
                catch (err) { 
                    alert("Invalid level file."); 
                    console.error("Error loading level:", err); 
                }
            };
            reader.readAsText(file);
        }
    
        getSerializableLevelData() {
            const entities = [...this.app.entities];
            
            entities.forEach(obj => {
                this._bakeScaleIntoDefinition(obj);
                const transformSource = obj.helperMesh || obj.mesh || obj.picker;
                if (!obj.definition || !transformSource) return;
    
                obj.definition.position = { x: transformSource.position.x, y: transformSource.position.y, z: transformSource.position.z };
                
                // NEW: Save quaternion instead of euler angles
                if (obj.definition.rotation !== undefined) {
                    obj.definition.quaternion = {
                        x: transformSource.quaternion.x,
                        y: transformSource.quaternion.y,
                        z: transformSource.quaternion.z,
                        w: transformSource.quaternion.w
                    };
                    delete obj.definition.rotation; // Remove the old property
                }
            });
    
            const finalSettings = JSON.parse(JSON.stringify(this.app.settings));
            finalSettings.directionalLights = this.app.getDirectionalLights().map(lightObj => {
                const def = lightObj.definition;
                def.position = { x: lightObj.light.position.x, y: lightObj.light.position.y, z: lightObj.light.position.z };
                def.targetPosition = { x: lightObj.light.target.position.x, y: lightObj.light.target.position.y, z: lightObj.light.target.position.z };
                return def;
            });
    
            const geometricObjects = [
                ...this.app.getLevelObjects(),
                ...this.app.getWaterVolumes(),
                ...this.app.getWaterfalls()
            ];
    
            const levelData = {
                name: this.app.levelName || "Custom Level",
                spawnPoint: { x: this.app.spawnPointHelper.position.x, y: this.app.spawnPointHelper.position.y, z: this.app.spawnPointHelper.position.z },
                deathSpawnPoint: { x: this.app.deathSpawnPointHelper.position.x, y: this.app.deathSpawnPointHelper.position.y, z: this.app.deathSpawnPointHelper.position.z },
                settings: finalSettings,
                objects: geometricObjects.map(obj => obj.definition),
                npcs: this.app.getNPCs().map(npc => npc.definition),
                triggers: this.app.getTriggers().map(t => t.definition),
                deathTriggers: this.app.getDeathTriggers().map(t => t.definition)
            };
            return levelData;
        }
    
        saveFile() {
            const levelData = this.getSerializableLevelData();
            const blob = new Blob([JSON.stringify(levelData, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${levelData.name.toLowerCase().replace(/\s/g, '-')}.json`;
            a.click();
            URL.revokeObjectURL(a.href);
        }
    
        playInDebugMode() {
            const levelData = this.getSerializableLevelData();
            try {
                localStorage.setItem('editorLevelData', JSON.stringify(levelData));
                window.location.href = 'index.html?loadFromEditor=true&debug=true';
            } catch (e) {
                console.error("Failed to save level to localStorage:", e);
                alert("Could not play level in debug mode. Level data might be too large.");
            }
        }
        
        setSpawnPointToCamera() { this.camera.getWorldPosition(this.app.spawnPointHelper.position); this.editor.syncObjectTransforms(this.app.spawnPointHelper); }
        setDeathSpawnPointToCamera() { this.camera.getWorldPosition(this.app.deathSpawnPointHelper.position); this.editor.syncObjectTransforms(this.app.deathSpawnPointHelper); }
    }
--------------------------------------------------
=== END OF FILE: src/editor/EditorActions.js ===


=== FILE: src/editor/EditorApp.js ===
--------------------------------------------------
 import * as THREE from 'three';
    import * as CANNON from 'cannon-es';
    import { Renderer } from '../core/Renderer.js';
    import { Physics } from '../core/Physics.js';
    import { InputManager } from '../core/InputManager.js';
    import { LevelManager } from '../game/world/LevelManager.js';
    import { LevelEditor } from './LevelEditor.js';
    
    export class EditorApp {
        constructor() {
            this.clock = new THREE.Clock();
            const canvas = document.getElementById('game-canvas');
            this.renderer = new Renderer(canvas);
            this.physics = new Physics();
            this.input = new InputManager();
    
            this.scene = this.renderer.scene;
            this.camera = this.renderer.camera;
    
            // Centralized entity management
            this.entities = new Set();
            
            this.settings = {};
            this.levelName = '';
            this.ambientLight = null;
            this.spawnPoint = new THREE.Vector3(0, 5, 10);
            this.deathSpawnPoint = new THREE.Vector3(0, 5, 12);
            this.spawnPointHelper = null;
            this.deathSpawnPointHelper = null;
            this.gridHelper = null;
        }
    
        // --- Entity Getters ---
        getEntities(type) {
            return [...this.entities].filter(e => e.userData?.gameEntity?.type === type);
        }
        getLevelObjects() { return this.getEntities('Object'); }
        getNPCs() { return this.getEntities('NPC'); }
        getTriggers() { return this.getEntities('Trigger'); }
        getDeathTriggers() { return this.getEntities('DeathTrigger'); }
        getDirectionalLights() { return this.getEntities('DirectionalLight'); }
        getWaterVolumes() { return this.getEntities('Water'); }
        getWaterfalls() { return this.getEntities('Waterfall'); }
    
        async init() {
            this.gridHelper = new THREE.GridHelper(200, 200, 0xcccccc, 0x888888);
            this.gridHelper.material.opacity = 0.2;
            this.gridHelper.material.transparent = true;
            this.scene.add(this.gridHelper);
    
            this.levelManager = new LevelManager(this);
            await this.levelManager.init();
            this.editor = new LevelEditor(this);
            await this.editor.actions.newLevel();
            window.editorApp = this;
            this.renderer.renderer.setAnimationLoop(() => this.animate());
        }
    
        add(entity) {
            if (!entity || this.entities.has(entity)) return;
    
            this.entities.add(entity);
            const gameEntityType = entity.userData?.gameEntity?.type;
    
            if (gameEntityType === 'DirectionalLight') {
                this.scene.add(entity.light, entity.light.target, entity.helper, entity.picker, entity.targetHelper);
            } else if (gameEntityType === 'SpawnPoint' || gameEntityType === 'DeathSpawnPoint') {
                 this.scene.add(entity);
            } else {
                if (entity.mesh) this.scene.add(entity.mesh);
                if (entity.helperMesh) this.scene.add(entity.helperMesh); // For water volume helpers
                if (entity.body) this.physics.addBody(entity.body);
            }
        }
    
        remove(entity, dispose = true) {
            if (!entity || !this.entities.has(entity)) return;
            
            const gameEntityType = entity.userData?.gameEntity?.type;
    
            if (gameEntityType === 'DirectionalLight') {
                this.removeDirectionalLight(entity, dispose);
            } else {
                this.removeGenericEntity(entity, dispose);
            }
            this.entities.delete(entity);
        }
    
        async loadLevel(levelData) {
            this.clearLevel();
            const { ambientLight, directionalLights } = await this.levelManager.build(levelData);
    
            this.settings = levelData.settings;
            this.levelName = levelData.name;
            this.ambientLight = ambientLight;
            this.scene.add(this.ambientLight);
    
            directionalLights.forEach(light => {
                const lightObject = this.createDirectionalLightWithHelper(light);
                this.add(lightObject);
            });
            
            this.createSpawnPointHelper();
            this.createDeathSpawnPointHelper();
            this.editor.onLevelLoaded();
        }
    
        createDirectionalLightWithHelper(light) {
            const helper = new THREE.DirectionalLightHelper(light, 5, 0xffffff);
            if (helper.lightPlane?.material) helper.lightPlane.material.depthTest = false;
            
            const picker = new THREE.Mesh( new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ visible: false }));
            picker.position.copy(light.position);
    
            const targetHelper = new THREE.Mesh( new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true }));
            targetHelper.position.copy(light.target.position);
            
            const lightObject = { light, helper, picker, targetHelper, definition: light.userData.definition };
            
            lightObject.userData = { gameEntity: { type: 'DirectionalLight', entity: lightObject } };
            picker.userData.gameEntity = lightObject.userData.gameEntity;
            targetHelper.userData.gameEntity = { type: 'LightTarget', entity: targetHelper, parentLight: lightObject };
    
            return lightObject;
        }
        
        removeDirectionalLight(lightObject, dispose = true) {
            if (!lightObject) return;
            this.scene.remove(lightObject.light.target, lightObject.light, lightObject.helper, lightObject.picker, lightObject.targetHelper);
            
            if (dispose) {
                lightObject.helper.dispose();
                lightObject.picker.geometry.dispose();
                lightObject.picker.material.dispose();
                lightObject.targetHelper.geometry.dispose();
                lightObject.targetHelper.material.dispose();
                lightObject.light.dispose();
            }
        }
        
        removeGenericEntity(entity, dispose = true) {
            if (!entity) return;
            const mesh = entity.mesh || entity;
            this.scene.remove(mesh);
            if (entity.helperMesh) this.scene.remove(entity.helperMesh);
            
            if (dispose && mesh.geometry) {
                mesh.geometry.dispose();
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => m.dispose());
                } else if (mesh.material?.dispose) {
                    mesh.material.dispose();
                }
            }
            if (dispose && entity.helperMesh?.geometry) {
                entity.helperMesh.geometry.dispose();
                entity.helperMesh.material.dispose();
            }
            if (entity.body) this.physics.queueForRemoval(entity.body);
        }
    
        createSpawnPointHelper() {
            const helper = new THREE.AxesHelper(2);
            helper.material.depthTest = false;
            helper.position.copy(this.spawnPoint);
            helper.add(new THREE.Mesh( new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 })));
            helper.userData.gameEntity = { type: 'SpawnPoint', entity: helper };
            helper.children[0].userData.gameEntity = helper.userData.gameEntity;
            this.spawnPointHelper = helper;
            this.add(helper);
        }
    
        createDeathSpawnPointHelper() {
            const helper = new THREE.AxesHelper(2);
            helper.material.depthTest = false;
            helper.position.copy(this.deathSpawnPoint);
            helper.add(new THREE.Mesh( new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.6 })));
            helper.userData.gameEntity = { type: 'DeathSpawnPoint', entity: helper };
            helper.children[0].userData.gameEntity = helper.userData.gameEntity;
            this.deathSpawnPointHelper = helper;
            this.add(helper);
        }
    
        clearLevel() {
            this.editor.deselect();
            [...this.entities].forEach(entity => this.remove(entity));
            this.entities.clear();
            this.spawnPointHelper = null;
            this.deathSpawnPointHelper = null;
            if (this.ambientLight) {
                this.scene.remove(this.ambientLight);
                this.ambientLight.dispose();
                this.ambientLight = null;
            }
            if (this.scene.background && this.scene.background.isTexture) {
                this.scene.background.dispose();
                this.scene.background = null;
            }
        }
    
        animate() {
            const deltaTime = this.clock.getDelta();
            const elapsedTime = this.clock.elapsedTime;
            
            const entitiesWithShaders = [...this.getWaterVolumes(), ...this.getWaterfalls()];
            for (const entity of entitiesWithShaders) {
                const uniforms = entity.mesh?.material?.uniforms;
                if (uniforms) {
                    if (uniforms.time) { // For THREE.Water pools
                        uniforms.time.value = elapsedTime;
                    }
                    if (uniforms.uTime) { // For custom waterfall shader
                        uniforms.uTime.value = elapsedTime;
                    }
                }
            }
            
            this.physics.update(deltaTime);
            this.editor.update(deltaTime);
            this.renderer.render();
        }
    }
--------------------------------------------------
=== END OF FILE: src/editor/EditorApp.js ===


=== FILE: src/editor/EditorCamera.js ===
--------------------------------------------------
// src/editor/EditorCamera.js

import * as THREE from 'three';

/**
 * Implements the editor's first-person fly-camera controls.
 * It reads from the InputManager to move and rotate the camera.
 */
export class EditorCamera {
    constructor(editor) {
        this.editor = editor;
        this.camera = editor.camera;
        this.input = editor.input;
    }

    update(deltaTime) {
        // Prevent camera movement while transform controls are active or input is disabled
        if (this.editor.controls.transformControls.dragging || !this.input.enabled) {
            this.input.update();
            return;
        }

        const moveSpeed = 50 * deltaTime;
        const forward = new THREE.Vector3();
        this.camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(this.camera.up, forward).negate();
        
        if (this.input.keys['KeyW']) this.camera.position.addScaledVector(forward, moveSpeed);
        if (this.input.keys['KeyS']) this.camera.position.addScaledVector(forward, -moveSpeed);
        if (this.input.keys['KeyA']) this.camera.position.addScaledVector(right, -moveSpeed);
        if (this.input.keys['KeyD']) this.camera.position.addScaledVector(right, moveSpeed);
        if (this.input.keys['Space']) this.camera.position.y += moveSpeed;
        if (this.input.keys['ShiftLeft']) this.camera.position.y -= moveSpeed;
        
        // REVISED: Left-click to look around
        if (this.input.mouse.leftClick && !this.editor.ui.isClickOnUI(this.input.mouse.screenX, this.input.mouse.screenY)) {
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            euler.setFromQuaternion(this.camera.quaternion);
            euler.y -= this.input.mouse.movementX * 0.002;
            euler.x -= this.input.mouse.movementY * 0.002;
            euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
            this.camera.quaternion.setFromEuler(euler);
        }

        this.input.update();
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorCamera.js ===


=== FILE: src/editor/EditorControls.js ===
--------------------------------------------------
import * as THREE from 'three';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';
    import { StateChangeCommand } from './UndoManager.js';
    
    /**
     * Manages object selection via raycasting, and manipulation via TransformControls (gizmos).
     * It listens for mouse events on the canvas and interacts with the selected object.
     */
    export class EditorControls {
        constructor(editor) {
            this.editor = editor;
            this.app = editor.app;
            this.scene = editor.scene;
            this.camera = editor.camera;
            this.renderer = editor.app.renderer.renderer;
            this.input = editor.input;
    
            this.raycaster = new THREE.Raycaster();
            this.mouse = new THREE.Vector2();
            
            this._initialDragState = null;
    
            this._onMouseDownHandler = this.onMouseDown.bind(this);
            this._onContextMenuHandler = (e) => e.preventDefault();
            
            this.init();
        }
        
        init() {
            this.transformControls = new TransformControls(this.camera, this.renderer.domElement);
            this.transformControls.addEventListener('dragging-changed', (event) => this.onDraggingChanged(event));
            this.transformControls.addEventListener('objectChange', () => this.onObjectChange());
            this.scene.add(this.transformControls);
    
            this.selectionBoxGroup = new THREE.Group();
            this.selectionBoxGroup.renderOrder = 999;
            this.scene.add(this.selectionBoxGroup);
            
            this.applySnapSettings();
            
            this.renderer.domElement.addEventListener('mousedown', this._onMouseDownHandler, false);
            this.renderer.domElement.addEventListener('contextmenu', this._onContextMenuHandler, false);
        }
    
        dispose() {
            this.renderer.domElement.removeEventListener('mousedown', this._onMouseDownHandler, false);
            this.renderer.domElement.removeEventListener('contextmenu', this._onContextMenuHandler, false);
            this.transformControls.dispose();
            this.scene.remove(this.transformControls);
            this.scene.remove(this.selectionBoxGroup);
            this.clearSelectionBoxes();
        }
    
        onDraggingChanged(event) {
            this.input.enabled = !event.value;
            const selected = this.editor.selectedObjects;
            if (selected.size === 0) return;
    
            if (event.value) { // Drag started
                this._initialDragState = [];
                selected.forEach(entity => {
                    let definitionHolder = entity;
                    if (entity.userData.gameEntity.type === 'LightTarget') {
                        definitionHolder = entity.userData.gameEntity.parentLight;
                    }
                    this._initialDragState.push({
                        entity, // The object being dragged
                        definitionHolder,
                        definition: JSON.parse(JSON.stringify(definitionHolder.definition))
                    });
                });
                // For group scaling, we need the initial mesh scales
                if (this.transformControls.mode === 'scale' && selected.size > 1) {
                    this._initialDragState.forEach(state => {
                        const mesh = state.entity.helperMesh || state.entity.mesh || state.entity.picker || state.entity;
                        state.initialScale = mesh.scale.clone();
                    });
                }
            } else { // Drag ended
                this.detachFromGroup();
                
                const changes = [];
                this._initialDragState.forEach(state => {
                    const { entity, definitionHolder, definition } = state;
                    const afterState = JSON.parse(JSON.stringify(definition)); // Start with old state
                    const mesh = entity; // The dragged mesh is the 'entity' from the drag state
                    
                    if (definitionHolder.userData.gameEntity.type === 'DirectionalLight') {
                        if (entity.userData.gameEntity.type === 'LightTarget') {
                            // Dragged the target helper
                            afterState.targetPosition = { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z };
                        } else { // This would be the light source (picker)
                            afterState.position = { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z };
                        }
                    } else {
                        afterState.position = { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z };
                        if (afterState.rotation) {
                            const euler = new THREE.Euler().setFromQuaternion(mesh.quaternion, 'YXZ');
                            afterState.rotation = { x: THREE.MathUtils.radToDeg(euler.x), y: THREE.MathUtils.radToDeg(euler.y), z: THREE.MathUtils.radToDeg(euler.z) };
                        }
                        
                        if (this.transformControls.mode === 'scale' && afterState.size) {
                            const groupScale = this.editor.selectionGroup.scale;
                            const finalScale = selected.size > 1 ? groupScale : mesh.scale;
                            const baseSize = new THREE.Vector3().fromArray(definition.size);
                            const newSize = baseSize.clone().multiply(finalScale);
                            afterState.size = newSize.toArray();
                        }
                    }
    
                    changes.push({ entity: definitionHolder, beforeState: definition, afterState });
                });
                
                const command = new StateChangeCommand(this.editor, changes);
                this.editor.undoManager.execute(command);
                
                this._initialDragState = null;
                this.updateSelection();
            }
        }
    
        onObjectChange() {
            if (this.editor.primarySelectedObject && !this.transformControls.dragging) {
                this.editor.syncObjectTransforms();
                this.editor.ui.updatePropertiesPanel();
            } else if (this.transformControls.dragging) {
                const draggedObject = this.transformControls.object;
                if (draggedObject?.userData.gameEntity?.type === 'LightTarget') {
                    this.editor.syncObjectTransforms(draggedObject.userData.gameEntity.parentLight);
                } else if (draggedObject === this.editor.selectionGroup) {
                     this.editor.selectedObjects.forEach(entity => this.editor.syncObjectTransforms(entity));
                } else if (this.editor.primarySelectedObject) {
                    this.editor.syncObjectTransforms(this.editor.primarySelectedObject);
                }
                this.editor.ui.updatePropertiesPanel();
            }
        }
    
        onMouseDown(event) {
            if (event.button !== 2 || this.transformControls.dragging || this.editor.ui.isClickOnUI(event.clientX, event.clientY)) return;
            
            const rect = this.renderer.domElement.getBoundingClientRect();
            this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
            this.raycaster.setFromCamera(this.mouse, this.camera);
    
            const pickableMeshes = [...this.app.entities]
                .map(e => [e.mesh, e.picker, e.targetHelper, e.helperMesh])
                .flat()
                .filter(Boolean);
                
            const intersects = this.raycaster.intersectObjects(pickableMeshes.filter(m => m.visible), true);
            const validIntersects = intersects.filter(i => i.object.userData.gameEntity?.entity);
            
            if (validIntersects.length > 0) {
                const entity = validIntersects[0].object.userData.gameEntity.entity;
                if (entity.definition?.editorSelectable === false) {
                     this.editor.deselect();
                } else {
                     if (event.shiftKey) {
                         if (this.editor.selectedObjects.has(entity)) {
                             this.editor.removeFromSelection(entity);
                         } else {
                             this.editor.addToSelection(entity);
                         }
                     } else {
                        this.editor.select(entity);
                     }
                }
            } else {
                if (!event.shiftKey) {
                    this.editor.deselect();
                }
            }
        }
        
        updateSelection() {
            this.detachFromGroup();
            this.transformControls.detach();
            this.clearSelectionBoxes();
        
            const selected = this.editor.selectedObjects;
            if (selected.size === 0) return;
        
            if (selected.size === 1) {
                const entity = selected.values().next().value;
                const objectToAttach = entity.helperMesh || entity.mesh || entity.picker || entity.targetHelper || entity;
                
                this.transformControls.attach(objectToAttach);
                this.addSelectionBox(objectToAttach);
        
            } else {
                const selectionGroup = this.editor.selectionGroup;
                const centroid = new THREE.Vector3();
                selected.forEach(entity => {
                    const mesh = entity.helperMesh || entity.mesh || entity.picker || entity;
                    centroid.add(mesh.position);
                });
                centroid.divideScalar(selected.size);
                selectionGroup.position.copy(centroid);
                selectionGroup.rotation.set(0,0,0);
                selectionGroup.scale.set(1,1,1);
        
                selected.forEach(entity => {
                    const mesh = entity.helperMesh || entity.mesh || entity.picker || entity;
                    this.scene.remove(mesh);
                    selectionGroup.add(mesh);
                    this.addSelectionBox(mesh);
                });
        
                this.transformControls.attach(selectionGroup);
            }
            
            this.updateToolAvailability();
        }
    
        detachFromGroup() {
            const selectionGroup = this.editor.selectionGroup;
            const children = [...selectionGroup.children];
            for (const child of children) {
                child.updateWorldMatrix(true, false);
                selectionGroup.remove(child);
                this.scene.add(child);
            }
            selectionGroup.position.set(0,0,0);
            selectionGroup.rotation.set(0,0,0);
            selectionGroup.scale.set(1,1,1);
            selectionGroup.updateWorldMatrix(true, false);
        }
        
        updateSelectionBoxes() {
            this.selectionBoxGroup.children.forEach(box => box.update());
        }
        
        addSelectionBox(object) {
            const selectionBox = new THREE.BoxHelper(object, 0xffff00);
            selectionBox.material.depthTest = false;
            selectionBox.material.transparent = true;
            this.selectionBoxGroup.add(selectionBox);
        }
        
        clearSelectionBoxes() {
            while(this.selectionBoxGroup.children.length) {
                const box = this.selectionBoxGroup.children[0];
                this.selectionBoxGroup.remove(box);
                box.geometry.dispose();
                box.material.dispose();
            }
        }
        
        updateToolAvailability() {
            let canRotate = true, canScale = true;
            this.editor.selectedObjects.forEach(entity => {
                const entityType = entity.userData?.gameEntity?.type;
                const isEnemy = entityType === 'Enemy';
                const isLightTarget = entityType === 'LightTarget';
                const isSpecialPoint = ['SpawnPoint', 'DeathSpawnPoint', 'DirectionalLight'].includes(entityType);
    
                if (isSpecialPoint || isEnemy || isLightTarget) {
                    canRotate = false;
                    canScale = false;
                }
            });
    
            document.getElementById('tool-rotate').disabled = !canRotate;
            document.getElementById('tool-scale').disabled = !canScale;
    
            const mode = this.transformControls.getMode();
            // FIX: Changed this.controls.setTransformMode to this.setTransformMode
            if (!canRotate && mode === 'rotate') this.setTransformMode('translate');
            if (!canScale && mode === 'scale') this.setTransformMode('translate');
        }
    
        setTransformSpace(space) {
            this.transformControls.setSpace(space);
            this.editor.ui.updateSpaceToggle(this.transformControls.space);
        }
    
        toggleTransformSpace() {
            const currentSpace = this.transformControls.space;
            this.setTransformSpace(currentSpace === 'world' ? 'local' : 'world');
        }
    
        applySnapSettings() {
            const editor = this.editor;
            if (editor.isSnapEnabled) {
                this.transformControls.setTranslationSnap(editor.translationSnapValue);
                this.transformControls.setRotationSnap(THREE.MathUtils.degToRad(editor.rotationSnapValue));
                this.transformControls.setScaleSnap(editor.translationSnapValue);
            } else {
                this.transformControls.setTranslationSnap(null);
                this.transformControls.setRotationSnap(null);
                this.transformControls.setScaleSnap(null);
            }
        }
    
        setTransformMode(mode) {
            if (this.transformControls.object) {
                this.transformControls.setMode(mode);
                this.editor.ui.updateTransformModeButtons(mode);
            }
        }
    }
--------------------------------------------------
=== END OF FILE: src/editor/EditorControls.js ===


=== FILE: src/editor/EditorUI.js ===
--------------------------------------------------
// src/editor/EditorUI.js
 import * as THREE from 'three';
    import { StateChangeCommand } from './UndoManager.js';
    
    export class EditorUI {
        constructor(editor) {
            this.editor = editor;
            this.app = editor.app;
            this.skyboxOptions = [];
            this.init();
        }
    
        init() {
            // Fetch skybox manifest
            fetch('./assets/skyboxes/manifest.json')
                .then(res => res.ok ? res.json() : Promise.resolve([]))
                .then(data => { this.skyboxOptions = data; })
                .catch(err => console.error("Could not load skybox manifest.", err));
                
            // --- File Menu ---
            document.getElementById('menu-file-new').onclick = async () => await this.editor.actions.newLevel();
            document.getElementById('menu-file-open').onclick = () => document.getElementById('editor-file-input').click();
            document.getElementById('editor-file-input').onchange = async (e) => await this.editor.actions.loadFile(e);
            document.getElementById('menu-file-save').onclick = () => this.editor.actions.saveFile();
            document.getElementById('menu-file-play').onclick = () => this.editor.actions.playInDebugMode();
            document.getElementById('menu-file-exit').onclick = () => { window.location.href = 'index.html'; };
    
            // --- Edit Menu ---
            document.getElementById('menu-edit-undo').onclick = () => this.editor.undoManager.undo();
            document.getElementById('menu-edit-redo').onclick = () => this.editor.undoManager.redo();
            document.getElementById('menu-edit-copy').onclick = () => this.editor.actions.copySelected();
            document.getElementById('menu-edit-paste').onclick = () => this.editor.actions.pasteFromClipboard();
            document.getElementById('menu-edit-delete').onclick = () => this.editor.actions.deleteSelected();
            
            // --- View Menu ---
            document.getElementById('view-toggle-grid').onchange = (e) => { if(this.app.gridHelper) this.app.gridHelper.visible = e.target.checked; };
            document.getElementById('view-toggle-light-helpers').onchange = (e) => this.setHelpersVisibility('DirectionalLight', e.target.checked);
            document.getElementById('view-toggle-spawn-helpers').onchange = (e) => this.setHelpersVisibility('SpawnAndDeath', e.target.checked);
            document.getElementById('view-toggle-msg-triggers').onchange = (e) => this.setHelpersVisibility('Trigger', e.target.checked);
            document.getElementById('view-toggle-death-triggers').onchange = (e) => this.setHelpersVisibility('DeathTrigger', e.target.checked);
            document.getElementById('view-toggle-water-volumes').onchange = (e) => this.setHelpersVisibility('Water', e.target.checked);
            
            // --- Help Menu ---
            document.getElementById('menu-help-metrics').onclick = (event) => {
                event.preventDefault(); // Prevents the <details> menu from closing
                this.showInfoModal();
            };
    
            // --- Toolbar ---
            document.getElementById('tool-translate').onclick = () => this.editor.controls.setTransformMode('translate');
            document.getElementById('tool-rotate').onclick = () => this.editor.controls.setTransformMode('rotate');
            document.getElementById('tool-scale').onclick = () => this.editor.controls.setTransformMode('scale');
            document.getElementById('tool-space').onclick = () => this.editor.controls.toggleTransformSpace();
            
            // --- Snapping Controls ---
            const snapToggle = document.getElementById('snap-toggle');
            const transSnapInput = document.getElementById('snap-translation-input');
            const rotSnapInput = document.getElementById('snap-rotation-input');
            const snapLabel = document.querySelector('label[for="snap-toggle"]');
    
            snapToggle.onchange = (e) => this.editor.setSnapEnabled(e.target.checked);
            transSnapInput.onchange = (e) => this.editor.setTranslationSnap(parseFloat(e.target.value));
            rotSnapInput.onchange = (e) => this.editor.setRotationSnap(parseFloat(e.target.value));
            if (snapLabel) snapLabel.onclick = () => snapToggle.click();
    
            // Set initial UI values from editor state
            snapToggle.checked = this.editor.isSnapEnabled;
            transSnapInput.value = this.editor.translationSnapValue;
            rotSnapInput.value = this.editor.rotationSnapValue;
            
            // --- Create Button & Context Menu ---
            const createButton = document.getElementById('create-button');
            const createMenu = document.getElementById('create-context-menu');
            createButton.onclick = (e) => {
                e.stopPropagation(); // Prevent document click listener from firing immediately
                createMenu.style.display = createMenu.style.display === 'none' ? 'flex' : 'none';
            };
            createMenu.onclick = (e) => {
                const action = e.target.dataset.action;
                if (action && typeof this.editor.actions[action] === 'function') {
                    this.editor.actions[action]();
                }
                createMenu.style.display = 'none'; // Hide menu after action
            };
            // Hide menu if clicking anywhere else
            document.addEventListener('click', () => { createMenu.style.display = 'none'; });
    
            // --- Outliner ---
            this.outlinerContent = document.getElementById('outliner-content');
            this.outlinerContent.onclick = (e) => {
                const item = e.target.closest('.outliner-item');
                if (item) {
                    if (e.shiftKey) {
                        const entity = this.findEntityByUUID(item.dataset.uuid);
                        if (entity) {
                            if (this.editor.selectedObjects.has(entity)) {
                                this.editor.removeFromSelection(entity);
                            } else {
                                this.editor.addToSelection(entity);
                            }
                        }
                    } else {
                        this.editor.selectByUUID(item.dataset.uuid);
                    }
                }
            };
            
            // --- Inspector ---
            this.inspectorContent = document.getElementById('inspector-content');
            this.inspectorPlaceholder = this.inspectorContent.querySelector('.placeholder-text');
    
            // --- Modal Events ---
            document.querySelector('#editor-info-modal .modal-close-btn').onclick = () => { document.getElementById('editor-info-modal').style.display = 'none'; };
            document.getElementById('editor-info-modal').onclick = (e) => { if(e.target === e.currentTarget) e.currentTarget.style.display = 'none'; };
    
            // Top Menu Hover Logic to close other menus
            const menuDropdowns = document.querySelectorAll('.menu-dropdown');
            menuDropdowns.forEach(dropdown => {
                dropdown.addEventListener('mouseenter', () => dropdown.open = true);
                dropdown.addEventListener('mouseleave', () => dropdown.open = false);
                dropdown.addEventListener('pointerenter', () => {
                     if (document.querySelector('.menu-dropdown[open]') && document.querySelector('.menu-dropdown[open]') !== dropdown) {
                        document.querySelector('.menu-dropdown[open]').open = false;
                     }
                });
            });
        }
    
        findEntityByUUID(uuid) {
            return [...this.app.entities].find(e => {
                const mesh = e.mesh || e.picker || e.targetHelper || e;
                return mesh?.uuid === uuid;
            });
        }
    
        /**
         * REWORKED: Robustly checks if coordinates are over any UI panel.
         * This now uses elementFromPoint to correctly handle any element,
         * including inputs and their pop-ups (like the color picker).
         * @param {number} x - The screen X coordinate.
         * @param {number} y - The screen Y coordinate.
         * @returns {boolean}
         */
        isClickOnUI(x, y) {
            const el = document.elementFromPoint(x, y);
            if (!el) return false;
    
            const uiAreas = [
                document.getElementById('editor-menu-bar'),
                document.getElementById('editor-toolbar'),
                document.getElementById('editor-outliner'),
                document.getElementById('editor-inspector'),
                document.getElementById('create-button-container'),
            ];
        
            return uiAreas.some(area => area && area.contains(el));
        }
    
        showInfoModal() {
            const playerRadius = 0.8;
            const speed = 8;
            const jumpVy = 8;
            const dashMultiplier = 4;
            const dashDuration = 0.2;
            const gravity = 9.82; 
    
            const playerHeight = playerRadius * 2;
            const dashSpeed = speed * dashMultiplier;
            const groundDashDist = dashSpeed * dashDuration;
            const timeToPeak1 = jumpVy / gravity;
            const height1 = (jumpVy * jumpVy) / (2 * gravity);
            const airTime1 = 2 * timeToPeak1;
            const distance1 = speed * airTime1;
            const height2 = height1 + height1;
            const timeToFallFromH2 = Math.sqrt((2 * height2) / gravity);
            const airTime2_height = timeToPeak1 + timeToFallFromH2;
            const distance2_height = speed * airTime2_height;
            const horizontalDistToPeak = speed * timeToPeak1;
            const jumpDashDist = horizontalDistToPeak + groundDashDist + (speed * timeToPeak1);
    
            const infoText = `
    [Base Parameters]
    Player Collider Height: ${playerHeight.toFixed(2)}m
    Ground Speed          : ${speed.toFixed(2)} m/s
    Dash Speed            : ${dashSpeed.toFixed(2)} m/s
    Gravity               : ${gravity.toFixed(2)} m/s²
    
    [Ground Movement]
    Dash Distance         : ${groundDashDist.toFixed(2)}m
    
    [Single Jump]
    Max Height            : ${height1.toFixed(2)}m (Gap clearance: ${(height1 + playerHeight).toFixed(2)}m)
    Max Distance          : ${distance1.toFixed(2)}m
    Air Time              : ${airTime1.toFixed(2)}s
    
    [Double Jump (for max height)]
    Max Height            : ${height2.toFixed(2)}m (Gap clearance: ${(height2 + playerHeight).toFixed(2)}m)
    Horizontal Distance   : ${distance2_height.toFixed(2)}m
    Air Time              : ${airTime2_height.toFixed(2)}s
    
    [Jump + Dash (for max distance)]
    Max Distance          : ${jumpDashDist.toFixed(2)}m
    
    NOTE: Distances are ideal, assuming flat ground. "Gap clearance" is max height + player height.
            `.trim();
    
            document.getElementById('info-modal-text').textContent = infoText;
            document.getElementById('editor-info-modal').style.display = 'flex';
        }
    
        updateTransformModeButtons(mode) {
            ['translate', 'rotate', 'scale'].forEach(m => {
                document.getElementById(`tool-${m}`).classList.toggle('active', m === mode);
            });
        }
    
        updateSpaceToggle(space) {
            document.getElementById('tool-space').textContent = space === 'world' ? 'World' : 'Local';
        }
    
        updateOutliner() {
            this.outlinerContent.innerHTML = '';
            const createItem = (parent, entity, name, uuid, prefix = '') => {
                const item = document.createElement('div');
                item.className = 'outliner-item';
                item.textContent = `${prefix} ${name}`;
                item.dataset.uuid = uuid;
                if (this.editor.selectedObjects.has(entity)) {
                    item.classList.add('selected');
                }
                parent.appendChild(item);
            };
        
            const createCategory = (title, entities, prefix) => {
                if (!entities || entities.length === 0) return;
                const details = document.createElement('details');
                details.open = true;
                const summary = document.createElement('summary');
                summary.textContent = `${title} (${entities.length})`;
                details.appendChild(summary);
                entities.forEach(e => {
                    let name;
                    if (e.userData?.gameEntity?.type === 'NPC') {
                        const team = e.definition.team === 'player' ? 'Ally' : 'Enemy';
                        const type = e.definition.attackType.charAt(0).toUpperCase() + e.definition.attackType.slice(1);
                        name = `${type} ${team}`;
                    } else {
                        name = e.definition?.name || e.name || e.userData?.gameEntity?.type || 'Unnamed';
                    }
                     
                    const uuidProvider = e.mesh || e.picker || e.helperMesh || e.targetHelper || e;
                    if(uuidProvider) {
                        createItem(details, e, name, uuidProvider.uuid, prefix);
                    }
                });
                this.outlinerContent.appendChild(details);
            };
        
            const spawnPoints = [this.app.spawnPointHelper, this.app.deathSpawnPointHelper].filter(Boolean);
            spawnPoints.forEach(sp => {
                sp.name = sp.userData.gameEntity.type === 'SpawnPoint' ? 'Initial Spawn' : 'Death Respawn';
            });
        
            createCategory('Scene Points', spawnPoints, '[P]');
            createCategory('Lights', this.app.getDirectionalLights(), '[L]');
            createCategory('Geometry', this.app.getLevelObjects(), '[G]');
            createCategory('NPCs', this.app.getNPCs(), '[N]');
            createCategory('Message Triggers', this.app.getTriggers(), '[T]');
            createCategory('Death Zones', this.app.getDeathTriggers(), '[D]');
            createCategory('Water Volumes', this.app.getWaterVolumes(), '[W]');
        }
    
        updatePropertiesPanel() {
            if (this.inspectorContent.contains(document.activeElement) && document.activeElement.tagName === 'INPUT') {
                return;
            }
    
            this.inspectorContent.innerHTML = '';
            const fragment = document.createDocumentFragment();
            
            const handleEnterKey = (e, updateFn) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    updateFn(e.target.value);
                    e.target.blur();
                }
            };
        
            const createPropGroup = (label) => {
                const group = document.createElement('div');
                group.className = 'prop-group';
                const labelEl = document.createElement('label');
                labelEl.textContent = label;
                group.appendChild(labelEl);
                fragment.appendChild(group);
                return group;
            };
    
            const createTextInput = (parent, value, callback) => {
                const input = document.createElement('input');
                input.type = 'text';
                input.value = value;
                const updateValue = (val) => callback(val);
                input.onchange = (e) => updateValue(e.target.value);
                input.onkeydown = (e) => handleEnterKey(e, updateValue);
                parent.appendChild(input);
                return input;
            };
        
            const createNumberInput = (parent, value, { min, max, step = 0.1 }, callback) => {
                const input = document.createElement('input');
                input.type = 'number';
                if (min !== undefined) input.min = min;
                if (max !== undefined) input.max = max;
                input.step = step;
                input.value = value;
                const updateValue = (val) => callback(parseFloat(val) || 0);
                input.onchange = (e) => updateValue(e.target.value);
                input.onkeydown = (e) => handleEnterKey(e, updateValue);
                parent.appendChild(input);
                return input;
            };
    
            const createColorInput = (parent, colorHex, callback) => {
                const input = document.createElement('input');
                input.type = 'color';
                input.value = colorHex;
                input.oninput = (e) => callback(e.target.value);
                parent.appendChild(input);
                return input;
            };

            const createSelectInput = (parent, value, options, callback) => {
                const select = document.createElement('select');
                for (const [val, text] of Object.entries(options)) {
                    const option = document.createElement('option');
                    option.value = val;
                    option.textContent = text;
                    select.appendChild(option);
                }
                select.value = value;
                select.onchange = (e) => callback(e.target.value);
                parent.appendChild(select);
                return select;
            };
        
            const createVec3Inputs = (parent, vector, step, callback) => {
                const inputGroup = document.createElement('div');
                inputGroup.className = 'prop-input-group';
                ['x', 'y', 'z'].forEach(axis => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.step = step;
                    input.value = vector[axis].toFixed(3);
                    const updateValue = (val) => callback(axis, parseFloat(val) || 0);
                    input.onchange = (e) => updateValue(e.target.value);
                    input.onkeydown = (e) => handleEnterKey(e, updateValue);
                    inputGroup.appendChild(input);
                });
                parent.appendChild(inputGroup);
                return inputGroup;
            };
    
            if (this.editor.selectedObjects.size === 0) {
                this.renderSceneSettings(fragment, createPropGroup, createColorInput, createNumberInput);
            } else {
                if (this.editor.selectedObjects.size > 1) {
                    const multiSelectInfo = document.createElement('div');
                    multiSelectInfo.className = 'placeholder-text';
                    multiSelectInfo.innerHTML = `<b>${this.editor.selectedObjects.size} objects selected.</b><br>Properties shown for primary selection.`;
                    fragment.appendChild(multiSelectInfo);
                }
                this.renderEntitySettings(fragment, createPropGroup, createTextInput, createColorInput, createNumberInput, createVec3Inputs, createSelectInput);
            }
    
            this.inspectorContent.appendChild(fragment);
        }
        
        renderSceneSettings(fragment, createPropGroup, createColorInput, createNumberInput) {
            const settings = this.app.settings;
            const groupTitle = document.createElement('div');
            groupTitle.className = 'placeholder-text';
            groupTitle.innerHTML = '<b>Scene Settings</b>';
            fragment.appendChild(groupTitle);
            
            const skyboxGroup = createPropGroup('Skybox');
            const select = document.createElement('select');
            select.onchange = (e) => this.editor.updateSceneSetting('skybox', e.target.value);
    
            const noneOption = document.createElement('option');
            noneOption.value = '';
            noneOption.textContent = 'None (Use Background Color)';
            select.appendChild(noneOption);
    
            this.skyboxOptions.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.path;
                option.textContent = opt.name;
                select.appendChild(option);
            });
            select.value = settings.skybox || '';
            skyboxGroup.appendChild(select);
            
            fragment.appendChild(document.createElement('hr'));
            
            const bgGroup = createPropGroup('Background Color');
            const bgColor = settings.backgroundColor ? '#' + new THREE.Color(parseInt(settings.backgroundColor, 16)).getHexString() : '#000000';
            createColorInput(bgGroup, bgColor, (val) => this.editor.updateSceneSetting('backgroundColor', val.replace('#', '0x')));
            
            const fogGroup = createPropGroup('Fog Color');
            const fogColor = settings.fogColor ? '#' + new THREE.Color(parseInt(settings.fogColor, 16)).getHexString() : '#000000';
            createColorInput(fogGroup, fogColor, (val) => this.editor.updateSceneSetting('fogColor', val.replace('#', '0x')));
            
            const fogDistGroup = createPropGroup('Fog Distance (Near / Far)');
            const fogDistContainer = document.createElement('div');
            fogDistContainer.className = 'prop-input-group';
            createNumberInput(fogDistContainer, settings.fogNear || 10, {min: 0, step: 1}, (val) => this.editor.updateSceneSetting('fogNear', val));
            createNumberInput(fogDistContainer, settings.fogFar || 200, {min: 0, step: 1}, (val) => this.editor.updateSceneSetting('fogFar', val));
            fogDistGroup.appendChild(fogDistContainer);
            
            fragment.appendChild(document.createElement('hr'));
    
            const ambientGroup = createPropGroup('Ambient Light');
            const ambientContainer = document.createElement('div');
            ambientContainer.className = 'prop-input-group';
            const ambientColor = settings.ambientLight.color ? '#' + new THREE.Color(parseInt(settings.ambientLight.color, 16)).getHexString() : '#ffffff';
            createColorInput(ambientContainer, ambientColor, (val) => this.editor.updateSceneSetting('ambientLight.color', val.replace('#', '0x')));
            createNumberInput(ambientContainer, settings.ambientLight.intensity || 1, {min: 0, max: 5, step: 0.1}, (val) => this.editor.updateSceneSetting('ambientLight.intensity', val));
            ambientGroup.appendChild(ambientContainer);
        }
        
        renderEntitySettings(fragment, createPropGroup, createTextInput, createColorInput, createNumberInput, createVec3Inputs, createSelectInput) {
            const selectedEntity = this.editor.primarySelectedObject;
            if (!selectedEntity || !selectedEntity.userData?.gameEntity?.type) return;
    
            let propertySourceEntity = selectedEntity;
            const originallySelectedType = selectedEntity.userData.gameEntity.type;
            if (originallySelectedType === 'LightTarget') {
                propertySourceEntity = selectedEntity.userData.gameEntity.parentLight;
            }
    
            const entityType = propertySourceEntity.userData.gameEntity.type;
            const def = propertySourceEntity.definition;
            const mesh = selectedEntity.helperMesh || selectedEntity.mesh || selectedEntity.picker || selectedEntity;
    
            if (def && def.name !== undefined) {
                const group = createPropGroup('Name');
                const input = createTextInput(group, def.name, (val) => this.editor.updateSelectedProp('name', null, val));
                if (originallySelectedType === 'LightTarget') input.disabled = true;
            }
        
            fragment.appendChild(document.createElement('hr'));
        
            const posGroup = createPropGroup('Position');
            createVec3Inputs(posGroup, mesh.position, 0.25, (axis, val) => this.editor.updateSelectedProp('position', axis, val));
        
            if (def && def.rotation) {
                const rotGroup = createPropGroup('Rotation (Deg)');
                const eulerRot = new THREE.Euler().setFromQuaternion(mesh.quaternion, 'YXZ');
                const degRot = { x: THREE.MathUtils.radToDeg(eulerRot.x), y: THREE.MathUtils.radToDeg(eulerRot.y), z: THREE.MathUtils.radToDeg(eulerRot.z) };
                const inputs = createVec3Inputs(rotGroup, degRot, 1, (axis, val) => this.editor.updateSelectedProp('rotation', axis, val));
                if (originallySelectedType === 'LightTarget') inputs.querySelectorAll('input').forEach(i => i.disabled = true);
            }
        
            if (def && def.size) {
                if (def.type === 'Plane' || def.type === 'Waterfall') {
                    const widthGroup = createPropGroup('Width');
                    createNumberInput(widthGroup, def.size[0] * mesh.scale.x, { step: 0.25 }, (val) => { this.editor.updateSelectedProp('size', 0, val); });
                    const depthGroup = createPropGroup('Height');
                    createNumberInput(depthGroup, def.size[1] * mesh.scale.y, { step: 0.25 }, (val) => { this.editor.updateSelectedProp('size', 1, val); });
                } else {
                    const sizeGroup = createPropGroup('Size');
                    const displaySize = { x: def.size[0] * mesh.scale.x, y: def.size[1] * mesh.scale.y, z: def.size[2] * mesh.scale.z };
                    createVec3Inputs(sizeGroup, displaySize, 0.25, (axis, val) => {
                        const changes = [];
                        this.editor.selectedObjects.forEach(selEntity => {
                            const selMesh = selEntity.mesh || selEntity.picker || selEntity.helperMesh;
                            if (!selEntity.definition?.size || !selMesh) return;
                            const beforeDef = JSON.parse(JSON.stringify(selEntity.definition));
                            const afterDef = JSON.parse(JSON.stringify(beforeDef));
                            const map = { x: 0, y: 1, z: 2 };
                            afterDef.size[map[axis]] = val / selMesh.scale[axis];
                            changes.push({ entity: selEntity, beforeState: beforeDef, afterState: afterDef });
                        });
                        if (changes.length > 0) {
                            const command = new StateChangeCommand(this.editor, changes);
                            this.editor.undoManager.execute(command);
                        }
                    });
                }
            }
            
            if (entityType === 'NPC') {
                fragment.appendChild(document.createElement('hr'));
                const teamGroup = createPropGroup('Team');
                createSelectInput(teamGroup, def.team || 'enemy', { enemy: 'Enemy', player: 'Ally' }, (val) => this.editor.updateSelectedProp('team', null, val));
                
                const attackTypeGroup = createPropGroup('Attack Type');
                createSelectInput(attackTypeGroup, def.attackType || 'ranged', { ranged: 'Ranged', melee: 'Melee' }, (val) => this.editor.updateSelectedProp('attackType', null, val));
            }
        
            if (def && def.material) {
                fragment.appendChild(document.createElement('hr'));
                const matGroup = createPropGroup('Material Color');
                const initialColor = def.material.color ? '#' + new THREE.Color(parseInt(def.material.color, 16)).getHexString() : '#cccccc';
                createColorInput(matGroup, initialColor, (val) => this.editor.updateSelectedProp('material.color', null, val));
            }
        
            if (entityType === 'Trigger') {
                fragment.appendChild(document.createElement('hr'));
                const msgGroup = createPropGroup('Message');
                createTextInput(msgGroup, def.message || '', val => this.editor.updateSelectedProp('message', null, val));
                const durGroup = createPropGroup('Duration (s)');
                createNumberInput(durGroup, def.duration || 5, { min: 0.1, max: 100, step: 0.1 }, val => this.editor.updateSelectedProp('duration', null, val));
                const colorGroup = createPropGroup('Helper Color');
                const initialColor = def.color ? '#' + new THREE.Color(parseInt(def.color, 16)).getHexString() : '#00ff00';
                createColorInput(colorGroup, initialColor, val => this.editor.updateSelectedProp('color', null, val));
            }
        
            if (entityType === 'DirectionalLight') {
                fragment.appendChild(document.createElement('hr'));
                const lightGroup = createPropGroup('Light Color');
                const initialColor = def.color ? '#' + new THREE.Color(parseInt(def.color, 16)).getHexString() : '#ffffff';
                const colorInput = createColorInput(lightGroup, initialColor, val => this.editor.updateSelectedProp('color', null, val));
                if (originallySelectedType === 'LightTarget') colorInput.disabled = true;
        
                const intensityGroup = createPropGroup('Intensity');
                const intensityInput = createNumberInput(intensityGroup, propertySourceEntity.light.intensity, { min: 0, max: 20, step: 0.1 }, val => this.editor.updateSelectedProp('intensity', null, val));
                if (originallySelectedType === 'LightTarget') intensityInput.disabled = true;
        
                if (originallySelectedType !== 'LightTarget') {
                    const targetGroup = createPropGroup('Target Position');
                    createVec3Inputs(targetGroup, propertySourceEntity.light.target.position, 0.25, (axis, val) => this.editor.updateSelectedProp('targetPosition', axis, val));
                }
            }
        
            const deleteButton = document.createElement('button');
            deleteButton.className = 'delete-button';
            deleteButton.textContent = 'Delete Selected';
            deleteButton.onclick = () => this.editor.actions.deleteSelected();
            fragment.appendChild(deleteButton);
        }
        
        setHelpersVisibility(type, isVisible) {
            this.editor.helperVisibility[type] = isVisible;
        
            if (type === 'SpawnAndDeath') {
                if (this.app.spawnPointHelper) this.app.spawnPointHelper.visible = isVisible;
                if (this.app.deathSpawnPointHelper) this.app.deathSpawnPointHelper.visible = isVisible;
                return;
            }
        
            let entities;
            switch (type) {
                case 'DirectionalLight': entities = this.app.getDirectionalLights(); break;
                case 'Trigger': entities = this.app.getTriggers(); break;
                case 'DeathTrigger': entities = this.app.getDeathTriggers(); break;
                case 'Water': entities = this.app.getWaterVolumes(); break;
                default: entities = [];
            }
        
            entities.forEach(e => {
                if (type === 'DirectionalLight') {
                    if (e.helper) e.helper.visible = isVisible;
                    if (e.targetHelper) e.targetHelper.visible = isVisible;
                } else if (e.helperMesh) {
                    // For water, we toggle the helper box, not the visible surface
                    e.helperMesh.visible = isVisible;
                } else if (e.mesh) {
                    e.mesh.visible = isVisible;
                }
            });
        }
    }
--------------------------------------------------
=== END OF FILE: src/editor/EditorUI.js ===


=== FILE: src/editor/editor_main.js ===
--------------------------------------------------
import { EditorApp } from './EditorApp.js';

/**
 * The entry point for the level editor application.
 * It creates and initializes the main EditorApp instance.
 */
class Main {
    constructor() {
        this.app = new EditorApp();
    }

    async run() {
        try {
            await this.app.init();
        } catch(error) {
            console.error("Failed to initialize the editor application:", error);
            document.body.innerHTML = `<div style="color:red; text-align:center; margin-top: 50px;">
                <h1>Editor Failed to Start</h1>
                <p>Please check the console for errors.</p>
            </div>`;
        }
    }
}

const main = new Main();
main.run();
--------------------------------------------------
=== END OF FILE: src/editor/editor_main.js ===


=== FILE: src/editor/LevelEditor.js ===
--------------------------------------------------
// src/editor/LevelEditor.js
  import * as THREE from 'three';
    import * as CANNON from 'cannon-es';
    import { EditorControls } from './EditorControls.js';
    import { EditorUI } from './EditorUI.js';
    import { EditorActions } from './EditorActions.js';
    import { EditorCamera } from './EditorCamera.js';
    import { UndoManager, StateChangeCommand } from './UndoManager.js';
    import { COLLISION_GROUPS } from '../shared/CollisionGroups.js';
    
    export class LevelEditor {
        constructor(app) {
            this.app = app;
            this.scene = app.scene;
            this.camera = app.camera;
            this.renderer = app.renderer.renderer;
            this.physics = app.physics;
            this.input = app.input;
    
            // Core State
            this.selectedObjects = new Set();
            this.primarySelectedObject = null; // The one whose properties are shown in inspector
            this.clipboard = null;
            this.isSnapEnabled = false;
            this.translationSnapValue = 1;
            this.rotationSnapValue = 15;
            this.helperVisibility = {
                Trigger: true,
                DeathTrigger: true,
                DirectionalLight: true,
                SpawnAndDeath: true,
                Water: true,
            };
            
            // Group for multi-object transforms
            this.selectionGroup = new THREE.Group();
            this.scene.add(this.selectionGroup);
    
            // Modules
            this.undoManager = new UndoManager(this);
            this.ui = new EditorUI(this);
            this.controls = new EditorControls(this);
            this.actions = new EditorActions(this);
            this.cameraController = new EditorCamera(this);
            
            this.onKeyDownHandler = this.onKeyDown.bind(this);
            document.addEventListener('keydown', this.onKeyDownHandler);
        }
    
        dispose() {
            document.removeEventListener('keydown', this.onKeyDownHandler);
            this.controls.dispose();
        }
    
        onKeyDown(event) {
            if (event.target.tagName === 'INPUT' || this.controls.transformControls.dragging) return;
    
            if (event.ctrlKey) {
                switch (event.code) {
                    case 'KeyC': event.preventDefault(); if (this.selectedObjects.size > 0) this.actions.copySelected(); break;
                    case 'KeyV': event.preventDefault(); this.actions.pasteFromClipboard(); break;
                    case 'KeyZ': event.preventDefault(); this.undoManager.undo(); break;
                    case 'KeyY': event.preventDefault(); this.undoManager.redo(); break;
                }
            } else {
                switch (event.code) {
                    case 'KeyT': this.controls.setTransformMode('translate'); break;
                    case 'KeyR': this.controls.setTransformMode('rotate'); break;
                    case 'KeyS': this.controls.setTransformMode('scale'); break;
                    case 'KeyQ': this.controls.toggleTransformSpace(); break;
                    case 'Delete':
                    case 'Backspace': if (this.selectedObjects.size > 0) this.actions.deleteSelected(); break;
                }
            }
        }
    
        // --- State & Selection Management ---
    
        select(entity) {
            this.deselect();
            this.addToSelection(entity);
        }
    
        addToSelection(entity) {
            if (!entity || this.selectedObjects.has(entity)) return;
    
            this.selectedObjects.add(entity);
            this.primarySelectedObject = entity;
            this.controls.updateSelection();
            this.ui.updatePropertiesPanel();
            this.ui.updateOutliner();
        }
        
        removeFromSelection(entity) {
            if (!entity || !this.selectedObjects.has(entity)) return;
            this.selectedObjects.delete(entity);
            if (this.primarySelectedObject === entity) {
                this.primarySelectedObject = this.selectedObjects.size > 0 ? this.selectedObjects.values().next().value : null;
            }
            this.controls.updateSelection();
            this.ui.updatePropertiesPanel();
            this.ui.updateOutliner();
        }
    
        deselect() {
            if (this.selectedObjects.size === 0) return;
        
            this.controls.detachFromGroup();
            this.controls.transformControls.detach();
            this.controls.clearSelectionBoxes();
            
            this.selectedObjects.forEach(obj => {
                if (obj.userData?.gameEntity?.type === 'DirectionalLight') {
                    obj.picker.material.visible = false;
                }
            });
    
            this.selectedObjects.clear();
            this.primarySelectedObject = null;
            
            this.ui.updatePropertiesPanel();
            this.ui.updateOutliner();
            
            document.getElementById('tool-rotate').disabled = false;
            document.getElementById('tool-scale').disabled = false;
        }
    
        selectByUUID(uuid) {
            const entityToSelect = [...this.app.entities].find(e => {
                const mesh = e.mesh || e.picker || e.targetHelper || e.helperMesh;
                return mesh?.uuid === uuid;
            });
            if (entityToSelect) {
                this.select(entityToSelect);
            }
        }
    
        // --- Snap Control ---
        setSnapEnabled(isEnabled) {
            this.isSnapEnabled = isEnabled;
            this.controls.applySnapSettings();
        }
        
        setTranslationSnap(value) {
            this.translationSnapValue = value || 1;
            this.controls.applySnapSettings();
        }
        
        setRotationSnap(value) {
            this.rotationSnapValue = value || 15;
            this.controls.applySnapSettings();
        }
        
        // --- Data & Property Manipulation ---
    
        updateSceneSetting(key, value) {
            const path = key.split('.');
            let target = this.app.settings;
            for (let i = 0; i < path.length - 1; i++) {
                target = target[path[i]];
            }
            target[path[path.length - 1]] = value;
            this.app.levelManager._setupScene(this.app.settings);
        }
        
        updateSelectedProp(prop, key, value) {
            if (this.selectedObjects.size === 0) return;
        
            const changes = [];
            this.selectedObjects.forEach(entity => {
                let definitionHolder = entity;
                let definitionPropPath = prop;
        
                if (entity.userData?.gameEntity?.type === 'LightTarget') {
                    definitionHolder = entity.userData.gameEntity.parentLight;
                    if (prop === 'position') {
                        definitionPropPath = 'targetPosition';
                    }
                }
        
                const beforeState = JSON.parse(JSON.stringify(definitionHolder.definition));
                const afterState = JSON.parse(JSON.stringify(beforeState));
                
                const path = definitionPropPath.split('.');
                let parentTarget = afterState;
                let canApply = true;
                for(let i = 0; i < path.length - 1; i++) {
                    if (parentTarget[path[i]] !== undefined) {
                        parentTarget = parentTarget[path[i]];
                    } else {
                        canApply = false;
                        break;
                    }
                }
                if (!canApply) return;
        
                const finalKey = path[path.length - 1];
                let targetProperty = parentTarget[finalKey];
                if (targetProperty === undefined) return;
        
                if (key !== null) {
                    targetProperty[key] = value;
                } else {
                     parentTarget[finalKey] = value.toString().startsWith('#') ? value.replace('#', '0x') : value;
                }
                
                changes.push({ entity: definitionHolder, beforeState, afterState });
            });
        
            if (changes.length > 0) {
                const command = new StateChangeCommand(this, changes);
                this.undoManager.execute(command);
            }
        }
        
        // В файле: src/editor/LevelEditor.js

applyDefinition(obj) {
    const type = obj.userData?.gameEntity?.type;
    const def = obj.definition;

    if (!def || !type) return;

    // Обработка особых случаев с явным return
    if (type === 'SpawnPoint' || type === 'DeathSpawnPoint') {
        this.syncObjectTransforms(obj);
        return;
    }

    if (type === 'DirectionalLight') {
        const light = obj.light;
        light.color.set(parseInt(def.color, 16));
        light.intensity = def.intensity;
        light.position.set(def.position.x, def.position.y, def.position.z);
        if (def.targetPosition) {
            light.target.position.set(def.targetPosition.x, def.targetPosition.y, def.targetPosition.z);
        }
        obj.picker.position.copy(light.position);
        obj.targetHelper.position.copy(light.target.position);
        light.target.updateMatrixWorld(true);
        obj.helper.update();
        return;
    }

    if (type === 'Water') {
        const size = (def.size || [1, 1, 1]).map(s => Math.abs(s) || 0.1);
        const position = def.position;
        const rot = def.rotation ? new THREE.Euler(
            THREE.MathUtils.degToRad(def.rotation.x || 0),
            THREE.MathUtils.degToRad(def.rotation.y || 0),
            THREE.MathUtils.degToRad(def.rotation.z || 0), 'YXZ'
        ) : new THREE.Euler();
        const quat = new THREE.Quaternion().setFromEuler(rot);

        obj.helperMesh.position.set(position.x, position.y, position.z);
        obj.helperMesh.quaternion.copy(quat);
        obj.helperMesh.geometry.dispose();
        obj.helperMesh.geometry = new THREE.BoxGeometry(...size);

        obj.mesh.geometry.dispose();
        obj.mesh.geometry = new THREE.PlaneGeometry(size[0], size[2]);

        if(obj.body && obj.body.shapes[0]){
             const halfExtents = new CANNON.Vec3(size[0] / 2, size[1] / 2, size[2] / 2);
             obj.body.shapes[0].halfExtents.copy(halfExtents);
             obj.body.shapes[0].updateConvexPolyhedronRepresentation();
             obj.body.updateBoundingRadius();
        }
        
        this.syncObjectTransforms(obj); 
        return;
    }

    // Обработка динамических/интерактивных объектов
    if (type === 'NPC') {
        const team = def.team || 'enemy';
        const color = team === 'enemy' ? 0x990000 : 0x009933;
        obj.mesh.material.color.set(color);

        if (obj.body) {
            if (team === 'enemy') {
                obj.body.collisionFilterGroup = COLLISION_GROUPS.ENEMY;
                obj.body.collisionFilterMask = COLLISION_GROUPS.WORLD | COLLISION_GROUPS.PLAYER | COLLISION_GROUPS.ALLY | COLLISION_GROUPS.PLAYER_PROJECTILE | COLLISION_GROUPS.TRIGGER | COLLISION_GROUPS.WATER;
            } else { // ally
                obj.body.collisionFilterGroup = COLLISION_GROUPS.ALLY;
                obj.body.collisionFilterMask = COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY | COLLISION_GROUPS.ENEMY_PROJECTILE | COLLISION_GROUPS.TRIGGER | COLLISION_GROUPS.WATER;
            }
        }
        // NPC не должен обновлять свою позицию из definition, так как им управляет AI
        // Но мы все равно синхронизируем на случай, если его переместили в редакторе
        this.syncObjectTransforms(obj);

        // Обработка статической геометрии и триггеров
        } else {
        const mesh = obj.mesh;
        const body = obj.body;
        
        mesh.position.set(def.position.x, def.position.y, def.position.z);
    
        if (def.rotation) {
             mesh.rotation.set(
                THREE.MathUtils.degToRad(def.rotation.x || 0),
                THREE.MathUtils.degToRad(def.rotation.y || 0),
                THREE.MathUtils.degToRad(def.rotation.z || 0)
            );
        }
    
        if (def.material?.color && mesh.material && !mesh.material.isWireframeMaterial) {
            mesh.material.color.set(parseInt(def.material.color, 16));
        }
    
        if (def.size) {
            if (type === 'Trigger' || type === 'DeathTrigger') {
                mesh.geometry.dispose();
                mesh.geometry = new THREE.BoxGeometry(...def.size);
                if (type === 'Trigger' && def.color) {
                    mesh.material.color.set(parseInt(def.color, 16));
                }
            } else if (type === 'Waterfall') {
                mesh.geometry.dispose();
                mesh.geometry = new THREE.PlaneGeometry(def.size[0], def.size[1]);
            } else if (def.type === 'Plane') {
                mesh.geometry.dispose();
                mesh.geometry = new THREE.PlaneGeometry(def.size[0], def.size[1]);
            } else if (def.type === 'Box' && body?.shapes[0]) {
                const halfExtents = new CANNON.Vec3(def.size[0] / 2, def.size[1] / 2, def.size[2] / 2);
                body.shapes[0].halfExtents.copy(halfExtents);
                body.shapes[0].updateConvexPolyhedronRepresentation();
                body.updateBoundingRadius();
                mesh.geometry.dispose();
                mesh.geometry = new THREE.BoxGeometry(...def.size);
            }
        }
    
        // После всех обновлений mesh, синхронизируем физическое тело
        this.syncObjectTransforms(obj);
        }
        }       
        
        syncObjectTransforms(entityToSync) {
            const entity = entityToSync || this.primarySelectedObject;
            if (!entity) return;
            
            const entityType = entity.userData?.gameEntity?.type;
            
            if (entityType === 'SpawnPoint') {
                this.app.spawnPoint.copy(entity.position);
            } else if (entityType === 'DeathSpawnPoint') {
                this.app.deathSpawnPoint.copy(entity.position);
            } else if (entityType === 'DirectionalLight') {
                const picker = entity.picker;
                const light = entity.light;
                light.position.copy(picker.position);
                light.target.position.copy(entity.targetHelper.position);
                entity.helper.update();
            } else if (entityType === 'Water') {
                const sourceTransform = entity.helperMesh;
                entity.body.position.copy(sourceTransform.position);
                entity.body.quaternion.copy(sourceTransform.quaternion);
                
                const size = entity.definition.size;
                const upVector = new THREE.Vector3(0, 1, 0);
                upVector.applyQuaternion(sourceTransform.quaternion);
        
                const waterSurfacePosition = sourceTransform.position.clone().add(upVector.multiplyScalar(size[1] / 2));
                entity.mesh.position.copy(waterSurfacePosition);
                
                entity.mesh.quaternion.copy(sourceTransform.quaternion);
                entity.mesh.rotateX(-Math.PI / 2); // Re-apply the local rotation to make it flat
    
            } else if (entity.body) {
                const sourceTransform = entity.mesh || entity.picker || entity;
                entity.body.position.copy(sourceTransform.position);
                entity.body.quaternion.copy(sourceTransform.quaternion);
            }
        }
        
        onLevelLoaded() {
            this.deselect();
            this.ui.updateOutliner();
            this.ui.updatePropertiesPanel();
    
            // Apply initial visibility from UI checkboxes
            this.ui.setHelpersVisibility('Trigger', document.getElementById('view-toggle-msg-triggers').checked);
            this.ui.setHelpersVisibility('DeathTrigger', document.getElementById('view-toggle-death-triggers').checked);
            this.ui.setHelpersVisibility('DirectionalLight', document.getElementById('view-toggle-light-helpers').checked);
            this.ui.setHelpersVisibility('SpawnAndDeath', document.getElementById('view-toggle-spawn-helpers').checked);
            this.ui.setHelpersVisibility('Water', document.getElementById('view-toggle-water-volumes').checked);
        }
        
        update(deltaTime) {
            this.cameraController.update(deltaTime);
            this.controls.updateSelectionBoxes();
        }
    }
--------------------------------------------------
=== END OF FILE: src/editor/LevelEditor.js ===


=== FILE: src/editor/UndoManager.js ===
--------------------------------------------------
/**
 * A command representing a state change on an entity. It holds the "before"
 * and "after" states, allowing the change to be executed and undone.
 */

export class StateChangeCommand {
    /**
     * Can be constructed in two ways:
     * 1. new StateChangeCommand(editor, changes) where changes is an array of {entity, beforeState, afterState}
     * 2. new StateChangeCommand(editor, entity, beforeState, afterState) for a single object change
     * @param {import('./LevelEditor.js').LevelEditor} editor
     * @param {Array|object} changesOrEntity
     * @param {object} [beforeState]
     * @param {object} [afterState]
     */
    constructor(editor, changesOrEntity, beforeState, afterState) {
        this.editor = editor;
        
        if (Array.isArray(changesOrEntity)) {
            // New signature for multi-object changes
            this.changes = changesOrEntity.map(c => ({
                entity: c.entity,
                beforeState: JSON.parse(JSON.stringify(c.beforeState)),
                afterState: JSON.parse(JSON.stringify(c.afterState)),
            }));
        } else {
            // Original signature for single-object changes
            this.changes = [{
                entity: changesOrEntity,
                beforeState: JSON.parse(JSON.stringify(beforeState)),
                afterState: JSON.parse(JSON.stringify(afterState)),
            }];
        }
    }

    execute() {
        this.changes.forEach(change => {
            change.entity.definition = JSON.parse(JSON.stringify(change.afterState));
            // FIX: Target the correct object for scale reset (e.g., helperMesh for Water)
            const transformedObject = change.entity.helperMesh || change.entity.mesh || change.entity.picker || change.entity;
            if (transformedObject && change.afterState.size) {
                 transformedObject.scale.set(1, 1, 1);
            }
            this.editor.applyDefinition(change.entity);
        });
        
        this.editor.deselect();
        this.changes.forEach(change => this.editor.addToSelection(change.entity));
        this.editor.ui.updatePropertiesPanel();
    }

    undo() {
        this.changes.forEach(change => {
            change.entity.definition = JSON.parse(JSON.stringify(change.beforeState));
            // FIX: Target the correct object for scale reset (e.g., helperMesh for Water)
            const transformedObject = change.entity.helperMesh || change.entity.mesh || change.entity.picker || change.entity;
            if (transformedObject && change.beforeState.size) {
                transformedObject.scale.set(1, 1, 1);
            }
            this.editor.applyDefinition(change.entity);
        });
        
        this.editor.deselect();
        this.changes.forEach(change => this.editor.addToSelection(change.entity));
        this.editor.ui.updatePropertiesPanel();
    }
}

/**
 * Manages the undo and redo stacks for editor commands.
 */
export class UndoManager {
    constructor(editor) {
        this.editor = editor;
        this.undoStack = [];
        this.redoStack = [];
        this.maxHistory = 50;
    }

    execute(command) {
        this.undoStack.push(command);
        if (this.undoStack.length > this.maxHistory) {
            this.undoStack.shift();
        }
        this.redoStack = []; // Clear redo stack on new command
        command.execute();
    }

    undo() {
        if (this.undoStack.length === 0) return;
        const command = this.undoStack.pop();
        this.redoStack.push(command);
        command.undo();
    }

    redo() {
        if (this.redoStack.length === 0) return;
        const command = this.redoStack.pop();
        this.undoStack.push(command);
        command.execute();
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/UndoManager.js ===


=== FILE: src/game/Game.js ===
--------------------------------------------------
// ~ src/game/Game.js
import * as THREE from 'three';
import { World } from './world/World.js';
import { PlayerController } from '../client/entities/PlayerController.js';
import { EventEmitter } from '../shared/EventEmitter.js';
import { AbilityFactory } from './abilities/AbilityFactory.js';
import { GAME_CONFIG } from '../shared/config.js';

/**
 * Manages the high-level state of the game application.
 * Acts as a state machine (MENU, LOADING, PLAYING) and orchestrates the core modules,
 * the game world, and the UI manager.
 */
export class Game {
    constructor(core, ui) {
        this.emitter = new EventEmitter(); // Composition
        this.core = core;
        this.ui = ui;
        this.viewModelScene = new THREE.Scene();

        this.gameState = 'MENU';
        this.debugModeActive = false;
        
        this.world = null;
        this.playerController = new PlayerController(this.core.input);
        
        this.respawnTimer = 0;
        this.currentLevelConfig = null;
    }

    // --- Event Emitter Delegation ---
    on(eventName, listener) { this.emitter.on(eventName, listener); }
    emit(eventName, data) { this.emitter.emit(eventName, data); }
    off(eventName, listener) { this.emitter.off(eventName, listener); }
    removeAllListeners() { this.emitter.removeAllListeners(); }

    async init() {
        await AbilityFactory.init();
        this.ui.bindGame(this);
        this._setupEventListeners();
        
        const urlParams = new URLSearchParams(window.location.search);
        this.handleUrlParameters(urlParams);
    }

    handleUrlParameters(params) {
        const loadFromEditor = params.get('loadFromEditor') === 'true';
        const debugMode = params.get('debug') === 'true';
        const showLevelSelect = params.get('showLevelSelect') === 'true';

        if (debugMode) this.toggleDebugMode();

        if (loadFromEditor) {
            const editorLevelData = localStorage.getItem('editorLevelData');
            if (editorLevelData) {
                try {
                    const savedLoadout = JSON.parse(localStorage.getItem('activeLoadout') || '{ "cards": [] }');
                    this.startLevel({ data: JSON.parse(editorLevelData), loadout: savedLoadout });
                } catch (e) {
                    console.error("Failed to parse level data from editor:", e);
                    this.returnToMenu();
                } finally {
                    localStorage.removeItem('editorLevelData');
                }
            }
        } else if (showLevelSelect) {
            this.ui.populateLevelList(this);
            this.ui.showScreen('levelSelect');
        } else {
            this.returnToMenu();
        }
    }

    async startLevel(config) {
        if (this.gameState === 'LOADING') return;

        this.currentLevelConfig = config;
        this.gameState = 'LOADING';
        this.ui.setLoading(true);

        if (this.world) {
            this.world.dispose();
            this.world = null;
        }

        this.world = new World(this.core, this);
        this.emit('worldCreated', this.world);
        
        // Centralize all World event listening here
        this.world.on('playerDied', () => this.handlePlayerDeath());
        this.world.on('npcDied', ({ entity }) => this.world.onNPCDied(entity));
        this.world.on('levelCompleted', () => this.ui.tutorialManager.showLevelCompleted());
        this.world.on('tutorialTriggerActivated', (data) => this.ui.tutorialManager.onTriggerActivated(data));
        this.world.on('abilityCastFailed', (data) => {
            this.emit('abilityCastFailed', data);
        });

        try {
            await this.world.loadLevel(config);

            this.core.renderer.setupPostProcessing(
                this.world.scene,
                this.core.renderer.camera,
                this.game.viewModelScene
            );

            this.playerController.attach(this.world.player);
            
            this.gameState = 'AWAITING_PLAY';
            this.requestPointerLock();
        } catch (error) {
            console.error("Failed to start level:", error);
            this.returnToMenu();
        }
    }

    startGameplay() {
        if (this.gameState !== 'AWAITING_PLAY') return;
        this.gameState = 'PLAYING';
        this.ui.setLoading(false);
        this.ui.showScreen('none');
        document.body.classList.add('game-active');

        if (this.world.player.isDead) {
            this.world.player.spawn(this.world.spawnPoint);
        }
    }
    
    handlePlayerDeath() {
        if (this.gameState === 'DEAD') return;
        this.gameState = 'DEAD';
        this.respawnTimer = GAME_CONFIG.UI.RESPAWN_COOLDOWN;
        this.ui.showScreen('deathScreen');
        document.body.classList.remove('game-active');
        if (document.pointerLockElement) document.exitPointerLock();
    }

    respawnPlayer() {
        this.world.resetPlayer();
        this.gameState = 'AWAITING_PLAY';
        this.ui.showScreen('none');
        this.requestPointerLock();
    }
    
    returnToMenu() {
        if (this.world) {
            this.world.dispose();
            this.world = null;
        }
        this.core.renderer.composer = null;
        this.playerController.detach();
        this.gameState = 'MENU';
        this.ui.setLoading(false);
        this.ui.showScreen('mainMenu');
        document.body.classList.remove('game-active');
        this.emit('mainMenuRendered');
        if (document.pointerLockElement) document.exitPointerLock();
    }
    
    requestPointerLock() {
        this.core.renderer.renderer.domElement.requestPointerLock();
    }

    toggleDebugMode() {
        this.debugModeActive = !this.debugModeActive;
        console.log(`%cDEBUG MODE: ${this.debugModeActive ? 'ACTIVATED' : 'DEACTIVATED'}`, 
            `color: ${this.debugModeActive ? '#2ed573' : '#ff4757'}; font-weight: bold;`);
    }

    _setupEventListeners() {
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement) {
                if (this.gameState === 'AWAITING_PLAY') this.startGameplay();
                if (this.gameState === 'PAUSED') {
                    this.gameState = 'PLAYING';
                    this.ui.showScreen('none');
                    document.body.classList.add('game-active');
                }
            } else {
                if (this.gameState === 'PLAYING') {
                    this.gameState = 'PAUSED';
                    this.ui.showScreen('pauseMenu');
                    document.body.classList.remove('game-active');
                }
            }
        });

        const setupMainMenuListeners = () => {
            const playBtn = document.getElementById('play-btn');
            const loadoutBtn = document.getElementById('loadout-btn');
            const editorBtn = document.getElementById('editor-btn');
            const assetEditorBtn = document.getElementById('asset-editor-btn');

            if (playBtn) playBtn.onclick = () => {
                this.ui.populateLevelList(this);
                this.ui.showScreen('levelSelect');
            };
            if (loadoutBtn) loadoutBtn.onclick = () => { window.location.href = 'loadout.html'; };
            if (editorBtn) editorBtn.onclick = () => { window.location.href = 'editor.html'; };
            if (assetEditorBtn) assetEditorBtn.onclick = () => { window.location.href = 'asset-editor.html'; };
        };
        
        setupMainMenuListeners();
        this.on('mainMenuRendered', setupMainMenuListeners);

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape' && this.gameState === 'PLAYING') {
                // Let the pointerlockchange event handle pausing
            }
        });
    }

    update(deltaTime) {
        switch (this.gameState) {
            case 'PLAYING':
                this.world.update(deltaTime);
                break;
            case 'DEAD':
                this.respawnTimer -= deltaTime;
                if (this.respawnTimer <= 0) {
                    this.respawnPlayer();
                }
                break;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/Game.js ===


=== FILE: src/game/abilities/Ability.js ===
--------------------------------------------------
// src/game/abilities/Ability.js
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Base class for all player abilities. Handles shared logic like cooldowns and energy costs.
 * Subclasses must implement the _executeCast method.
 */
export class Ability {
    constructor(caster, abilityData) {
        this.caster = caster;
        this.data = abilityData;
        this.name = abilityData.name || 'Unnamed Ability';
        this.icon = abilityData.icon || '?';
        this.cooldown = abilityData.cooldown || 0;
        this.energyCost = abilityData.energyCost || 0;
        this.element = abilityData.element || 'Utility';
        this.isCasting = false;
        this.castType = abilityData.castType || 'instant';

        // Start ready to cast
        this.cooldownTimer = this.cooldown;
    }

    /**
     * Checks if the ability can be cast based on cooldown and caster's energy.
     * @returns {{canCast: boolean, reasons: string[]}}
     */
    _getCastability() {
        const reasons = [];
        if (this.caster.world.game?.debugModeActive) return { canCast: true, reasons: [] };

        if (this.isCasting) reasons.push('is_casting');
        if (this.cooldownTimer < this.cooldown) reasons.push('on_cooldown');
        if (this.caster.abilities.currentEnergy < this.energyCost) reasons.push('insufficient_energy');
        
        return { canCast: reasons.length === 0, reasons };
    }

    /**
     * Executes the ability's core logic. Must be implemented by subclasses.
     * @returns {boolean} True if the cast logic was successful, false otherwise.
     * @protected
     */
    _executeCast() {
        throw new Error("Ability._executeCast() must be implemented by subclasses.");
    }
    
    /**
     * Public-facing method to cast the ability. Handles resource consumption and cooldowns.
     * @returns {boolean} True if the cast was successful, false otherwise.
     */
    cast() {
        const { canCast, reasons } = this._getCastability();

        if (!canCast) {
            // Emit an event with all failure reasons if there are any user-facing ones
            if (reasons.includes('on_cooldown') || reasons.includes('insufficient_energy')) {
                this.caster.world.emit('abilityCastFailed', { 
                    reasons: reasons,
                    entity: this.caster, 
                    ability: this 
                });
            }
            return false;
        }

        const castSuccessful = this._executeCast();

        if (castSuccessful) {
            if (!this.caster.world.game || !this.caster.world.game.debugModeActive) {
                this.caster.abilities.currentEnergy -= this.energyCost;
                this.caster.abilities.lastAbilityTime = this.caster.world.physics.world.time;
                this.triggerCooldown();
            }
            return true;
        }
        return false;
    }

    /**
     * Called on button press. For instant abilities, this just casts.
     * Channeling abilities should override this to begin their channeling state.
     */
    startCasting() {
        return this.cast();
    }

    /**
     * Called on button release.
     * Channeling abilities should override this to end their channeling state.
     */
    stopCasting() {
        this.isCasting = false;
    }

    /**
     * Resets the cooldown timer after casting.
     */
    triggerCooldown() {
        this.cooldownTimer = 0;
    }

    /**
     * Gets the current cooldown progress as a value from 0.0 to 1.0.
     * @returns {number}
     */
    getCooldownProgress() {
        if (this.cooldown === 0) return 1.0;
        return Math.min(this.cooldownTimer / this.cooldown, 1.0);
    }
    
    /**
     * Updates the cooldown timer.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    update(deltaTime) {
        if (this.cooldownTimer < this.cooldown) {
            this.cooldownTimer += deltaTime;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/Ability.js ===


=== FILE: src/game/abilities/AbilityFactory.js ===
--------------------------------------------------
// ~ src/game/abilities/AbilityFactory.js
import { FireballAbility } from './FireballAbility.js';
import { FirefliesAbility } from './FirefliesAbility.js';
import { StonePlatingAbility } from './StonePlatingAbility.js';
import { WavePowerAbility } from './WavePowerAbility.js';
import { SecondChanceAbility } from './SecondChanceAbility.js';

const AbilityMap = {
    'FIRE_001': FireballAbility,
    'FIRE_002': FirefliesAbility,
    'EARTH_001': StonePlatingAbility,
    'WATER_001': WavePowerAbility,
    'UTILITY_001': SecondChanceAbility,
    // Add new ability classes here
};

let allAbilitiesData = null; // Module-level cache

/**
 * A factory for creating ability instances from their IDs.
 */
export class AbilityFactory {
    /**
     * Loads and caches the ability definitions from the JSON file.
     * Must be called once before any abilities can be created.
     */
    static async init() {
        if (allAbilitiesData) return; // Already initialized
        try {
            const response = await fetch('./data/abilities.json');
            allAbilitiesData = await response.json();
            console.log('Ability data loaded successfully.');
        } catch (error) {
            console.error('Failed to load ability data:', error);
            allAbilitiesData = {}; // Prevent further failed attempts
        }
    }

    /**
     * Creates an ability instance for a given caster and card ID.
     * @param {string} cardId - The ID of the ability card (e.g., 'FIRE_001').
     * @param {object} caster - The entity that will use the ability.
     * @returns {import('./Ability.js').Ability | null} An instance of the ability, or null if the ID is not found.
     */
    static create(cardId, caster) {
        if (!allAbilitiesData) {
            console.error('AbilityFactory not initialized. Call init() first.');
            return null;
        }

        const AbilityClass = AbilityMap[cardId];
        const abilityData = allAbilitiesData[cardId];

        if (AbilityClass && abilityData) {
            // Pass the full data object to the constructor
            return new AbilityClass(caster, abilityData);
        }

        console.warn(`AbilityFactory: No class or data found for card ID: ${cardId}`);
        return null;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/AbilityFactory.js ===


=== FILE: src/game/abilities/EnemyProjectile.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
import { GAME_CONFIG } from '../../shared/config.js';
import { PhysicsBodyComponent } from '../components/PhysicsBodyComponent.js';

/**
 * A generic projectile fired by an NPC (enemy or ally).
 * It is a simple physics object that deals damage on impact to opposing teams.
 * The collision group and mask are set dynamically based on the caster's team.
 */
export class EnemyProjectile {
    constructor({ world, caster, initialVelocity }) {
        this.id = THREE.MathUtils.generateUUID();
        this.type = 'enemy_projectile'; // Kept for VFX system compatibility
        this.world = world;
        this.caster = caster;

        const config = GAME_CONFIG.NPC.RANGED;
        this.damage = config.PROJECTILE_DAMAGE;
        this.lifetime = 3.0;
        this.isDead = false;

        // Physics
        const shape = new CANNON.Sphere(0.2);
        
        // Dynamically set collision group and mask based on the caster's team.
        const isFriendlyCaster = caster.team === 'player';
        const group = isFriendlyCaster ? COLLISION_GROUPS.PLAYER_PROJECTILE : COLLISION_GROUPS.ENEMY_PROJECTILE;
        const mask = isFriendlyCaster
            ? (COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY)
            : (COLLISION_GROUPS.WORLD | COLLISION_GROUPS.PLAYER | COLLISION_GROUPS.ALLY | COLLISION_GROUPS.WATER);

        const body = new CANNON.Body({
            mass: 0.1,
            shape,
            collisionFilterGroup: group,
            collisionFilterMask: mask,
        });

        const spawnDirection = new CANNON.Vec3().copy(initialVelocity);
        spawnDirection.normalize();
        const spawnPos = new CANNON.Vec3().copy(caster.physics.body.position);
        const offset = spawnDirection.scale(2);
        spawnPos.vadd(offset, spawnPos);
        
        body.position.copy(spawnPos);
        body.velocity.copy(initialVelocity);
        
        this.physics = new PhysicsBodyComponent(body);
        
        if (!body.userData) body.userData = {};
        body.userData.entity = this;

        body.addEventListener('collide', (e) => this.onCollide(e));
        
        this.world.physics.addBody(body);
        this.world.add(this);
    }

    onCollide(event) {
        if (this.isDead) return;

        const targetEntity = event.body?.userData?.entity;

        // A projectile should damage any entity on an opposing team.
        if (targetEntity?.team && targetEntity.team !== this.caster.team) {
            if (typeof targetEntity.takeDamage === 'function') {
                targetEntity.takeDamage(this.damage);
            }
        }
        
        // Detonate on impact with anything except a non-physical trigger volume.
        const otherGroup = event.body.collisionFilterGroup;
        if (!(otherGroup & COLLISION_GROUPS.TRIGGER)) {
            this.world.remove(this);
        }
    }

    update(deltaTime) {
        if (this.isDead) return;

        this.lifetime -= deltaTime;
        if (this.lifetime <= 0) {
            this.world.remove(this);
        }
    }
    
    dispose() {
        if (this.isDead) return;
        this.isDead = true;
        this.world.physics.queueForRemoval(this.physics.body);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/EnemyProjectile.js ===


=== FILE: src/game/abilities/Fireball.js ===
--------------------------------------------------
// ~ src/game/abilities/Fireball.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';

/**
 * The Fireball projectile entity. Handles its own movement, collision, and area-of-effect logic.
 * Emits an event for the client to create the visual explosion.
 */
export class Fireball {
    constructor({ world, caster, spawnPosition }) {
        this.world = world;
        this.physics = world.physics;
        this.id = Math.random();

        this.LIFETIME = 2.0;
        this.SPEED = 35;
        this.RADIUS = 0.3;
        this.LINGER_DURATION = 3.0;
        this.DAMAGE_PER_SECOND = 75;
        
        this.state = 'TRAVELING';
        this.stateTimer = 0;
        this.isDead = false;

        const shape = new CANNON.Sphere(this.RADIUS);
        this.body = new CANNON.Body({
            mass: 0.5, shape,
            collisionFilterGroup: COLLISION_GROUPS.PLAYER_PROJECTILE,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY,
        });

        // Use the safe spawn position passed from the ability
        this.body.position.copy(spawnPosition);

        // Still need caster's direction for velocity
        const threeCameraDirection = new THREE.Vector3();
        caster.camera.getWorldDirection(threeCameraDirection);
        const cannonVelocity = new CANNON.Vec3().copy(threeCameraDirection).scale(this.SPEED);
        this.body.velocity.copy(cannonVelocity);
        
        this.onCollideHandler = (e) => {
            if (this.body) {
                this.detonate(this.body.position.clone());
            }
        };
        this.body.addEventListener('collide', this.onCollideHandler);

        this.preStepHandler = () => {
            if (this.state === 'TRAVELING' && this.body) {
                const antiGravity = new CANNON.Vec3(0, -this.physics.world.gravity.y, 0).scale(this.body.mass);
                this.body.applyForce(antiGravity, this.body.position);
            }
        };
        this.physics.world.addEventListener('preStep', this.preStepHandler);

        this.aoeSphere = new CANNON.Sphere(this.RADIUS * 40);
        this.aoeBody = new CANNON.Body({
            type: CANNON.Body.STATIC,
            isTrigger: true,
            collisionFilterGroup: COLLISION_GROUPS.VISION_BLOCKER // This body will now block AI sight
        });
        this.aoeBody.addShape(this.aoeSphere);

        this.physics.addBody(this.body);
        this.world.add(this);
    }

    detonate(position) {
        if (this.state !== 'TRAVELING') return;

        this.state = 'LINGERING';
        this.stateTimer = 0;
        
        if (this.body) {
            this.body.removeEventListener('collide', this.onCollideHandler);
            this.physics.queueForRemoval(this.body);
            this.body = null;
        }
        
        this.aoeBody.position.copy(position);
        this.physics.addBody(this.aoeBody);

        this.world.emit('projectileDetonated', { type: 'Fireball', position });
    }

    update(deltaTime) {
        if (this.isDead) return;

        this.stateTimer += deltaTime;

        if (this.state === 'TRAVELING') {
            if (this.stateTimer > this.LIFETIME && this.body) {
                this.detonate(this.body.position.clone());
            }
        } else if (this.state === 'LINGERING') {
            this.updateAoeDamage(deltaTime);
            if (this.stateTimer > this.LINGER_DURATION) {
                this.world.remove(this);
            }
        }
    }

    updateAoeDamage(deltaTime) {
        const damage = this.DAMAGE_PER_SECOND * deltaTime;
        const radiusSq = this.aoeSphere.radius * this.aoeSphere.radius;

        // Player projectiles only damage enemies
        for (const enemy of this.world.getEnemies()) {
            if (enemy.physics.body.position.distanceSquared(this.aoeBody.position) < radiusSq) {
                enemy.takeDamage(damage);
            }
        }
    }
    
    dispose() {
        if (this.isDead) return;
        this.isDead = true;
        this.physics.world.removeEventListener('preStep', this.preStepHandler);
        if (this.body) {
            this.body.removeEventListener('collide', this.onCollideHandler);
            this.physics.queueForRemoval(this.body);
        }
        if (this.aoeBody) this.physics.queueForRemoval(this.aoeBody);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/Fireball.js ===


=== FILE: src/game/abilities/FireballAbility.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { Ability } from './Ability.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';

export class FireballAbility extends Ability {
    constructor(caster, abilityData) {
        super(caster, abilityData);
    }

    _executeCast() {
        const camera = this.caster.camera;
        const world = this.caster.world;
        const physics = world.physics;

        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir);

        const idealSpawnPoint = cameraPos.clone().add(cameraDir.clone().multiplyScalar(1.5));
        
        const rayFrom = new CANNON.Vec3().copy(cameraPos);
        const rayTo = new CANNON.Vec3().copy(idealSpawnPoint);
        const result = new CANNON.RaycastResult();
        
        physics.world.raycastClosest(rayFrom, rayTo, {
            collisionFilterMask: COLLISION_GROUPS.WORLD 
        }, result);

        let spawnPosition;
        if (result.hasHit) {
            const hitPoint = result.hitPointWorld;
            
            // FIX: Corrected method chaining.
            // .normalize() returns the length (a number), not the vector.
            const nudgeDirection = rayTo.vsub(rayFrom); // Get direction vector
            nudgeDirection.normalize(); // Normalize it in-place
            
            // .scale() returns a new, scaled vector.
            const nudgeVector = nudgeDirection.scale(-0.1); 
            
            spawnPosition = hitPoint.vadd(nudgeVector);
        } else {
            spawnPosition = rayTo;
        }
        
        this.caster.world.createFireball({ caster: this.caster, spawnPosition });
        return true;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FireballAbility.js ===


=== FILE: src/game/abilities/FirefliesAbility.js ===
--------------------------------------------------
// ~ src/game/abilities/FirefliesAbility.js
import { Ability } from './Ability.js';

export class FirefliesAbility extends Ability {
    constructor(caster, abilityData) {
        super(caster, abilityData);
        this.numProjectiles = 5;
        this.requiresLockOn = true;

        // State for update-based casting
        this.castTimer = 0;
        this.projectilesFired = 0;
        this.targetWhileCasting = null;
        this.CAST_INTERVAL = 0.075; // 75ms
    }

    // Override startCasting to manage its own lifecycle.
    startCasting() {
        const { canCast, reasons } = this._getCastability();
        if (!canCast) {
            if (reasons.includes('on_cooldown') || reasons.includes('insufficient_energy')) {
                this.caster.world.emit('abilityCastFailed', { 
                    reasons: reasons,
                    entity: this.caster, 
                    ability: this 
                });
            }
            return false;
        }

        const castSuccessful = this._executeCast();

        if (castSuccessful) {
            // Consume energy upfront, but do NOT trigger cooldown here.
            if (!this.caster.world.game || !this.caster.world.game.debugModeActive) {
                this.caster.abilities.currentEnergy -= this.energyCost;
                this.caster.abilities.lastAbilityTime = this.caster.world.physics.world.time;
            }
            return true;
        }
        return false;
    }

    /**
     * Overridden to prevent the cast from being interrupted on button release.
     * The sequence, once started, runs to completion automatically.
     */
    stopCasting() {
        // Do nothing.
    }

    _executeCast() {
        const targetNPC = this.caster.lockedTarget; 
        if (!targetNPC || targetNPC.isDead) return false;

        this.isCasting = true;
        this.castTimer = 0;
        this.projectilesFired = 0;
        this.targetWhileCasting = targetNPC;

        return true;
    }

    update(deltaTime) {
        super.update(deltaTime); // Handles the main cooldown timer countdown

        if (!this.isCasting) return;

        this.castTimer += deltaTime;

        // Check if it's time to fire the next projectile
        if (this.castTimer >= this.projectilesFired * this.CAST_INTERVAL) {
            if (this.projectilesFired < this.numProjectiles) {
                if (!this.caster.isDead && this.targetWhileCasting && !this.targetWhileCasting.isDead) {
                    this.caster.world.createFireflyProjectile({ 
                        caster: this.caster, 
                        target: this.targetWhileCasting 
                    });
                }
                this.projectilesFired++;
            }
        }

        // End casting sequence
        if (this.projectilesFired >= this.numProjectiles) {
            this.isCasting = false;
            this.targetWhileCasting = null;
            // Trigger the cooldown AFTER the sequence is complete.
            if (!this.caster.world.game || !this.caster.world.game.debugModeActive) {
                this.triggerCooldown();
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FirefliesAbility.js ===


=== FILE: src/game/abilities/FireflyProjectile.js ===
--------------------------------------------------
// ~ src/game/abilities/FireflyProjectile.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
import { PhysicsBodyComponent } from '../components/PhysicsBodyComponent.js';

/**
 * The Firefly homing projectile entity. Handles its own steering and collision logic.
 */
export class FireflyProjectile {
    constructor({ world, caster, target }) {
        this.id = THREE.MathUtils.generateUUID();
        this.type = 'firefly_projectile';
        this.world = world;
        this.caster = caster;
        this.target = target;
        
        this.damage = 100;
        this.lifetime = 6.0;
        this.speed = 18;
        this.isDead = false;
        this.homingForce = 4.0;
        
        const shape = new CANNON.Sphere(0.15);
        const body = new CANNON.Body({
            mass: 0.05, shape,
            collisionFilterGroup: COLLISION_GROUPS.PLAYER_PROJECTILE,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY,
            linearDamping: 0.1,
        });
        body.allowSleep = false;
        
        const initialDirection = new THREE.Vector3();
        caster.camera.getWorldDirection(initialDirection);
        const initialPosition = new THREE.Vector3();
        caster.camera.getWorldPosition(initialPosition).add(initialDirection.clone().multiplyScalar(0.7));
        body.position.copy(initialPosition);
        body.velocity.copy(initialDirection.multiplyScalar(this.speed));

        if (!body.userData) body.userData = {};
        body.userData.entity = this;

        this.physics = new PhysicsBodyComponent(body);

        body.addEventListener('collide', (e) => this.detonate());
        
        this.preStepHandler = () => { 
            if (this.physics.body) {
                const antiGravity = new CANNON.Vec3(0, -this.world.physics.world.gravity.y, 0).scale(this.physics.body.mass);
                this.physics.body.applyForce(antiGravity, this.physics.body.position);
            }
        };
        this.world.physics.world.addEventListener('preStep', this.preStepHandler);

        this.world.physics.addBody(body);
        this.world.add(this);
    }

    update(deltaTime) {
        if (this.isDead) return;

        this.lifetime -= deltaTime;
        if (this.lifetime <= 0) {
            this.detonate();
            return;
        }
        
        this.applySteering();
        this.orientToVelocity(deltaTime);
    }
    
    orientToVelocity(deltaTime) {
        const body = this.physics.body;
        if (body.velocity.lengthSquared() > 0.1) {
            const lookAtTarget = new CANNON.Vec3();
            body.position.vadd(body.velocity, lookAtTarget);
            
            const tempObject3D = new THREE.Object3D();
            tempObject3D.position.copy(body.position);
            tempObject3D.lookAt(lookAtTarget.x, lookAtTarget.y, lookAtTarget.z);
            
            body.quaternion.slerp(tempObject3D.quaternion, 15 * deltaTime, body.quaternion);
        }
    }

    applySteering() {
        if (!this.target || this.target.isDead || !this.target.physics?.body) return;

        const desiredVelocity = new CANNON.Vec3();
        this.target.physics.body.position.vsub(this.physics.body.position, desiredVelocity);

        if (desiredVelocity.lengthSquared() < 1) {
            this.detonate();
            return;
        }

        desiredVelocity.normalize();
        desiredVelocity.scale(this.speed, desiredVelocity);
        
        const steeringForce = new CANNON.Vec3();
        desiredVelocity.vsub(this.physics.body.velocity, steeringForce);
        steeringForce.normalize();
        steeringForce.scale(this.homingForce, steeringForce);
        
        this.physics.body.applyForce(steeringForce, this.physics.body.position);
    }

    detonate() {
        if (this.isDead) return;

        this.world.emit('projectileDetonated', { type: 'Firefly', position: this.physics.body.position });
        
        const radiusSq = 4 * 4;
        for (const enemy of this.world.getEnemies()) {
            if (enemy.physics?.body && enemy.physics.body.position.distanceSquared(this.physics.body.position) < radiusSq) {
                enemy.takeDamage(this.damage);
            }
        }
        
        this.world.remove(this);
    }
    
    dispose() {
        if (this.isDead) return;
        this.isDead = true;
        this.world.physics.world.removeEventListener('preStep', this.preStepHandler);
        if (this.physics.body) this.world.physics.queueForRemoval(this.physics.body);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FireflyProjectile.js ===


=== FILE: src/game/abilities/SecondChanceAbility.js ===
--------------------------------------------------
import { Ability } from './Ability.js';

export class SecondChanceAbility extends Ability {
    constructor(caster, abilityData) {
        super(caster, abilityData);

        this.isChanneling = false;
        // Constants for the ability's mechanics
        this.HEALTH_PER_SECOND = 50;
        this.ENERGY_PER_HEALTH = 2;
        this.ENERGY_PER_SECOND = this.HEALTH_PER_SECOND * this.ENERGY_PER_HEALTH;
    }

    // Override startCasting to avoid the base class's instant cooldown trigger.
    startCasting() {
        const { canCast, reasons } = this._getCastability();
        if (!canCast) {
            if (reasons.includes('on_cooldown') || reasons.includes('insufficient_energy')) {
                this.caster.world.emit('abilityCastFailed', { 
                    reasons: reasons,
                    entity: this.caster, 
                    ability: this 
                });
            }
            return false;
        }

        if (this.caster.health.currentHealth >= this.caster.health.maxHealth) {
            return false; // Silently fail if already at full health
        }
        
        if (this.caster.abilities.currentEnergy <= 0) {
            this.caster.world.emit('abilityCastFailed', {
                reasons: ['insufficient_energy'],
                entity: this.caster,
                ability: this,
            });
            return false;
        }

        this.isChanneling = true;
        this.caster.world.emit('playerChannelingUpdate', { isChanneling: true, ability: this });
        return true;
    }

    // Override stopCasting to trigger cooldown on release.
    stopCasting() {
        if (!this.isChanneling) return;
        
        this.isChanneling = false;
        this.caster.world.emit('playerChannelingUpdate', { isChanneling: false, ability: this });

        // Don't trigger cooldown in debug mode
        if (this.caster.world.game && this.caster.world.game.debugModeActive) return;

        this.triggerCooldown();
    }

    update(deltaTime) {
        super.update(deltaTime); // This still handles ticking up the cooldownTimer

        if (!this.isChanneling) {
            return;
        }

        if (this.caster.health.currentHealth >= this.caster.health.maxHealth || this.caster.abilities.currentEnergy <= 0) {
            this.stopCasting(); // Stop channeling and trigger cooldown
            return;
        }

        const energyToDrain = this.ENERGY_PER_SECOND * deltaTime;
        const actualEnergyDrained = Math.min(energyToDrain, this.caster.abilities.currentEnergy);
        
        this.caster.abilities.currentEnergy -= actualEnergyDrained;
        
        const healthToGain = actualEnergyDrained / this.ENERGY_PER_HEALTH;
        this.caster.health.currentHealth = Math.min(
            this.caster.health.maxHealth,
            this.caster.health.currentHealth + healthToGain
        );
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/SecondChanceAbility.js ===


=== FILE: src/game/abilities/StonePlatingAbility.js ===
--------------------------------------------------
 import { Ability } from './Ability.js';
    import { StatusEffect } from '../effects/StatusEffect.js';
    
    export class StonePlatingAbility extends Ability {
        constructor(caster, abilityData) {
            super(caster, abilityData);
            this.duration = 15.0;
        }
    
        _executeCast() {
            if (this.caster.statusEffects.has('stonePlating')) return false;
    
            const effect = new StatusEffect(this.caster, {
                name: 'stonePlating',
                duration: this.duration,
                properties: {
                    damageReduction: 0.80,
                    meleeDamageBoost: 0.30
                },
                onApply: (target) => {
                    target.world.emit('playerBuffActivated', { buffName: 'stonePlating' });
                },
                onRemove: (target) => {
                    target.world.emit('playerBuffDeactivated', { buffName: 'stonePlating' });
                }
            });
    
            this.caster.statusEffects.addEffect(effect);
            
            return true;
        }
    
        update(deltaTime) {
            // This is called for all abilities, even inactive ones, to handle their main cooldown
            super.update(deltaTime);
            // The active buff logic is now handled by the StatusEffectSystem
        }
    }
--------------------------------------------------
=== END OF FILE: src/game/abilities/StonePlatingAbility.js ===


=== FILE: src/game/abilities/WavePowerAbility.js ===
--------------------------------------------------
// src/game/abilities/WavePowerAbility.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { Ability } from './Ability.js';
import { GAME_CONFIG } from '../../shared/config.js';

export class WavePowerAbility extends Ability {
    constructor(caster, abilityData) {
        super(caster, abilityData);
        this.config = GAME_CONFIG.WAVE_POWER;

        // Reusable objects for performance
        this._forward = new THREE.Vector3();
        this._right = new THREE.Vector3();
        this._enemyLocalPos = new THREE.Vector3();
    }
    
    canCast() {
        const isGrounded = this.caster.jumpsRemaining === GAME_CONFIG.PLAYER.MAX_JUMPS;
        return super.canCast() && isGrounded;
    }

    _executeCast() {
        const UP_VECTOR = new THREE.Vector3(0, 1, 0);
        const playerPos = this.caster.physics.body.position;
        this.caster.camera.getWorldDirection(this._forward);
        this._forward.y = 0;
        this._forward.normalize();
        this._right.crossVectors(this._forward, UP_VECTOR);

        // Define the rectangular AoE in front of the player
        const halfWidth = this.config.WIDTH / 2;
        const halfLength = this.config.LENGTH / 2;
        
        // The center of the AoE rectangle
        const center = new THREE.Vector3().copy(playerPos).add(this._forward.clone().multiplyScalar(halfLength));
        
        // Matrix to transform world coordinates to the rectangle's local space
        const worldToLocalMatrix = new THREE.Matrix4().lookAt(this._forward, new THREE.Vector3(0,0,0), UP_VECTOR).setPosition(center).invert();

        let enemiesHit = 0;
        for (const enemy of this.caster.world.getEnemies()) {
            if (enemy.isDead || !enemy.physics.body) continue;

            // Transform enemy position to be relative to the AoE rectangle
            this._enemyLocalPos.copy(enemy.physics.body.position).applyMatrix4(worldToLocalMatrix);

            // Check if the enemy is within the rectangle's bounds
            if (Math.abs(this._enemyLocalPos.x) <= halfWidth && Math.abs(this._enemyLocalPos.z) <= halfLength) {
                this.applyEffect(enemy);
                enemiesHit++;
            }
        }
        
        // Emit event for VFX
        this.caster.world.emit('wavePowerUsed', { position: playerPos, direction: this._forward });

        return true;
    }

    applyEffect(enemy) {
        // Apply damage
        enemy.takeDamage(this.config.DAMAGE);

        // Apply knockback state and force
        enemy.ai.isKnockedBack = true;
        enemy.ai.knockbackTimer = this.config.KNOCKBACK_DURATION;

        const impulseDirection = new CANNON.Vec3().copy(this._forward);
        impulseDirection.y = this.config.IMPULSE_UPWARD / this.config.IMPULSE_FORWARD;
        impulseDirection.normalize();

        const impulse = impulseDirection.scale(this.config.IMPULSE_FORWARD);
        
        enemy.physics.body.applyImpulse(impulse, enemy.physics.body.position);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/WavePowerAbility.js ===


=== FILE: src/game/components/AbilityLoadoutComponent.js ===
--------------------------------------------------
/**
 * Data component storing an entity's equipped abilities and related state.
 */
export class AbilityLoadoutComponent {
    constructor() {
        /** @type {import('../abilities/Ability.js').Ability[]} */
        this.abilities = [null, null, null, null];
        this.selectedAbilityIndex = 0;

        this.currentEnergy = 1000;
        this.maxEnergy = 1000;
        this.energyRegenRate = 25; // per second
        this.energyRegenDelay = 5.0; // seconds
        this.lastAbilityTime = -Infinity;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/AbilityLoadoutComponent.js ===


=== FILE: src/game/components/AIComponent.js ===
--------------------------------------------------
// ~ src/game/components/AIComponent.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

/**
 * Data component storing state and parameters for an AI-controlled entity.
 */
export class AIComponent {
    constructor() {
        this.state = 'IDLE'; // e.g., IDLE, SEARCHING, COMBAT, REPOSITIONING
        this.target = null;
        
        // --- Perception ---
        this.lastKnownPlayerPosition = new CANNON.Vec3();
        this.perception = {
            detectionRange: 40,
            loseSightRange: 50,
            attackRange: 30,
            meleeAttackRange: 2.5,
            optimalRange: 22,
            minimumRange: 10,
            hasLineOfSight: false,
            distanceToPlayer: Infinity,
        };

        // --- Timers & Cooldowns ---
        this.aiUpdateInterval = 0.1; // Stagger AI logic updates for performance
        this.aiUpdateTimer = Math.random() * this.aiUpdateInterval; // Random initial offset
        
        this.actionTimers = {
            attack: 1.5,
            meleeAttack: 1.0,
            jump: 2.0,
            dash: 2.0,
            reposition: 3.0,
        };
        
        this.actionCooldowns = {
            attack: 1.5,
            meleeAttack: 1.0,
            jump: 2.0,
            dash: 2.0,
            reposition: 3.0,
        };

        // --- Movement & States---
        this.strafeDirection = 1;
        this.isDashing = false;
        this.dashDuration = 0.2;
        this.dashStateTimer = 0;
        this.dashDirection = new THREE.Vector3();
        this.isKnockedBack = false;
        this.knockbackTimer = 0;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/AIComponent.js ===


=== FILE: src/game/components/HealthComponent.js ===
--------------------------------------------------
/**
 * Data component storing health and damage-related state for an entity.
 */
export class HealthComponent {
    constructor(maxHealth = 100) {
        this.maxHealth = maxHealth;
        this.currentHealth = maxHealth;
        
        // For client-side visual feedback
        this.flashDuration = 0.15;
        this.flashTimer = 0;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/HealthComponent.js ===


=== FILE: src/game/components/PhysicsBodyComponent.js ===
--------------------------------------------------
/**
 * Data component holding a reference to an entity's CANNON-ES physics body.
 */
export class PhysicsBodyComponent {
    /**
     * @param {import('cannon-es').Body} body
     */
    constructor(body) {
        this.body = body;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/PhysicsBodyComponent.js ===


=== FILE: src/game/components/PlayerInputComponent.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Data component storing processed input state for a player-controlled entity.
 * This decouples the entity from the raw input manager.
 */
export class PlayerInputComponent {
    constructor() {
        this.moveDirection = new THREE.Vector3();
        this.lookDirection = new THREE.Quaternion();
        
        this.jumpRequested = false;
        this.dashRequested = false;
        this.slamRequested = false;
        this.slamHeld = false; // For continuous press detection

        this.firePrimary = false;
        this.fireSecondary = false;
        
        this.abilitySlotRequested = -1; // -1 means no request, 0-3 for slots
        this.swimDirection = 0; // -1 for down, 0 for neutral, 1 for up
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/PlayerInputComponent.js ===


=== FILE: src/game/components/StatusEffectComponent.js ===
--------------------------------------------------
// src/game/components/StatusEffectComponent.js

/**
 * A data component that holds and manages status effects for an entity.
 */
export class StatusEffectComponent {
    constructor() {
        /** @type {Map<string, import('../effects/StatusEffect.js').StatusEffect>} */
        this.activeEffects = new Map();
    }

    /**
     * Adds a new effect to the entity or refreshes the duration of an existing one.
     * @param {import('../effects/StatusEffect.js').StatusEffect} effect - The effect instance to add.
     */
    addEffect(effect) {
        const existing = this.activeEffects.get(effect.name);
        if (existing) {
            // Refresh duration of existing effect
            existing.timer = 0;
            return;
        }

        this.activeEffects.set(effect.name, effect);
        effect.apply();
    }

    /**
     * Checks if an effect is currently active.
     * @param {string} effectName - The name of the effect.
     * @returns {boolean}
     */
    has(effectName) {
        return this.activeEffects.has(effectName);
    }

    /**
     * Gets an active effect instance by name.
     * @param {string} effectName - The name of the effect.
     * @returns {import('../effects/StatusEffect.js').StatusEffect | undefined}
     */
    get(effectName) {
        return this.activeEffects.get(effectName);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/StatusEffectComponent.js ===


=== FILE: src/game/components/TransformComponent.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Data component storing position, rotation, and scale for an entity.
 * Useful for entities that have a visual representation but no physics body.
 */
export class TransformComponent {
    constructor() {
        this.position = new THREE.Vector3();
        this.quaternion = new THREE.Quaternion();
        this.scale = new THREE.Vector3(1, 1, 1);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/TransformComponent.js ===


=== FILE: src/game/effects/BleedingEffect.js ===
--------------------------------------------------
// src/game/effects/BleedingEffect.js
import { StatusEffect } from './StatusEffect.js';
import { GAME_CONFIG } from '../../shared/config.js';
import * as THREE from 'three'; // Import THREE for color manipulation

/**
 * A status effect that applies damage over time (DoT) to the target.
 */
export class BleedingEffect extends StatusEffect {
    constructor(target) {
        super(target, {
            name: 'bleeding',
            duration: GAME_CONFIG.BLEEDING.DURATION,
            // damagePerTick and tickInterval are properties handled by the effect itself
            // but defined by config.
        });

        this.damagePerTick = GAME_CONFIG.BLEEDING.DAMAGE_PER_TICK;
        this.tickInterval = GAME_CONFIG.BLEEDING.TICK_INTERVAL;
        this.tickTimer = 0; // Tracks time until next damage tick

        // Store original colors for restoration
        this.originalMeshColor = null;
        this.originalEmissiveColor = null;
    }

    onApply(target) {
        // Optional: Add a visual indicator or sound effect when bleeding starts
        // console.log(`${target.name} started bleeding!`);
        if (target.mesh?.material) {
            this.originalMeshColor = target.mesh.material.color.clone();
            this.originalEmissiveColor = target.mesh.material.emissive.clone();

            target.mesh.material.color.setHex(0xff0000); // Tint red
            target.mesh.material.emissive.setHex(0x330000); // Red glow
            target.mesh.material.emissiveIntensity = 0.5;
        }
    }

    onTick(target, deltaTime) {
        this.tickTimer += deltaTime;
        if (this.tickTimer >= this.tickInterval) {
            if (!target.isDead) {
                target.takeDamage(this.damagePerTick);
            }
            this.tickTimer -= this.tickInterval; // Subtract to handle potential frame skips
        }

        // Subtle pulsing effect during bleeding
        if (target.mesh?.material && this.originalEmissiveColor) {
            const pulseIntensity = Math.sin(this.timer * 8) * 0.2 + 0.3; // 0.1 to 0.5
            target.mesh.material.emissiveIntensity = pulseIntensity;
        }
    }

    onRemove(target) {
        // Optional: Clean up visual indicator or sound effect when bleeding ends
        // console.log(`${target.name} stopped bleeding.`);
        if (target.mesh?.material && this.originalMeshColor && this.originalEmissiveColor) {
            target.mesh.material.color.copy(this.originalMeshColor);
            target.mesh.material.emissive.copy(this.originalEmissiveColor);
            target.mesh.material.emissiveIntensity = 1.0; // Reset to default
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/effects/BleedingEffect.js ===


=== FILE: src/game/effects/StatusEffect.js ===
--------------------------------------------------
// src/game/effects/StatusEffect.js

/**
 * Represents a single buff, debuff, or state applied to an entity.
 * Encapsulates duration, properties, and lifecycle callbacks.
 */
export class StatusEffect {
    /**
     * @param {object} target - The entity the effect is applied to.
     * @param {object} options - Configuration for the effect.
     * @param {string} options.name - The unique name of the effect.
     * @param {number} [options.duration=Infinity] - The duration of the effect in seconds.
     * @param {object} [options.properties={}] - A key-value store for static data like damage multipliers.
     * @param {Function} [options.onApply] - Callback executed when the effect is first applied.
     * @param {Function} [options.onTick] - Callback executed on every game update.
     * @param {Function} [options.onRemove] - Callback executed when the effect expires or is removed.
     */
    constructor(target, { name, duration = Infinity, properties = {}, onApply, onTick, onRemove }) {
        this.target = target;
        this.name = name;
        this.duration = duration;
        this.properties = properties;
        this.timer = 0;
        this.isFinished = false;

        this._onApply = onApply;
        this._onTick = onTick;
        this._onRemove = onRemove;
    }

    /**
     * Called when the effect is first added to a target.
     */
    apply() {
        if (this._onApply) {
            this._onApply(this.target);
        }
    }

    /**
     * Called every frame the effect is active.
     * @param {number} deltaTime - The time since the last frame.
     */
    tick(deltaTime) {
        this.timer += deltaTime;
        if (this.duration !== Infinity && this.timer >= this.duration) {
            this.isFinished = true;
        }
        if (this._onTick) {
            this._onTick(this.target, deltaTime);
        }
    }

    /**
     * Called when the effect is removed from a target.
     */
    remove() {
        if (this._onRemove) {
            this._onRemove(this.target);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/effects/StatusEffect.js ===


=== FILE: src/game/entities/NPC.js ===
--------------------------------------------------
import * as THREE from 'three';
import { HealthComponent } from '../components/HealthComponent.js';
import { AIComponent } from '../components/AIComponent.js';
import { PhysicsBodyComponent } from '../components/PhysicsBodyComponent.js';
import { StatusEffectComponent } from '../components/StatusEffectComponent.js';
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Encapsulates a generic Non-Player Character entity's state and components.
 */
export class NPC {
    constructor(world, body, mesh, definition) {
        this.id = THREE.MathUtils.generateUUID();
        this.type = 'npc';
        this.world = world;
        this.name = definition.name || 'NPC';
        this.mesh = mesh;
        this.definition = definition;
        
        // NPC-specific properties from definition
        this.team = definition.team || 'enemy';
        this.attackType = definition.attackType || 'ranged';

        // Components
        this.health = new HealthComponent(GAME_CONFIG.NPC.BASE.MAX_HEALTH);
        this.ai = new AIComponent();
        this.physics = new PhysicsBodyComponent(body);
        this.statusEffects = new StatusEffectComponent();

        // Client-side visual state
        this.originalEmissive = new THREE.Color(mesh.material.emissive.getHex());
        // Store original base color as well for status effects that tint the model
        this.originalColor = new THREE.Color(mesh.material.color.getHex()); 
        this.isDead = false;
        
        // Water interaction state
        this.isInWater = false;
        this.currentWaterVolume = null;

        // Melee animation state
        this.isAttacking = false;
        this.attackAnimationTimer = 0;
        this.attackAnimationDuration = 0.4; // seconds
        this.leftHand = null;
        this.rightHand = null;
        this.whichHand = 'left'; // For alternating punches

        // Link back to entity for easy access from physics/rendering
        const gameEntityLink = { type: 'NPC', entity: this };
        this.userData = { gameEntity: gameEntityLink };
        mesh.userData.gameEntity = gameEntityLink;
        if (!body.userData) body.userData = {};
        body.userData.entity = this; // Use consistent .entity property for collisions
    }
    
    takeDamage(amount) {
        if (this.isDead) return;

        this.health.currentHealth -= amount;
        this.world.emit('entityTookDamage', { entity: this, amount });

        if (this.health.currentHealth <= 0) {
            this.health.currentHealth = 0;
            this.die();
        }
    }

    die() {
        if (this.isDead) return;
        this.isDead = true;
        this.world.emit('npcDied', { entity: this });
    }

    dispose() {
        if (this.physics.body) {
            this.physics.body.userData.entity = null;
            this.world.physics.queueForRemoval(this.physics.body);
            this.physics.body = null;
        }
        if (this.mesh) {
            // Restore original colors before disposing
            if (this.originalColor && this.mesh.material) {
                this.mesh.material.color.copy(this.originalColor);
                this.mesh.material.emissive.copy(this.originalEmissive);
                this.mesh.material.emissiveIntensity = 1.0;
            }
            this.mesh.userData.entity = null;
            this.mesh.geometry?.dispose();
            if (this.mesh.material.dispose) {
                this.mesh.material.dispose();
            }
            this.world.scene.remove(this.mesh);
            this.mesh = null;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/entities/NPC.js ===


=== FILE: src/game/entities/Player.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { HealthComponent } from '../components/HealthComponent.js';
import { PlayerInputComponent } from '../components/PlayerInputComponent.js';
import { PhysicsBodyComponent } from '../components/PhysicsBodyComponent.js';
import { AbilityLoadoutComponent } from '../components/AbilityLoadoutComponent.js';
import { StatusEffectComponent } from '../components/StatusEffectComponent.js';
import { GAME_CONFIG } from '../../shared/config.js';
import { AbilityFactory } from '../abilities/AbilityFactory.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
import { CustomWeapon } from '../weapons/CustomWeapon.js';

/**
 * Encapsulates the player entity's state, components, and core logic.
 */
export class Player {
    constructor(world, camera, weapon, body) {
        this.id = THREE.MathUtils.generateUUID();
        this.type = 'player';
        this.team = 'player';
        this.world = world;
        this.camera = camera;
        this.weapon = weapon;
        if (this.weapon) this.weapon.wielder = this;
        
        this.health = new HealthComponent(GAME_CONFIG.PLAYER.MAX_HEALTH);
        this.input = new PlayerInputComponent();
        this.physics = new PhysicsBodyComponent(body);
        this.abilities = new AbilityLoadoutComponent();
        this.statusEffects = new StatusEffectComponent();

        // Oxygen state
        this.maxOxygen = GAME_CONFIG.PLAYER.MAX_OXYGEN;
        this.currentOxygen = GAME_CONFIG.PLAYER.MAX_OXYGEN;
        
        this.jumpsRemaining = 0;
        this.isSlamming = false;
        this.isDead = true;
        this.lockedTarget = null;
        this.doubleJumpOnCooldown = false;
        this.doubleJumpCooldownTimer = GAME_CONFIG.PLAYER.DOUBLE_JUMP_COOLDOWN;
        this.isDashing = false;
        this.dashOnCooldown = false;
        this.dashCooldownTimer = GAME_CONFIG.PLAYER.DASH_COOLDOWN;
        this.dashStateTimer = 0;
        this.dashDirection = new THREE.Vector3();
        this.targetFov = GAME_CONFIG.PLAYER.FOV;

        // Water interaction state
        this.isSwimming = false;
        this.isAtWaterSurface = false;
        this.isWaterSpecialist = false;
        this.currentWaterVolume = null;

        if (!body.userData) body.userData = {};
        body.userData.entity = this;
        
        this.physics.body.addEventListener('collide', (e) => this.onCollide(e));
    }

    onCollide(event) {
        const otherBody = event.body;
        if (otherBody.collisionFilterGroup & COLLISION_GROUPS.WORLD) {
            const contactNormal = new CANNON.Vec3();
            if (event.contact.bi.id === this.physics.body.id) event.contact.ni.negate(contactNormal);
            else contactNormal.copy(event.contact.ni);

            if (contactNormal.dot(CANNON.Vec3.UNIT_Y) > 0.5) {
                if (this.isSlamming) {
                    this.isSlamming = false;
                    this.world.emit('playerGroundSlammed');
                }
                this.jumpsRemaining = GAME_CONFIG.PLAYER.MAX_JUMPS;
                if (!this.doubleJumpOnCooldown) {
                    this.doubleJumpCooldownTimer = GAME_CONFIG.PLAYER.DOUBLE_JUMP_COOLDOWN;
                }
            }
        }
    }

    setMoveDirection(direction) { this.input.moveDirection.copy(direction); }
    setLookDirection(euler) { this.input.lookDirection.setFromEuler(euler); }
    
    jump() {
        if (this.statusEffects.has('stonePlating') && this.jumpsRemaining < GAME_CONFIG.PLAYER.MAX_JUMPS) {
            return; // Block double jump when buff is active
        }
        this.input.jumpRequested = true;
    }
    
    dash(direction) {
        // Guard against dashing in water
        if (this.isSwimming || this.statusEffects.has('stonePlating') || this.dashOnCooldown) return;
        this.input.dashRequested = true;
        this.dashDirection.copy(direction);
    }
    
    reloadWeapon() {
        if (this.weapon && typeof this.weapon.reload === 'function') {
            this.weapon.reload();
        }
    }

    inspectWeapon() {
        if (this.weapon && typeof this.weapon.inspect === 'function') {
            this.weapon.inspect();
        }
    }
    
    requestSwim(direction) {
        this.input.swimDirection = direction;
    }

    requestSlam(isSlamming) { this.input.slamRequested = this.input.slamHeld = isSlamming; }
    selectAbility(index) { if (index >= 0 && index < this.abilities.abilities.length) this.abilities.selectedAbilityIndex = index; }

    startUsingAbility() {
        const ability = this.abilities.abilities[this.abilities.selectedAbilityIndex];
        if (ability) {
            ability.startCasting();
        }
    }

    stopUsingAbility() {
        const ability = this.abilities.abilities[this.abilities.selectedAbilityIndex];
        if (ability) {
            ability.stopCasting();
        }
    }

    cycleAbility(direction) {
        const numAbilities = this.abilities.abilities.length;
        if (numAbilities === 0) return;

        let currentIndex = this.abilities.selectedAbilityIndex;
        // The modulo trick handles wrapping around in both directions.
        // Adding numAbilities before taking the modulo ensures the result is always positive.
        const newIndex = (currentIndex + direction + numAbilities) % numAbilities;
        this.selectAbility(newIndex);
    }

    applyLoadout(loadoutData) {
        // Ensure loadoutData is an object and has a 'cards' array property.
        const cardIds = (loadoutData && Array.isArray(loadoutData.cards)) 
            ? loadoutData.cards 
            : [null, null, null, null]; // Default to empty slots if data is malformed.
        
        this.abilities.abilities = cardIds.map(cardId => 
            cardId ? AbilityFactory.create(cardId, this) : null
        );
        this.updateWaterSpecialistStatus();
    }
    
    useCustomWeapon(assetData) {
        if (this.weapon?.mesh) {
            this.camera.remove(this.weapon.mesh);
        }
        this.weapon = new CustomWeapon(assetData);
        this.weapon.wielder = this;
        if (this.weapon.mesh) {
            this.camera.add(this.weapon.mesh);
        }
    }

    updateWaterSpecialistStatus() {
        if (!this.abilities?.abilities) {
            this.isWaterSpecialist = false;
            return;
        }
        const waterAbilities = this.abilities.abilities.filter(a => a && a.data.element === 'Water').length;
        this.isWaterSpecialist = waterAbilities >= 2;
    }

    takeDamage(amount) {
        if (this.isDead || (this.world.game && this.world.game.debugModeActive)) return;
        
        let finalAmount = amount;
        if (this.statusEffects.has('stonePlating')) {
            const buff = this.statusEffects.get('stonePlating');
            finalAmount *= (1 - buff.properties.damageReduction);
        }

        this.health.currentHealth -= finalAmount;
        this.world.emit('entityTookDamage', { entity: this, amount: finalAmount });
        if (this.health.currentHealth <= 0) {
            this.health.currentHealth = 0;
            this.die();
        }
    }

    die() { if (!this.isDead) { this.isDead = true; this.world.emit('playerDied'); } }

    reset(spawnPosition) {
        this.health.currentHealth = this.health.maxHealth;
        this.abilities.currentEnergy = this.abilities.maxEnergy;
        this.currentOxygen = this.maxOxygen;
        this.isDead = false; this.isSlamming = false; this.isDashing = false; this.lockedTarget = null;
        this.jumpsRemaining = 0;
        this.doubleJumpOnCooldown = false; this.doubleJumpCooldownTimer = GAME_CONFIG.PLAYER.DOUBLE_JUMP_COOLDOWN;
        this.dashOnCooldown = false; this.dashCooldownTimer = GAME_CONFIG.PLAYER.DASH_COOLDOWN;
        this.dashStateTimer = 0;
        this.isSwimming = false;
        this.isAtWaterSurface = false;
        this.currentWaterVolume = null;
        this.abilities.abilities.forEach(a => { if(a) a.cooldownTimer = a.cooldown; });
        this.abilities.lastAbilityTime = -Infinity;
        this.statusEffects.activeEffects.clear();
        
        this.physics.body.position.copy(spawnPosition);
        this.physics.body.velocity.set(0, 0, 0);
        this.physics.body.angularVelocity.set(0, 0, 0);
        this.physics.body.wakeUp();
    }
    
    spawn(spawnPosition) { this.reset(spawnPosition); }
}
--------------------------------------------------
=== END OF FILE: src/game/entities/Player.js ===


=== FILE: src/game/prefabs/NPCPrefab.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { NPC } from '../entities/NPC.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
import { GAME_CONFIG } from '../../shared/config.js';
import { RENDERING_LAYERS } from '../../shared/CollisionGroups.js';

/**
 * A factory for creating NPC entities with all their required components.
 */
export class NPCPrefab {
    /**
     * Creates a new NPC entity.
     * @param {import('../world/World.js').World} world - The world context.
     * @param {object} definition - The NPC definition from level data.
     * @returns {NPC} The fully assembled NPC entity.
     */
    static create(world, definition) {
        const config = GAME_CONFIG.NPC.BASE;
        const team = definition.team || 'enemy';

        // 1. Visuals (Mesh)
        const geometry = new THREE.CapsuleGeometry(0.7, 1.0, 4, 8);
        const color = team === 'enemy' ? 0x990000 : 0x009933; // Red for enemies, Green for allies
        const material = new THREE.MeshStandardMaterial({ color, roughness: 0.4, emissive: 0x000000 });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.position.copy(definition.position);
        mesh.layers.enable(RENDERING_LAYERS.NO_REFLECTION);

        // 2. Physics (Body)
        const shape = new CANNON.Sphere(config.RADIUS);
        
        let group, mask;
        if (team === 'enemy') {
            group = COLLISION_GROUPS.ENEMY;
            mask = COLLISION_GROUPS.WORLD | COLLISION_GROUPS.PLAYER | COLLISION_GROUPS.ALLY | COLLISION_GROUPS.PLAYER_PROJECTILE | COLLISION_GROUPS.TRIGGER | COLLISION_GROUPS.WATER;
        } else { // ally
            group = COLLISION_GROUPS.ALLY;
            mask = COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY | COLLISION_GROUPS.ENEMY_PROJECTILE | COLLISION_GROUPS.TRIGGER | COLLISION_GROUPS.WATER;
        }
        
        const body = new CANNON.Body({
            mass: config.MASS,
            shape,
            position: new CANNON.Vec3(definition.position.x, definition.position.y, definition.position.z),
            fixedRotation: true,
            collisionFilterGroup: group,
            collisionFilterMask: mask,
            linearDamping: 0.1,
        });

        // 3. Entity creation
        const entity = new NPC(world, body, mesh, definition);
        
        // 4. Add melee "hands" if applicable
        if (entity.attackType === 'melee') {
            const handGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const handMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.6 });
            
            entity.leftHand = new THREE.Mesh(handGeo, handMat);
            entity.leftHand.position.set(-0.7, 0.2, 0.5); // Position relative to parent capsule
            entity.leftHand.castShadow = true;
            
            entity.rightHand = new THREE.Mesh(handGeo, handMat);
            entity.rightHand.position.set(0.7, 0.2, 0.5); // Position relative to parent capsule
            entity.rightHand.castShadow = true;

            mesh.add(entity.leftHand, entity.rightHand);
        }
        
        return entity;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/prefabs/NPCPrefab.js ===


=== FILE: src/game/prefabs/PlayerPrefab.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { Player } from '../entities/Player.js';
import { WeaponFactory } from '../weapons/WeaponFactory.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * A factory for creating the player entity with all its required components.
 */
export class PlayerPrefab {
    static create(world, camera, viewModelScene, loadoutData) {
        const { physics } = world;
        const config = GAME_CONFIG.PLAYER;

        const shape = new CANNON.Sphere(config.RADIUS);
        const material = new CANNON.Material({ name: 'playerMaterial', friction: 0.0 });
        const body = new CANNON.Body({
            mass: config.MASS,
            shape,
            material,
            fixedRotation: true,
            allowSleep: false,
            collisionFilterGroup: COLLISION_GROUPS.PLAYER,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY | COLLISION_GROUPS.ENEMY_PROJECTILE | COLLISION_GROUPS.TRIGGER | COLLISION_GROUPS.WATER,
            linearDamping: config.DEFAULT_DAMPING,
            // --- CONTINUOUS COLLISION DETECTION (CCD) ---
            // Activate CCD if speed exceeds 15 m/s to prevent tunneling.
            ccdSpeedThreshold: 15, 
            // Set the radius for the swept sphere check, slightly smaller than the actual radius.
            ccdSweptSphereRadius: 0.75, 
        });
        const playerWorldContactMaterial = new CANNON.ContactMaterial(
            physics.world.defaultMaterial, material,
            { friction: 0.0, restitution: 0.0, contactEquationStiffness: 1e8, contactEquationRelaxation: 3, frictionEquationStiffness: 1e8 }
        );
        physics.addContactMaterial(playerWorldContactMaterial);
        
        const weaponId = loadoutData?.weapon || 'WEAPON_001';
        const weapon = WeaponFactory.create(weaponId);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
        directionalLight.position.set(0.5, 0.8, -0.2).normalize();
        
        if (weapon?.mesh) {
            camera.add(weapon.mesh);
        }
        viewModelScene.add(ambientLight, directionalLight, camera);
        
        const entity = new Player(world, camera, weapon, body);
        entity.applyLoadout(loadoutData || { cards: [null, null, null, null], weapon: null });
        
        return entity;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/prefabs/PlayerPrefab.js ===


=== FILE: src/game/systems/AbilitySystem.js ===
--------------------------------------------------
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Manages ability cooldowns for entities.
 * Energy regeneration is now handled by PlayerResourceSystem.
 */
export class AbilitySystem {
    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        for (const entity of world.getEntities()) {
            if (entity.abilities) {
                this._updateCooldowns(entity.abilities, deltaTime);
            }
        }
    }

    _updateCooldowns(abilitiesComponent, deltaTime) {
        for (const ability of abilitiesComponent.abilities) {
            if (ability) {
                ability.update(deltaTime);
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/AbilitySystem.js ===


=== FILE: src/game/systems/AISystem.js ===
--------------------------------------------------
import * as CANNON from 'cannon-es';
import * as THREE from 'three';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
import { Util } from '../../shared/util.js';
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Manages AI behavior for NPC entities.
 */
export class AISystem {
    constructor() {
        // --- PERFORMANCE: Reusable objects to prevent GC churn ---
        this._perceptionRayFrom = new CANNON.Vec3();
        this._perceptionRayTo = new CANNON.Vec3();
        this._losRayResult = new CANNON.RaycastResult();
        this._obstacleRayResult = new CANNON.RaycastResult();
        this._groundRayResult = new CANNON.RaycastResult();
        this._ledgeRayResult = new CANNON.RaycastResult();
        this._lookAtTarget = new THREE.Vector3();
        this._tempQuaternion = new CANNON.Quaternion();
        this._tempObject3D = new THREE.Object3D();
        this._forward = new THREE.Vector3();
    }

    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        for (const npc of world.getNPCs()) {
            if (npc.isDead) continue;

            this._updateAnimations(npc, deltaTime);
            this._updateTimers(npc.ai, deltaTime);

            if (npc.ai.isKnockedBack) {
                npc.ai.knockbackTimer -= deltaTime;
                if (npc.ai.knockbackTimer <= 0) npc.ai.isKnockedBack = false;
                continue;
            }
            
            npc.ai.aiUpdateTimer += deltaTime;
            if (npc.ai.aiUpdateTimer >= npc.ai.aiUpdateInterval) {
                this._runAI(world, npc);
                npc.ai.aiUpdateTimer = 0;
            }
            
            this._applyMovement(world, npc);
        }
    }
    
    _runAI(world, npc) {
        this._updateTarget(world, npc);
        if (!npc.ai.target) {
            npc.ai.state = 'IDLE';
            npc.physics.body.velocity.x *= 0.9;
            npc.physics.body.velocity.z *= 0.9;
            return;
        }

        this._updatePerception(world, npc);
        this._updateState(npc);
        this._executeStateActions(world, npc);
    }
    
    _updateTarget(world, npc) {
        let potentialTargets = [];
        if (npc.team === 'enemy') {
            potentialTargets = [world.player, ...world.getAllies()].filter(t => t && !t.isDead);
        } else { // ally
            potentialTargets = world.getEnemies().filter(t => t && !t.isDead);
        }

        let closestTarget = null;
        let minDistanceSq = Infinity;

        for (const target of potentialTargets) {
            const distanceSq = npc.physics.body.position.distanceSquared(target.physics.body.position);
            if (distanceSq < minDistanceSq) {
                minDistanceSq = distanceSq;
                closestTarget = target;
            }
        }
        npc.ai.target = closestTarget;
    }

    _updatePerception(world, npc) {
        const ai = npc.ai;
        ai.perception.distanceToPlayer = npc.physics.body.position.distanceTo(ai.target.physics.body.position);
        
        this._perceptionRayFrom.copy(npc.physics.body.position);
        this._perceptionRayFrom.y += 1.0;
        this._perceptionRayTo.copy(ai.target.physics.body.position);
        this._perceptionRayTo.y += 1.0;

        this._losRayResult.reset();
        world.physics.world.raycastClosest(
            this._perceptionRayFrom, this._perceptionRayTo,
            {
                collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.VISION_BLOCKER,
                skipBackfaces: true
            },
            this._losRayResult
        );
        
        ai.perception.hasLineOfSight = !this._losRayResult.hasHit;
        if (ai.perception.hasLineOfSight) {
            ai.lastKnownPlayerPosition.copy(ai.target.physics.body.position);
        }
    }

    _updateState(npc) {
        const ai = npc.ai;
        if (!ai.target) {
            ai.state = 'IDLE';
            return;
        }
    
        // If we can see the target and are close enough, enter combat.
        if (ai.perception.hasLineOfSight && ai.perception.distanceToPlayer < ai.perception.detectionRange) {
            ai.state = 'COMBAT';
        } 
        // If we are in combat but have lost line of sight, start searching.
        else if (ai.state === 'COMBAT' && !ai.perception.hasLineOfSight) {
            ai.state = 'SEARCHING';
        }
        // If we are in combat but the target moved too far away, start searching.
        else if (ai.state === 'COMBAT' && ai.perception.distanceToPlayer > ai.perception.loseSightRange) {
            ai.state = 'SEARCHING';
        }
        // If we were searching and have arrived at the last known position, go idle.
        else if (ai.state === 'SEARCHING' && npc.physics.body.position.distanceTo(ai.lastKnownPlayerPosition) < 2) {
            ai.state = 'IDLE';
        }
    }

    _executeStateActions(world, npc) {
        const { ai } = npc;
        if (ai.isDashing) {
            if (ai.dashStateTimer >= ai.dashDuration) ai.isDashing = false;
            return;
        }
        
        this._faceTarget(npc, ai.lastKnownPlayerPosition);
        if (ai.state === 'COMBAT') this._handleCombatDecisions(world, npc);
    }

    _handleCombatDecisions(world, npc) {
        if (npc.attackType === 'ranged') this._handleRangedCombat(world, npc);
        else if (npc.attackType === 'melee') this._handleMeleeCombat(world, npc);
    }
    
    _handleRangedCombat(world, npc) {
        const { ai, physics } = npc;
        const { distanceToPlayer, hasLineOfSight, attackRange } = ai.perception;

        if (npc.isInWater) {
            this._navigateObstacles(world, npc);
            return;
        }
        
        if (hasLineOfSight && distanceToPlayer <= attackRange && ai.actionTimers.attack <= 0) {
            this._shoot(world, npc, ai.target);
            ai.actionTimers.attack = ai.actionCooldowns.attack;
        }

        this._navigateObstacles(world, npc);
        if (ai.actionTimers.dash <= 0) {
            const toPlayerDir = new CANNON.Vec3().copy(ai.lastKnownPlayerPosition).vsub(physics.body.position);
            const right = new THREE.Vector3().crossVectors(toPlayerDir, CANNON.Vec3.UNIT_Y).normalize();
            ai.dashDirection.copy(right.multiplyScalar(Math.random() > 0.5 ? 1 : -1));
            ai.isDashing = true;
            ai.dashStateTimer = 0;
            ai.actionTimers.dash = ai.actionCooldowns.dash;
        }
    }
    
    _handleMeleeCombat(world, npc) {
        const { ai } = npc;
        const { distanceToPlayer, hasLineOfSight, meleeAttackRange } = ai.perception;

        if (npc.isInWater) {
            this._navigateObstacles(world, npc);
            return;
        }

        if (hasLineOfSight && distanceToPlayer <= meleeAttackRange && ai.actionTimers.meleeAttack <= 0) {
            this._meleeAttack(npc, ai.target);
            ai.actionTimers.meleeAttack = ai.actionCooldowns.meleeAttack;
        }
        this._navigateObstacles(world, npc);
    }
    
    _meleeAttack(npc, target) {
        const config = GAME_CONFIG.NPC.MELEE;
        // A simple check if the target is in front of the NPC
        this._forward.set(0, 0, 1).applyQuaternion(npc.physics.body.quaternion);
        const toTarget = new THREE.Vector3().copy(target.physics.body.position).sub(npc.physics.body.position).normalize();
        
        if (this._forward.dot(toTarget) > 0.7) { // Check if target is roughly in front (cone)
            target.takeDamage(config.DAMAGE);
            // Trigger animation state
            if (!npc.isAttacking) {
                npc.isAttacking = true;
                npc.attackAnimationTimer = 0;
                npc.whichHand = (npc.whichHand === 'left') ? 'right' : 'left'; // Alternate hands
            }
        }
    }

    _applyMovement(world, npc) {
        const { ai, physics } = npc;

        if (ai.isDashing) {
            const dashSpeed = GAME_CONFIG.NPC.BASE.SPEED * GAME_CONFIG.PLAYER.DASH_SPEED_MULTIPLIER;
            physics.body.velocity.x = ai.dashDirection.x * dashSpeed;
            physics.body.velocity.y = 0; // Dashes are horizontal
            physics.body.velocity.z = ai.dashDirection.z * dashSpeed;
            return;
        }

        physics.body.wakeUp();

        let moveDirection;
        const avoidanceVector = this._getLedgeAvoidanceVector(world, npc);

        if (avoidanceVector) {
            moveDirection = avoidanceVector;
        } else {
            moveDirection = new CANNON.Vec3();
            switch(ai.state) {
                case 'IDLE':
                    physics.body.velocity.x *= 0.9;
                    physics.body.velocity.z *= 0.9;
                    return;
                case 'SEARCHING':
                    ai.lastKnownPlayerPosition.vsub(physics.body.position, moveDirection);
                    break;
                case 'COMBAT':
                    moveDirection = this._getCombatRepositionVector(npc);
                    break;
            }
        }

        if (moveDirection.lengthSquared() < 0.01) {
            physics.body.velocity.x *= 0.9;
            physics.body.velocity.z *= 0.9;
            return;
        }

        moveDirection.y = 0; // Movement is planar
        const normalizedMoveDir = moveDirection.clone();
        normalizedMoveDir.normalize();

        const speed = GAME_CONFIG.NPC.BASE.SPEED;
        physics.body.velocity.x = normalizedMoveDir.x * speed;
        physics.body.velocity.z = normalizedMoveDir.z * speed;
    }
    
    _getCombatRepositionVector(npc) {
        const { ai, physics } = npc;
        const { distanceToPlayer, optimalRange, minimumRange, meleeAttackRange } = ai.perception;
        const toPlayerDir = new CANNON.Vec3().copy(ai.lastKnownPlayerPosition).vsub(physics.body.position);

        if (npc.attackType === 'melee') {
            if (distanceToPlayer > meleeAttackRange * 0.8) return toPlayerDir; // Get closer
            return new CANNON.Vec3(); // Stay put
        } else { // Ranged
            if (distanceToPlayer > optimalRange) return toPlayerDir;
            if (distanceToPlayer < minimumRange) return toPlayerDir.negate();
            
            if (ai.actionTimers.reposition <= 0) {
                ai.strafeDirection *= -1;
                ai.actionTimers.reposition = ai.actionCooldowns.reposition;
            }
            return new CANNON.Vec3(toPlayerDir.z, 0, -toPlayerDir.x).scale(ai.strafeDirection);
        }
    }
    
    _navigateObstacles(world, npc) {
        const { physics, ai } = npc;
        if (physics.body.velocity.lengthSquared() < 0.1 || ai.actionTimers.jump <= 0) return;

        const rayFrom = new CANNON.Vec3().copy(physics.body.position);
        
        const velocityDirection = physics.body.velocity.clone();
        velocityDirection.normalize();
        const rayVector = velocityDirection.scale(2);
        const rayTo = rayFrom.clone().vadd(rayVector);

        this._obstacleRayResult.reset();
        world.physics.world.raycastClosest(rayFrom, rayTo, { collisionFilterMask: COLLISION_GROUPS.WORLD }, this._obstacleRayResult);
        
        if (this._obstacleRayResult.hasHit) {
             const groundRayTo = rayFrom.clone().vadd(new CANNON.Vec3(0, -1.1, 0));
             this._groundRayResult.reset();
             world.physics.world.raycastClosest(rayFrom, groundRayTo, { collisionFilterMask: COLLISION_GROUPS.WORLD }, this._groundRayResult);
             if (this._groundRayResult.hasHit) {
                 physics.body.velocity.y = GAME_CONFIG.PLAYER.JUMP_HEIGHT;
                 ai.actionTimers.jump = ai.actionCooldowns.jump;
             }
        }
    }
    
    _shoot(world, npc, target) {
        const config = GAME_CONFIG.NPC.RANGED;
        const timeToTarget = npc.ai.perception.distanceToPlayer / config.PROJECTILE_SPEED;
        const predictionTime = Math.min(timeToTarget, 1.0);
        const predictedPosition = new THREE.Vector3().copy(target.physics.body.position).add(
            new THREE.Vector3().copy(target.physics.body.velocity).multiplyScalar(predictionTime)
        );
        predictedPosition.y += 0.5;

        const launchVelocity = Util.calculateBallisticLaunchVelocity(
            new THREE.Vector3().copy(npc.physics.body.position), predictedPosition,
            config.PROJECTILE_SPEED, Math.abs(world.physics.world.gravity.y)
        );

        world.createEnemyProjectile({
            caster: npc,
            initialVelocity: launchVelocity || new THREE.Vector3().subVectors(predictedPosition, npc.physics.body.position).normalize().multiplyScalar(config.PROJECTILE_SPEED)
        });
    }

    _updateTimers(ai, deltaTime) {
        for (const key in ai.actionTimers) {
            if (ai.actionTimers[key] > 0) {
                ai.actionTimers[key] -= deltaTime;
            }
        }
        if (ai.isDashing) ai.dashStateTimer += deltaTime;
    }
    
    _faceTarget(npc, targetPosition) {
        this._lookAtTarget.copy(targetPosition);
        this._lookAtTarget.y = npc.physics.body.position.y;
        this._tempObject3D.position.copy(npc.physics.body.position);
        this._tempObject3D.lookAt(this._lookAtTarget);
        this._tempQuaternion.copy(this._tempObject3D.quaternion);
        npc.physics.body.quaternion.slerp(this._tempQuaternion, 0.1, npc.physics.body.quaternion);
    }

    _getLedgeAvoidanceVector(world, npc) {
        const body = npc.physics.body;
        const config = GAME_CONFIG.NPC.BASE;
        const probeDistance = config.RADIUS * 1.5;
        const rayLength = 5.0; // How far down to check for ground
        const worldPhysics = world.physics.world;

        const directions = [
            new CANNON.Vec3(1, 0, 0),    // E
            new CANNON.Vec3(0.707, 0, 0.707), // SE
            new CANNON.Vec3(0, 0, 1),    // S
            new CANNON.Vec3(-0.707, 0, 0.707),// SW
            new CANNON.Vec3(-1, 0, 0),   // W
            new CANNON.Vec3(-0.707, 0, -0.707),// NW
            new CANNON.Vec3(0, 0, -1),   // N
            new CANNON.Vec3(0.707, 0, -0.707) // NE
        ];

        let avoidanceVector = new CANNON.Vec3();
        let dangerCount = 0;

        for (const dir of directions) {
            const rayFrom = body.position.clone().vadd(dir.scale(probeDistance));
            rayFrom.y += 0.5; // Start ray slightly above NPC's feet level
            const rayTo = rayFrom.clone();
            rayTo.y -= rayLength;

            this._ledgeRayResult.reset();
            worldPhysics.raycastClosest(
                rayFrom,
                rayTo,
                { collisionFilterMask: COLLISION_GROUPS.WORLD },
                this._ledgeRayResult
            );

            if (!this._ledgeRayResult.hasHit) {
                dangerCount++;
                // Add the vector pointing AWAY from the danger.
                avoidanceVector.vsub(dir, avoidanceVector);
            }
        }

        // If we are partially on a ledge, move away from it.
        // If we are totally surrounded by a ledge (dangerCount=8), don't move.
        // If we are totally safe (dangerCount=0), do nothing.
        if (dangerCount > 0 && dangerCount < 8) { 
            avoidanceVector.normalize();
            return avoidanceVector;
        }

        return null; // No avoidance needed
    }

    _updateAnimations(npc, deltaTime) {
        if (!npc.isAttacking || npc.attackType !== 'melee') return;

        npc.attackAnimationTimer += deltaTime;
        const progress = Math.min(npc.attackAnimationTimer / npc.attackAnimationDuration, 1.0);

        // A simple "punch" animation: forward then back
        // The sin curve creates a smooth 0 -> 1 -> 0 motion over the animation duration.
        const punchProgress = Math.sin(progress * Math.PI);

        const handToAnimate = (npc.whichHand === 'left') ? npc.leftHand : npc.rightHand;
        if (handToAnimate) {
            const initialZ = 0.5; // From prefab
            const punchDistance = 0.8;
            handToAnimate.position.z = initialZ + punchProgress * punchDistance;
        }

        if (progress >= 1.0) {
            npc.isAttacking = false;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/AISystem.js ===


=== FILE: src/game/systems/AnimationSystem.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Plays keyframe animations defined in custom asset data.
 */
export class AnimationSystem {
    constructor() {
        this.activeAnimations = new Map(); // Map<entity, { clipName, time, duration }>
    }

    update(world, deltaTime) {
        // Listen for new animation requests
        world.on('animationTriggered', ({ entity, clipName }) => {
            if (entity.assetData?.animations[clipName]) {
                const clip = entity.assetData.animations[clipName];
                this.activeAnimations.set(entity, {
                    clipName,
                    time: 0,
                    duration: clip.duration,
                });
            }
        });

        if (this.activeAnimations.size === 0) return;

        // Update active animations
        for (const [entity, animState] of this.activeAnimations.entries()) {
            animState.time += deltaTime;

            if (animState.time >= animState.duration) {
                this.resetToIdle(entity);
                this.activeAnimations.delete(entity);
                continue;
            }

            this.applyKeyframes(entity, animState);
        }
    }

    applyKeyframes(entity, animState) {
        const clip = entity.assetData.animations[animState.clipName];
        if (!clip) return;

        for (const track of clip.tracks) {
            const targetPart = entity.parts.get(track.targetUUID);
            if (!targetPart) continue;

            const { prevKey, nextKey } = this.findSurroundingKeys(track.keyframes, animState.time);
            
            if (!prevKey) continue;

            const t = (nextKey)
                ? (animState.time - prevKey.time) / (nextKey.time - prevKey.time)
                : 1;

            const value = (nextKey) 
                ? THREE.MathUtils.lerp(prevKey.value, nextKey.value, t)
                : prevKey.value;
            
            // This is a simplified version; a full implementation would handle vectors and quaternions.
            // e.g., if track.property is "position.z"
            const props = track.property.split('.');
            if (props.length === 2 && targetPart[props[0]]) {
                targetPart[props[0]][props[1]] = value;
            }
        }
    }

    findSurroundingKeys(keyframes, time) {
        let prevKey = null, nextKey = null;
        for (const key of keyframes) {
            if (key.time <= time) {
                prevKey = key;
            } else {
                nextKey = key;
                break;
            }
        }
        return { prevKey, nextKey };
    }

    resetToIdle(entity) {
        for (const partData of entity.assetData.geometry) {
            const partMesh = entity.parts.get(partData.uuid);
            if (!partMesh) continue;
            const { position, rotation } = partData.transform;
            if (position) partMesh.position.fromArray(position);
            if (rotation) partMesh.quaternion.setFromEuler(new THREE.Euler().fromArray(rotation));
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/AnimationSystem.js ===


=== FILE: src/game/systems/DeathSystem.js ===
--------------------------------------------------
// ~ src/game/systems/DeathSystem.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

const DEATH_DURATION = 2.5; // seconds

/**
 * Manages the death sequence for entities, providing a more visually
 * appealing effect than immediate removal.
 */
export class DeathSystem {
    constructor() {
        this.dyingEntities = new Map(); // Map<entity, { timer: number }>
    }

    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        // Find newly dead NPCs and start their death sequence
        for (const npc of world.getNPCs()) {
            if (npc.isDead && !this.dyingEntities.has(npc)) {
                this.startDeathSequence(npc);
            }
        }

        // Update ongoing death sequences
        for (const [entity, state] of this.dyingEntities.entries()) {
            state.timer -= deltaTime;
            
            this.updateFadeOut(entity, state.timer);

            if (state.timer <= 0) {
                world.remove(entity);
                this.dyingEntities.delete(entity);
            }
        }
    }

    /**
     * Initiates the death sequence for an NPC.
     * @param {import('../entities/NPC.js').NPC} npc
     */
    startDeathSequence(npc) {
        this.dyingEntities.set(npc, { timer: DEATH_DURATION });
        
        if (npc.physics?.body) {
            const body = npc.physics.body;
            // Make it a ragdoll
            body.fixedRotation = false;
            body.updateMassProperties();

            // Give it a little push for a dynamic fall
            const impulse = new CANNON.Vec3(
                (Math.random() - 0.5) * 100,
                Math.random() * 150,
                (Math.random() - 0.5) * 100
            );
            const point = new CANNON.Vec3(0, 0.5, 0);
            body.applyImpulse(impulse, point);
        }

        // Prepare material for fading
        if (npc.mesh?.material) {
            npc.mesh.material.transparent = true;
        }
    }

    /**
     * Updates the opacity of an entity's mesh to create a fade-out effect.
     * @param {object} entity
     * @param {number} timer
     */
    updateFadeOut(entity, timer) {
        if (entity.mesh?.material) {
            const opacity = Math.max(0, timer / DEATH_DURATION);
            entity.mesh.material.opacity = opacity;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/DeathSystem.js ===


=== FILE: src/game/systems/MovementSystem.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { GAME_CONFIG } from '../../shared/config.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
        
/**
* Handles player movement based on input, including jumping, dashing, and ground slams.
*/
export class MovementSystem {
    constructor() {
        this.swimForce = new CANNON.Vec3();
    }
    
    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        const player = world.player;
        if (!player || player.isDead) return;

        player.physics.body.wakeUp();

        this._handleCooldowns(player, deltaTime);
        this._handleLook(player);
        this._handleFOV(player, deltaTime);
        
        if (player.isSwimming) {
            this._applySwimMovement(player);
        } else {
            this._applyLandMovement(player, deltaTime);
        }

        // Reset single-press inputs after they have been processed for the frame.
        player.input.jumpRequested = false;
    }

    _applySwimMovement(player) {
        const { input, physics } = player;
    
        player.isDashing = false;
        player.isSlamming = false;
    
        // Determine if player is at the surface of the water
        let atSurface = false;
        if (player.currentWaterVolume) {
            const body = player.physics.body;
            const volume = player.currentWaterVolume;
            const surfaceY = volume.body.position.y + volume.definition.size[1] / 2;
            
            if (body.position.y >= surfaceY - body.shapes[0].radius) {
                atSurface = true;
            }
        }
        player.isAtWaterSurface = atSurface;
        
        // Prioritize jumping out of the water if requested at the surface
        if (player.input.jumpRequested && atSurface) {
            const body = player.physics.body;
            body.velocity.y = GAME_CONFIG.PLAYER.JUMP_HEIGHT;
            player.world.emit('playerJumped');
            
            player.jumpsRemaining = GAME_CONFIG.PLAYER.MAX_JUMPS;
            
            player.isSwimming = false;
            player.isAtWaterSurface = false;
            player.physics.body.linearDamping = GAME_CONFIG.PLAYER.DEFAULT_DAMPING;
            player.currentWaterVolume = null;
            return; // Exit early, we are no longer swimming
        }
    
        // Apply horizontal movement force
        this._applySwimHorizontalMovement(player);
    
        // Apply vertical movement force (swimming up/down)
        const forceMagnitude = GAME_CONFIG.PLAYER.SWIM_SPEED * GAME_CONFIG.PLAYER.SWIM_FORCE_MULTIPLIER;
        let verticalForce = 0;
        
        if (input.swimDirection > 0) {
            verticalForce = forceMagnitude;
        } else if (input.swimDirection < 0) {
            verticalForce = -forceMagnitude;
        }
        
        if (verticalForce !== 0) {
            this.swimForce.set(0, verticalForce, 0);
            physics.body.applyForce(this.swimForce, physics.body.position);
        }
        
        // Clamp vertical speed
        const maxVerticalSpeed = GAME_CONFIG.PLAYER.SWIM_SPEED * 1.5;
        if (Math.abs(physics.body.velocity.y) > maxVerticalSpeed) {
            physics.body.velocity.y = Math.sign(physics.body.velocity.y) * maxVerticalSpeed;
        }
    }

    /**
     * Applies horizontal movement in water using forces, which allows the physics
     * solver to correctly handle collisions with static objects like logs.
     * @param {import('../entities/Player.js').Player} player 
     */
    _applySwimHorizontalMovement(player) {
        const speed = GAME_CONFIG.PLAYER.SPEED * 0.6; // Water speed modifier
        const body = player.physics.body;
        const moveDirection = player.input.moveDirection;
        
        const targetVelocity = new CANNON.Vec3(
            moveDirection.x * speed,
            body.velocity.y,
            moveDirection.z * speed
        );

        const force = new CANNON.Vec3();
        targetVelocity.vsub(body.velocity, force);
        force.y = 0; // Only apply horizontal force
        force.scale(body.mass * 20, force); // Proportional gain for responsiveness
        body.applyForce(force, body.position);
    }

    _applyLandMovement(player, deltaTime) {
        const { input, physics } = player;
        
        this._initiateDash(player);

        if (player.isSlamming) {
            physics.body.velocity.y = GAME_CONFIG.PLAYER.GROUND_SLAM_VELOCITY;
        } else if (player.isDashing) {
            this._applyDashMovement(player);
        } else {
            this._applyStandardMovement(player, input.moveDirection);
        }
        
        this._handleJump(player);
        this._handleSlam(player);
    }
        
    _initiateDash(player) {
        if (player.input.dashRequested && !player.isDashing && !player.dashOnCooldown) {
            player.isDashing = true;
            player.dashOnCooldown = true;
            player.dashStateTimer = 0;
            player.dashCooldownTimer = 0;
            
            const cameraDir = new THREE.Vector3();
            player.camera.getWorldDirection(cameraDir);
            cameraDir.y = 0;
            cameraDir.normalize();
        
            const rightDir = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), cameraDir).normalize();
            
            const forwardDot = player.dashDirection.dot(cameraDir);
            const rightDot = player.dashDirection.dot(rightDir);
    
            player.world.emit('playerDashed', { forwardDot, rightDot });
    
            if (Math.abs(forwardDot) > Math.abs(rightDot)) {
                player.targetFov = GAME_CONFIG.PLAYER.FOV + (forwardDot > 0 ? 15 : -10);
            }
            
            player.input.dashRequested = false;
        }
    }
        
    _handleFOV(player, deltaTime) {
        if (Math.abs(player.camera.fov - player.targetFov) > 0.01) {
            player.camera.fov = THREE.MathUtils.lerp(player.camera.fov, player.targetFov, deltaTime * 10);
            player.camera.updateProjectionMatrix();
        }
        
        if (!player.isDashing && player.targetFov !== GAME_CONFIG.PLAYER.FOV) {
            player.targetFov = GAME_CONFIG.PLAYER.FOV;
        }
    }
        
    _handleCooldowns(player, deltaTime) {
        const config = GAME_CONFIG.PLAYER;
        
        if (player.doubleJumpOnCooldown) {
            player.doubleJumpCooldownTimer += deltaTime;
            if (player.doubleJumpCooldownTimer >= config.DOUBLE_JUMP_COOLDOWN) {
                player.doubleJumpOnCooldown = false;
                player.doubleJumpCooldownTimer = config.DOUBLE_JUMP_COOLDOWN;
            }
        }
        
        if (player.dashOnCooldown) {
            player.dashCooldownTimer += deltaTime;
            if (player.dashCooldownTimer >= config.DASH_COOLDOWN) {
                player.dashOnCooldown = false;
            }
        }
        
        if (player.isDashing) {
            player.dashStateTimer += deltaTime;
            if (player.dashStateTimer >= config.DASH_DURATION) {
                player.isDashing = false;
            }
        }
    }
        
    _handleLook(player) {
        player.camera.quaternion.slerp(player.input.lookDirection, 0.9);
    }
        
    _applyStandardMovement(player, moveDirection) {
        let speed = GAME_CONFIG.PLAYER.SPEED;
        if (player.statusEffects.has('stonePlating')) {
            speed *= 0.8;
        }
    
        const body = player.physics.body;
        const yVelocity = body.velocity.y; // Preserve vertical velocity from gravity, jumps, etc.
    
        // Directly set the horizontal velocity for responsive control
        body.velocity.x = moveDirection.x * speed;
        body.velocity.z = moveDirection.z * speed;
        
        // Restore the vertical velocity
        body.velocity.y = yVelocity;
    }
        
    _applyDashMovement(player) {
        const dashSpeed = GAME_CONFIG.PLAYER.SPEED * GAME_CONFIG.PLAYER.DASH_SPEED_MULTIPLIER;
        const velocity = player.physics.body.velocity;
        velocity.x = player.dashDirection.x * dashSpeed;
        velocity.z = player.dashDirection.z * dashSpeed;
    }
            
    _handleJump(player) {
        if (!player.input.jumpRequested || player.jumpsRemaining <= 0) return;
        
        const performJump = () => {
            player.physics.body.velocity.y = GAME_CONFIG.PLAYER.JUMP_HEIGHT;
            player.world.emit('playerJumped');
            player.jumpsRemaining--;
        };
        
        if (player.jumpsRemaining === 1 && GAME_CONFIG.PLAYER.MAX_JUMPS === 2) {
            if (!player.doubleJumpOnCooldown) {
                player.doubleJumpOnCooldown = true;
                player.doubleJumpCooldownTimer = 0;
                performJump();
            }
        } else {
            performJump();
        }
    }
            
    _handleSlam(player) {
        const isAirborne = player.jumpsRemaining < GAME_CONFIG.PLAYER.MAX_JUMPS;
        
        if (player.input.slamRequested && !player.isSlamming) {
            if (isAirborne && player.physics.body.velocity.y < 0) {
                player.isSlamming = true;
            }
        } else if (player.isSlamming && !player.input.slamHeld) {
            player.isSlamming = false;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/MovementSystem.js ===


=== FILE: src/game/systems/OutOfBoundsSystem.js ===
--------------------------------------------------
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * A system to handle entities falling out of the world bounds.
 * This acts as a failsafe to prevent soft-locks.
 */

export class OutOfBoundsSystem {
    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        const threshold = GAME_CONFIG.DEATH_Y;

        for (const entity of world.getEntities()) {
            // Skip entities that are already dead or don't have a physics body
            if (entity.isDead || !entity.physics?.body) continue;

            if (entity.physics.body.position.y < threshold) {
                // The `die` method on both Player and Enemy will handle the necessary events.
                if (typeof entity.die === 'function') {
                    entity.die();
                }
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/OutOfBoundsSystem.js ===


=== FILE: src/game/systems/PhysicsSyncSystem.js ===
--------------------------------------------------
// src/game/systems/PhysicsSyncSystem.js

/**
 * Synchronizes the visual representation (Three.js mesh) of entities
 * with their physics simulation state (CANNON-ES body).
 */

export class PhysicsSyncSystem {
    /**
     * @param {import('../world/World.js').World} world
     */
    update(world) {
        // General sync for all entities with a mesh and body
        for (const entity of world.getEntities()) {
            if (entity.mesh && entity.physics?.body) {
                entity.mesh.position.copy(entity.physics.body.position);
                entity.mesh.quaternion.copy(entity.physics.body.quaternion);
            }
        }

        // Specific sync for the player's camera, which acts as the 'view'
        if (world.player && !world.player.isDead) {
            world.player.camera.position.copy(world.player.physics.body.position);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/PhysicsSyncSystem.js ===


=== FILE: src/game/systems/PlayerResourceSystem.js ===
--------------------------------------------------
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Manages player-specific resources like energy and oxygen.
 */
export class PlayerResourceSystem {
    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        const player = world.player;
        if (!player || player.isDead) return;

        this._updateEnergy(world, player, deltaTime);
        this._updateOxygen(player, deltaTime);
    }

    _updateEnergy(world, player, deltaTime) {
        const abilities = player.abilities;
        const config = GAME_CONFIG.PLAYER;

        if (world.physics.world.time - abilities.lastAbilityTime > config.ENERGY_REGEN_DELAY) {
            if (abilities.currentEnergy < abilities.maxEnergy) {
                abilities.currentEnergy = Math.min(
                    abilities.maxEnergy,
                    abilities.currentEnergy + config.ENERGY_REGEN_RATE * deltaTime
                );
            }
        }
    }

    _updateOxygen(player, deltaTime) {
        const config = GAME_CONFIG.PLAYER;
        // Consume oxygen only when submerged, not a water specialist, and NOT at the surface.
        const isConsumingOxygen = player.isSwimming && !player.isWaterSpecialist && !player.isAtWaterSurface;

        if (isConsumingOxygen) {
            player.currentOxygen -= config.OXYGEN_CONSUMPTION_RATE * deltaTime;
            if (player.currentOxygen <= 0) {
                player.currentOxygen = 0;
                player.takeDamage(config.OXYGEN_DAMAGE_PER_SECOND * deltaTime);
            }
        } else {
            // Oxygen regenerates when out of water OR at the surface.
            if (player.currentOxygen < player.maxOxygen) {
                player.currentOxygen = Math.min(
                    player.maxOxygen,
                    player.currentOxygen + config.OXYGEN_REGEN_RATE * deltaTime
                );
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/PlayerResourceSystem.js ===


=== FILE: src/game/systems/StatusEffectSystem.js ===
--------------------------------------------------
// ~ src/game/systems/StatusEffectSystem.js
/**
 * Manages the lifecycle of all active status effects in the world.
 * It ticks effects, checks for expiration, and handles their removal.
 */
export class StatusEffectSystem {
    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        for (const entity of world.getEntities()) {
            if (!entity.statusEffects) continue;

            const effectsToDelete = [];
            for (const effect of entity.statusEffects.activeEffects.values()) {
                effect.tick(deltaTime);
                if (effect.isFinished) {
                    effectsToDelete.push(effect);
                }
            }

            for (const effect of effectsToDelete) {
                effect.remove();
                entity.statusEffects.activeEffects.delete(effect.name);
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/StatusEffectSystem.js ===


=== FILE: src/game/systems/TargetingSystem.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { GAME_CONFIG } from '../../shared/config.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';

/**
 * Handles target acquisition for abilities that require a lock-on.
 */
export class TargetingSystem {
    constructor() {
        // --- System Performance ---
        this.updateInterval = 0.1; // Run every 100ms
        this.timer = Math.random() * this.updateInterval; // Stagger updates

        // --- Reusable objects to prevent garbage collection churn ---
        this._targetRayOrigin = new THREE.Vector3();
        this._targetRayDirection = new THREE.Vector3();
        this._enemyPos = new THREE.Vector3();
        this._toEnemyVector = new THREE.Vector3();
        this._losRayFrom = new CANNON.Vec3();
        this._losRayTo = new CANNON.Vec3();
        this._raycastResult = new CANNON.RaycastResult();
    }

    /**
     * Updates the player's locked-on target based on the current view and selected ability.
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        const player = world.player;
        if (!player || player.isDead) return;

        // Throttle the main logic to run at a fixed interval
        this.timer += deltaTime;
        if (this.timer < this.updateInterval) {
            return;
        }
        this.timer = 0;

        const currentAbility = player.abilities.abilities[player.abilities.selectedAbilityIndex];
        if (!currentAbility?.requiresLockOn) {
            player.lockedTarget = null;
            return;
        }

        player.camera.getWorldPosition(this._targetRayOrigin);
        player.camera.getWorldDirection(this._targetRayDirection);

        let bestEnemy = null;
        let minScore = Infinity;

        for (const enemy of world.getEnemies()) {
            if (enemy.isDead) continue;
            
            this._enemyPos.copy(enemy.physics.body.position);
            this._enemyPos.y += 1.0; // Aim for the center of the enemy's body

            const distanceToEnemy = this._targetRayOrigin.distanceTo(this._enemyPos);
            if (distanceToEnemy > GAME_CONFIG.TARGETING.MAX_RANGE) continue;
            
            this._toEnemyVector.subVectors(this._enemyPos, this._targetRayOrigin).normalize();
            
            const dotProduct = this._toEnemyVector.dot(this._targetRayDirection);
            if (dotProduct < 0) continue; // Enemy is behind the player

            const angle = Math.acos(Math.min(1, Math.max(-1, dotProduct)));

            if (angle < GAME_CONFIG.TARGETING.MAX_ANGLE_RAD) {
                // Perform line-of-sight check
                this._losRayFrom.copy(this._targetRayOrigin);
                this._losRayTo.copy(this._enemyPos);
                
                this._raycastResult.reset();
                world.physics.world.raycastClosest(
                    this._losRayFrom, this._losRayTo, 
                    { collisionFilterMask: COLLISION_GROUPS.WORLD, skipBackfaces: true }, 
                    this._raycastResult
                );

                if (!this._raycastResult.hasHit) {
                    // Score prioritizes being closer to the center of the screen, then distance.
                    const score = angle + (distanceToEnemy / GAME_CONFIG.TARGETING.MAX_RANGE);
                    if (score < minScore) {
                        minScore = score;
                        bestEnemy = enemy;
                    }
                }
            }
        }
        player.lockedTarget = bestEnemy;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/TargetingSystem.js ===


=== FILE: src/game/systems/TriggerSystem.js ===
--------------------------------------------------
/**
 * A centralized system for handling logic for all trigger volumes.
 * It is event-driven and listens for collision events on trigger entities.
 */
export class TriggerSystem {
    constructor(world) {
        this.world = world;
        this._boundOnEntityAdded = this.onEntityAdded.bind(this);
        this.world.on('entityAdded', this._boundOnEntityAdded);
        this._initAllTriggers();
    }

    /**
     * Iterates through existing triggers in the world and initializes them.
     * This is useful for when the system is created after entities already exist.
     */
    _initAllTriggers() {
        const triggers = [...this.world.getTriggers(), ...this.world.getDeathTriggers()];
        triggers.forEach(trigger => this._initTrigger(trigger));
    }

    /**
     * Initializes a single trigger by attaching a collision handler.
     * @param {object} trigger - The trigger entity.
     */
    _initTrigger(trigger) {
        // Ensure we don't add the same listener multiple times.
        if (trigger.body && !trigger.body.hasEventListener('collide', trigger._collisionHandler)) {
            trigger._collisionHandler = (event) => this.onTriggerCollide(trigger, event);
            trigger.body.addEventListener('collide', trigger._collisionHandler);
        }
    }

    /**
     * Handler for when a new entity is added to the world.
     * If it's a trigger, initialize it.
     * @param {object} data - The event data containing the added entity.
     * @param {object} data.entity - The entity that was added.
     */
    onEntityAdded({ entity }) {
        if (entity.type === 'Trigger' || entity.type === 'DeathTrigger') {
            this._initTrigger(entity);
        }
    }

    /**
     * The core collision logic that runs when a trigger's body reports a collision.
     * @param {object} triggerEntity - The trigger volume itself.
     * @param {object} event - The CANNON.js collision event.
     */
    onTriggerCollide(triggerEntity, event) {
        const otherBody = event.body;
        const targetEntity = otherBody?.userData?.entity;

        if (!targetEntity) return;

        // Apply logic based on the type of the trigger volume.
        if (triggerEntity.type === 'DeathTrigger') {
            if (typeof targetEntity.takeDamage === 'function') {
                targetEntity.takeDamage(99999); // Apply lethal damage
            }
        } else if (triggerEntity.type === 'Trigger') {
            // Tutorial message triggers should only affect the player and only fire once.
            if (targetEntity.type === 'player' && !triggerEntity.hasFired) {
                this.world.emit('tutorialTriggerActivated', {
                    message: triggerEntity.message,
                    duration: triggerEntity.duration,
                });
                triggerEntity.hasFired = true;
            }
        }
    }

    /**
     * Cleans up all event listeners when the world is disposed.
     */
    dispose() {
        this.world.off('entityAdded', this._boundOnEntityAdded);
        const triggers = [...this.world.getTriggers(), ...this.world.getDeathTriggers()];
        triggers.forEach(trigger => {
            if (trigger.body && trigger._collisionHandler) {
                trigger.body.removeEventListener('collide', trigger._collisionHandler);
                delete trigger._collisionHandler;
            }
        });
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/TriggerSystem.js ===


=== FILE: src/game/systems/WaterSystem.js ===
--------------------------------------------------
import * as CANNON from 'cannon-es';
import { GAME_CONFIG } from '../../shared/config.js';

export class WaterSystem {
    constructor() {
        // Reusable vectors to avoid allocations in the update loop
        this._localEntityPos = new CANNON.Vec3();
        this.buoyantForce = new CANNON.Vec3();
    }

    update(world, deltaTime) {
        const waterVolumes = world.getWaterVolumes();
        const entitiesToCheck = [world.player, ...world.getNPCs()];

        // Part 1: Detect which entities are in water and handle entry/exit effects
        if (waterVolumes.length === 0) {
            // Optimization: if no water, quickly reset any entities that might have been in water
            for (const entity of entitiesToCheck) {
                if (entity?.isInWater) {
                    this.removeWaterEffects(entity);
                }
            }
            return;
        }

        for (const entity of entitiesToCheck) {
            if (!entity || entity.isDead || !entity.physics?.body) continue;

            const wasInWater = entity.isInWater || false;
            let isConsideredInWater = false;
            let currentVolumeForFrame = null;
            
            // This logic is only for spherical entities like Player and NPC
            if (entity.physics.body.shapes[0] instanceof CANNON.Sphere) {
                // Broad phase check for potential water interaction
                for (const volume of waterVolumes) {
                    if (entity.physics.body.aabb.overlaps(volume.body.aabb)) {
                        // Precise check: sphere-box intersection test.
                        // 1. Transform sphere center to the box's local frame
                        volume.body.pointToLocalFrame(entity.physics.body.position, this._localEntityPos);
        
                        // 2. Find the closest point on the box AABB (in local coords) to the sphere's center
                        const halfSize = volume.body.shapes[0].halfExtents;
                        const closestPointInBox = new CANNON.Vec3(
                            Math.max(-halfSize.x, Math.min(this._localEntityPos.x, halfSize.x)),
                            Math.max(-halfSize.y, Math.min(this._localEntityPos.y, halfSize.y)),
                            Math.max(-halfSize.z, Math.min(this._localEntityPos.z, halfSize.z))
                        );
        
                        // 3. Check distance squared between sphere center and this closest point
                        const distanceSq = closestPointInBox.distanceSquared(this._localEntityPos);
                        const entityRadius = entity.physics.body.shapes[0].radius;
        
                        if (distanceSq < entityRadius * entityRadius) {
                            isConsideredInWater = true;
                            currentVolumeForFrame = volume;
                            break; // Found a volume, no need to check others
                        }
                    }
                }
            }
            
            if (isConsideredInWater && !wasInWater) {
                this.applyWaterEffects(entity, currentVolumeForFrame);
            } else if (!isConsideredInWater && wasInWater) {
                this.removeWaterEffects(entity);
            }
            
            if (entity.type === 'player') {
                entity.currentWaterVolume = isConsideredInWater ? currentVolumeForFrame : null;
            }
        }

        // Part 2: Apply persistent water physics (buoyancy) to all submerged entities
        for (const entity of entitiesToCheck) {
            if (entity?.isInWater && entity.physics?.body) {
                this.applyBuoyancy(entity, world.physics.world.gravity);
            }
        }
    }
    
    applyBuoyancy(entity, gravity) {
        const body = entity.physics.body;
        // Don't apply buoyancy to water specialists walking on water, as they aren't "submerged".
        if (entity.type === 'player' && entity.isWaterSpecialist) {
            return;
        }
        
        // Force to counteract gravity for neutral buoyancy
        const buoyancyMagnitude = Math.abs(gravity.y) * body.mass;
        
        // Apply some damping to vertical velocity to simulate water resistance
        const verticalDamping = 0.95;
        body.velocity.y *= verticalDamping;
        
        this.buoyantForce.set(0, buoyancyMagnitude, 0);
        body.applyForce(this.buoyantForce, body.position);
    }

    applyWaterEffects(entity, volume) {
        const body = entity.physics.body;
        entity.isInWater = true;
        entity.currentWaterVolume = volume;

        if (entity.type === 'player') {
            const surfaceY = volume.body.position.y + volume.definition.size[1] / 2;

            if (entity.isWaterSpecialist) {
                entity.isSwimming = false;
                if (body.position.y <= surfaceY + 0.5) {
                    body.position.y = surfaceY;
                    body.velocity.y = Math.max(0, body.velocity.y);
                    entity.jumpsRemaining = GAME_CONFIG.PLAYER.MAX_JUMPS;
                }
            } else {
                entity.isSwimming = true;
                body.linearDamping = 0.8;
            }
        } else if (entity.type === 'npc') {
            body.linearDamping = 0.8;
        }
    }

    removeWaterEffects(entity) {
        entity.isInWater = false;
        entity.currentWaterVolume = null;

        if (entity.type === 'player') {
            entity.isSwimming = false;
            entity.isAtWaterSurface = false;
            entity.physics.body.linearDamping = GAME_CONFIG.PLAYER.DEFAULT_DAMPING;
        } else if (entity.type === 'npc') {
            entity.physics.body.linearDamping = 0.1;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/WaterSystem.js ===


=== FILE: src/game/systems/WeaponSystem.js ===
--------------------------------------------------
/**
 * Manages the update logic for weapons, such as cooldowns and animations.
 */
export class WeaponSystem {
    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        for (const entity of world.getEntities()) {
            if (entity.weapon?.update) {
                entity.weapon.update(deltaTime);
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/WeaponSystem.js ===


=== FILE: src/game/weapons/CustomWeapon.js ===
--------------------------------------------------
import * as THREE from 'three';
import { Weapon } from './Weapon.js';

/**
 * A weapon instantiated from dynamic asset data created in the Asset Editor.
 */
export class CustomWeapon extends Weapon {
    constructor(assetData) {
        super(null, {
            name: assetData.assetName,
            damage: 50, // Placeholder
            cooldown: 0.5, // Placeholder
        });

        this.assetData = assetData;
        this.parts = new Map(); // Map<uuid, THREE.Object3D>
        
        this.createMesh();
        this.wielder = null; // Set when equipped
    }

    createMesh() {
        this.mesh = new THREE.Group();
        this.mesh.name = this.assetData.assetName;

        const geometryMap = {
            'Box': (s) => new THREE.BoxGeometry(...s),
            'Cylinder': (s) => new THREE.CylinderGeometry(s[0], s[1], s[2]),
            'Sphere': (s) => new THREE.SphereGeometry(s[0]),
        };

        // First pass: create all objects and map them by UUID
        for (const partData of this.assetData.geometry) {
            const geoFn = geometryMap[partData.type];
            if (!geoFn) continue;

            const material = new THREE.MeshStandardMaterial({
                color: parseInt(partData.material.color, 16) || 0xcccccc,
            });

            // Use scale from definition
            const size = partData.transform.scale || [1, 1, 1];
            const partMesh = new THREE.Mesh(geoFn(size), material);
            
            partMesh.name = partData.uuid; // For debugging
            this.parts.set(partData.uuid, partMesh);
        }

        // Second pass: build the hierarchy
        for (const partData of this.assetData.geometry) {
            const partMesh = this.parts.get(partData.uuid);
            if (!partMesh) continue;

            const { position, rotation } = partData.transform;
            if (position) partMesh.position.fromArray(position);
            if (rotation) partMesh.quaternion.setFromEuler(new THREE.Euler().fromArray(rotation));
            
            if (partData.parent) {
                const parentMesh = this.parts.get(partData.parent);
                parentMesh?.add(partMesh);
            } else {
                this.mesh.add(partMesh); // Add root parts to the main mesh group
            }
        }
    }

    attack() {
        if (!this.canAttack() || !this.wielder) return;
        
        this.triggerCooldown();
        this.wielder.world.emit('animationTriggered', {
            entity: this,
            clipName: 'fire'
        });
        
        // Placeholder attack logic
        console.log(`Custom weapon "${this.name}" fired!`);
    }

    update(deltaTime) {
        super.update(deltaTime);
        // The AnimationSystem will handle transform updates.
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/CustomWeapon.js ===


=== FILE: src/game/weapons/Katana.js ===
--------------------------------------------------
// ~ src/game/weapons/Katana.js
import * as THREE from 'three';
import { Weapon } from './Weapon.js';
import { GAME_CONFIG } from '../../shared/config.js';

export class Katana extends Weapon {
    constructor() {
        super(null, {
            name: 'Katana',
            damage: GAME_CONFIG.KATANA.DAMAGE,
            cooldown: GAME_CONFIG.KATANA.COOLDOWN,
        });

        this.swingRange = GAME_CONFIG.KATANA.RANGE;
        
        // REWORK: State management for animations
        this.state = 'idle'; // idle, swinging, inspecting
        this.animationProgress = 0;
        this.animationDuration = 0;

        // Internal helpers
        this._forward = new THREE.Vector3();
        this._npcPos = new THREE.Vector3();
        
        this._defineKeyframes();
        this.createMesh();
        
        this.mesh.position.copy(this.idlePosition);
        this.mesh.quaternion.copy(this.qIdle);
    }

    _defineKeyframes() {
        // --- Swing Animation ---
        this.swingDuration = 0.45;
        this.hitTiming = 120; // ms
        this.idlePosition = new THREE.Vector3(0.35, -0.35, -0.7);
        this.windUpPosition = new THREE.Vector3(0.5, 0.4, -0.6);
        this.followThroughPosition = new THREE.Vector3(-0.4, -0.5, -0.7);
        const idleRotation = new THREE.Euler(THREE.MathUtils.degToRad(10), THREE.MathUtils.degToRad(-15), THREE.MathUtils.degToRad(5), 'YXZ');
        const windUpRotation = new THREE.Euler(THREE.MathUtils.degToRad(70), THREE.MathUtils.degToRad(30), THREE.MathUtils.degToRad(-20), 'YXZ');
        const followThroughRotation = new THREE.Euler(THREE.MathUtils.degToRad(-45), THREE.MathUtils.degToRad(-40), THREE.MathUtils.degToRad(45), 'YXZ');
        this.qIdle = new THREE.Quaternion().setFromEuler(idleRotation);
        this.qWindUp = new THREE.Quaternion().setFromEuler(windUpRotation);
        this.qFollowThrough = new THREE.Quaternion().setFromEuler(followThroughRotation);

        // --- Inspect Animation ---
        // Player must be out of water to inspect weapon.
        this.inspectDuration = 2.5;
        this.p_inspect_up = new THREE.Vector3(0.1, -0.1, -0.6);
        this.q_inspect_up = new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.5, -0.2, 0.2, 'YXZ'));
        this.p_inspect_flat = this.p_inspect_up.clone();
        this.q_inspect_flat = new THREE.Quaternion().setFromEuler(new THREE.Euler(-1.4, 0.1, -0.2, 'YXZ'));
    }

    createMesh() {
        this.mesh = new THREE.Group();
        const bladeMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.9, roughness: 0.3 });
        const blade = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.7, 0.01), bladeMat);
        blade.position.y = 0.7 / 2 + 0.02 / 2;
        blade.castShadow = true;
        
        const guardMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6, roughness: 0.5 });
        const guard = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.02, 0.15), guardMat);
        guard.castShadow = true;
        
        const hiltMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
        const hilt = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.02, 0.25, 8), hiltMat);
        hilt.position.y = -0.25 / 2 - 0.02 / 2;
        hilt.castShadow = true;
        
        this.mesh.add(blade, guard, hilt);
    }

    attack() {
        if (!this.canAttack() || this.state !== 'idle') return false;
        
        this.state = 'swinging';
        this.animationDuration = this.swingDuration;
        this.animationProgress = 0;
        this.triggerCooldown();
        setTimeout(() => { if (this.state === 'swinging') this.detectHit(); }, this.hitTiming);
        return true;
    }

    inspect() {
        if (this.state !== 'idle' || this.wielder.isInWater) return;
        this.state = 'inspecting';
        this.animationDuration = this.inspectDuration;
        this.animationProgress = 0;
    }

    detectHit() {
        if (!this.wielder) return;

        this.wielder.camera.getWorldDirection(this._forward);
        const playerPos = this.wielder.physics.body.position;

        for (const npc of this.wielder.world.getEnemies()) {
            if (npc.isDead || !npc.physics.body) continue;

            this._npcPos.copy(npc.physics.body.position);
            const distance = playerPos.distanceTo(this._npcPos);

            if (distance < this.swingRange + npc.physics.body.shapes[0].radius) {
                const toNPC = this._npcPos.clone().sub(playerPos).normalize();
                if (this._forward.dot(toNPC) > 0.64) {
                    let damage = this.damage;
                    if (this.wielder.statusEffects.has('stonePlating')) {
                        const effect = this.wielder.statusEffects.get('stonePlating');
                        damage *= (1 + effect.properties.meleeDamageBoost);
                    }
                    if (this.wielder.isSlamming) {
                        damage *= GAME_CONFIG.KATANA.SLAM_DAMAGE_MULTIPLIER;
                    }
                    npc.takeDamage(damage);
                }
            }
        }
    }

    update(deltaTime) {
        super.update(deltaTime);
        if (this.state === 'idle') {
            this.mesh.position.lerp(this.idlePosition, 10 * deltaTime);
            this.mesh.quaternion.slerp(this.qIdle, 10 * deltaTime);
            return;
        }

        this.animationProgress += deltaTime;
        const p = Math.min(this.animationProgress / this.animationDuration, 1.0);

        switch(this.state) {
            case 'swinging':
                this.updateSwingAnimation(p);
                break;
            case 'inspecting':
                this.updateInspectAnimation(p);
                break;
        }
        
        if (p >= 1.0) {
            this.state = 'idle';
        }
    }

    updateSwingAnimation(p) {
        const windUpPhaseEnd = 0.20;
        const slashPhaseEnd = 0.60;

        let currentPosition = new THREE.Vector3();
        let currentQuaternion = new THREE.Quaternion();
        let phaseProgress, easedProgress;

        if (p < windUpPhaseEnd) {
            phaseProgress = p / windUpPhaseEnd;
            easedProgress = 1 - Math.pow(1 - phaseProgress, 3);
            currentPosition.lerpVectors(this.idlePosition, this.windUpPosition, easedProgress);
            currentQuaternion.slerpQuaternions(this.qIdle, this.qWindUp, easedProgress);
        } else if (p < slashPhaseEnd) {
            phaseProgress = (p - windUpPhaseEnd) / (slashPhaseEnd - windUpPhaseEnd);
            easedProgress = 1 - Math.pow(1 - phaseProgress, 4);
            currentPosition.lerpVectors(this.windUpPosition, this.followThroughPosition, easedProgress);
            currentQuaternion.slerpQuaternions(this.qWindUp, this.qFollowThrough, easedProgress);
        } else {
            phaseProgress = (p - slashPhaseEnd) / (1.0 - slashPhaseEnd);
            easedProgress = phaseProgress < 0.5 ? 2 * p * p : 1 - Math.pow(-2 * p + 2, 2) / 2;
            currentPosition.lerpVectors(this.followThroughPosition, this.idlePosition, easedProgress);
            currentQuaternion.slerpQuaternions(this.qFollowThrough, this.qIdle, easedProgress);
        }

        this.mesh.position.copy(currentPosition);
        this.mesh.quaternion.copy(currentQuaternion);
    }
    
    updateInspectAnimation(p) {
        const p1_end = 0.15, p2_end = 0.8, p3_end = 1.0;
        let phaseProgress, easedProgress;
        let currentPosition = new THREE.Vector3();
        let currentQuaternion = new THREE.Quaternion();
    
        if (p < p1_end) {
            phaseProgress = p / p1_end;
            easedProgress = 1 - Math.pow(1 - phaseProgress, 3);
            currentPosition.lerpVectors(this.idlePosition, this.p_inspect_up, easedProgress);
            currentQuaternion.slerpQuaternions(this.qIdle, this.q_inspect_up, easedProgress);
        } else if (p < p2_end) {
            phaseProgress = (p - p1_end) / (p2_end - p1_end);
            easedProgress = phaseProgress < 0.5 ? 2 * 4 * phaseProgress**3 : 1 - Math.pow(-2 * phaseProgress + 2, 3) / 2; // Smoother in and out
            currentPosition.lerpVectors(this.p_inspect_up, this.p_inspect_flat, easedProgress);
            currentQuaternion.slerpQuaternions(this.q_inspect_up, this.q_inspect_flat, easedProgress);
        } else {
            phaseProgress = (p - p2_end) / (p3_end - p2_end);
            easedProgress = 1 - Math.pow(1 - phaseProgress, 3);
            currentPosition.lerpVectors(this.p_inspect_flat, this.idlePosition, easedProgress);
            currentQuaternion.slerpQuaternions(this.q_inspect_flat, this.qIdle, easedProgress);
        }
    
        this.mesh.position.copy(currentPosition);
        this.mesh.quaternion.copy(currentQuaternion);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/Katana.js ===


=== FILE: src/game/weapons/Revolver.js ===
--------------------------------------------------
// ~ src/game/weapons/Revolver.js
import * as THREE from 'three';
import { Weapon } from './Weapon.js';
import { GAME_CONFIG } from '../../shared/config.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';

export class Revolver extends Weapon {
    constructor() {
        super(null, {
            name: 'Revolver',
            damage: GAME_CONFIG.REVOLVER.DAMAGE,
            cooldown: GAME_CONFIG.REVOLVER.COOLDOWN,
        });

        this.range = 200;
        this.magazineSize = GAME_CONFIG.REVOLVER.MAGAZINE_SIZE;
        this.magazineAmmo = this.magazineSize;
        this.reserveAmmo = GAME_CONFIG.REVOLVER.RESERVE_AMMO;

        this.state = 'idle'; // idle, firing, reloading, inspecting
        this.animationProgress = 0;
        this.animationDuration = 0;

        this._defineKeyframes();
        this.createMesh();
        
        this.mesh.position.copy(this.p_idle);
        this.mesh.quaternion.copy(this.q_idle);
    }

    _defineKeyframes() {
        // --- Base Positions & Rotations ---
        // Weapon is offset to the right but rotated (yaw) to point towards the center crosshair.
        this.p_idle = new THREE.Vector3(0.3, -0.4, -0.7);
        this.q_idle = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, -0.3, 0));
        
        // --- ADS (Aim Down Sights) - Future Use ---
        // this.p_ads = new THREE.Vector3(0, -0.3, -0.5);
        // this.q_ads = new THREE.Quaternion();

        // --- Reloading Keyframes ---
        this.p_reload_start = new THREE.Vector3(0.3, -0.5, -0.7);
        this.q_reload_start = new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.8, -0.4, 0.2));
        
        // --- Inspecting Keyframes ---
        // Player must be out of water to inspect weapon.
        this.inspectDuration = 3.5;
        this.p_inspect_center = new THREE.Vector3(0.1, -0.35, -0.6);
        this.q_inspect_start = new THREE.Quaternion().setFromEuler(new THREE.Euler(0.2, -0.2, 0.5));
        this.q_inspect_roll = new THREE.Quaternion().setFromEuler(new THREE.Euler(0.5, -0.2, -1.5));
    }

    createMesh() {
        this.mesh = new THREE.Group();
        const darkMetal = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.9, roughness: 0.4 });
        const gripRubber = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.7 });

        // --- Frame ---
        const frameGeo = new THREE.BoxGeometry(0.045, 0.1, 0.14);
        const frame = new THREE.Mesh(frameGeo, darkMetal);
        frame.position.set(0, -0.01, -0.05);

        // --- Barrel Assembly ---
        const barrelAssembly = new THREE.Group();
        barrelAssembly.position.set(0, 0.045, -0.12);
        const shroud = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.055, 0.22), darkMetal);
        shroud.position.z = -0.09;
        const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.014, 0.014, 0.2, 8), darkMetal);
        barrel.rotation.x = Math.PI / 2;
        barrel.position.z = -0.08;
        barrelAssembly.add(shroud, barrel);

        // --- Top Rail & Sights ---
        const topRail = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.015, 0.18), darkMetal);
        topRail.position.set(0, 0.08, -0.11);
        const rearSight = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 0.01), darkMetal);
        rearSight.position.set(0, 0.05, 0.02);

        // --- Grip ---
        const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.025, 0.16, 8), gripRubber);
        grip.position.set(0, -0.1, 0.01);
        grip.rotation.x = -0.2;
        grip.scale.x = 1.3;

        // --- Cylinder & Crane (for reload animation) ---
        this.crane = new THREE.Group();
        this.crane.position.set(-0.0225, -0.01, -0.05); // Pivot point on the frame
        this.cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.07, 6), darkMetal);
        this.cylinder.rotation.x = Math.PI / 2;
        this.crane.add(this.cylinder);

        // --- Hammer ---
        this.hammer = new THREE.Mesh(new THREE.BoxGeometry(0.015, 0.04, 0.02), darkMetal);
        this.hammer.position.set(0, 0.05, 0.02);
        this.hammer.geometry.translate(0, -0.02, 0); // Set pivot to bottom

        this.mesh.add(frame, barrelAssembly, topRail, rearSight, grip, this.crane, this.hammer);
        this.mesh.scale.setScalar(1.1);
        return this.mesh;
    }

    attack() {
        if (this.state !== 'idle' || !this.canAttack()) return false;
        
        if (this.magazineAmmo <= 0) {
            this.reload();
            return false;
        }

        this.state = 'firing';
        this.animationDuration = this.cooldown * 0.9;
        this.animationProgress = 0;
        this.magazineAmmo--;
        this.triggerCooldown();

        const raycaster = new THREE.Raycaster();
        const camera = this.wielder.camera;
        raycaster.setFromCamera({ x: 0, y: 0 }, camera);
        
        const enemyMeshes = this.wielder.world.getEnemies().map(e => e.mesh).filter(Boolean);
        const worldMeshes = this.wielder.world.getLevelObjects().map(e => e.mesh).filter(Boolean);
        const entitiesToTest = [...enemyMeshes, ...worldMeshes];

        const intersects = raycaster.intersectObjects(entitiesToTest, true);

        let hitPoint = null;
        if (intersects.length > 0) {
            const hit = intersects[0];
            if (hit.distance < this.range) {
                hitPoint = hit.point; // Always set hit point
                const gameEntityLink = hit.object.userData.gameEntity;
                if (gameEntityLink?.type === 'NPC' && gameEntityLink.entity.team === 'enemy') {
                    gameEntityLink.entity.takeDamage(this.damage);
                }
            }
        }
        
        if (!hitPoint) {
            hitPoint = raycaster.ray.at(this.range, new THREE.Vector3());
        }

        this.wielder.world.emit('weaponFired', { weapon: this, hitPoint });

        if (this.magazineAmmo === 0) {
            setTimeout(() => this.reload(), 500);
        }

        return true;
    }

    reload() {
        if (this.state !== 'idle' || this.magazineAmmo === this.magazineSize || this.reserveAmmo <= 0) return;

        this.state = 'reloading';
        this.animationDuration = 2.8;
        this.animationProgress = 0;
    }

    inspect() {
        if (this.state !== 'idle' || this.wielder.isInWater) return;
        this.state = 'inspecting';
        this.animationDuration = this.inspectDuration;
        this.animationProgress = 0;
    }

    update(deltaTime) {
        super.update(deltaTime);
        if (this.state === 'idle') {
            this.mesh.position.lerp(this.p_idle, 10 * deltaTime);
            this.mesh.quaternion.slerp(this.q_idle, 10 * deltaTime);
            this.crane.rotation.y = THREE.MathUtils.lerp(this.crane.rotation.y, 0, 15 * deltaTime);
            this.hammer.rotation.z = THREE.MathUtils.lerp(this.hammer.rotation.z, 0, 15 * deltaTime);
            return;
        }

        this.animationProgress += deltaTime;
        const p = Math.min(this.animationProgress / this.animationDuration, 1.0);

        switch(this.state) {
            case 'firing': this.updateFireAnimation(p, deltaTime); break;
            case 'reloading': this.updateReloadAnimation(p, deltaTime); break;
            case 'inspecting': this.updateInspectAnimation(p); break;
        }
        
        if (p >= 1.0) {
            if (this.state === 'reloading') {
                const ammoNeeded = this.magazineSize - this.magazineAmmo;
                const ammoToReload = Math.min(ammoNeeded, this.reserveAmmo);
                this.magazineAmmo += ammoToReload;
                this.reserveAmmo -= ammoToReload;
            }
            this.state = 'idle';
        }
    }

    updateFireAnimation(p, deltaTime) {
        const kickProgress = Math.sin(p * Math.PI); // A value from 0 -> 1 -> 0

        // Rotational flip
        const kickRotation = new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(1, 0, 0),
            kickProgress * -0.5 // flip amount
        );
        // Apply the kick rotation relative to the base idle rotation
        this.mesh.quaternion.copy(this.q_idle).multiply(kickRotation);
    
        // Positional kickback
        const kickPosition = this.p_idle.clone();
        kickPosition.z += kickProgress * 0.2; // kickback amount
        this.mesh.position.copy(kickPosition);

        // Hammer animation (this is safe as it's a child object's local rotation)
        const hammerCockBack = -Math.PI / 4;
        if (p < 0.1) this.hammer.rotation.z = THREE.MathUtils.lerp(0, hammerCockBack, p / 0.1);
        else this.hammer.rotation.z = THREE.MathUtils.lerp(hammerCockBack, 0, (p - 0.1) / 0.9);
        
        // Cylinder rotation
        this.cylinder.rotation.y -= deltaTime * 20 * (1 - p);
    }

    updateReloadAnimation(p, deltaTime) {
        // Phase 1: Bring to center and start opening (0.0 -> 0.2)
        const p1 = Math.min(1, p / 0.2);
        this.mesh.position.lerpVectors(this.p_idle, this.p_reload_start, p1);
        this.mesh.quaternion.slerpQuaternions(this.q_idle, this.q_reload_start, p1);

        // Phase 2: Swing cylinder out (0.1 -> 0.4)
        const p2 = Math.min(1, Math.max(0, (p - 0.1) / 0.3));
        const swingOutAngle = -Math.PI / 2.5;
        this.crane.rotation.y = THREE.MathUtils.lerp(0, swingOutAngle, p2);

        // Phase 3: Eject shells (0.4 -> 0.6) - a quick spin
        if (p > 0.4 && p < 0.6) {
            this.cylinder.rotation.y -= deltaTime * 50;
        }

        // Phase 4: Swing cylinder in (0.7 -> 0.9)
        const p4 = Math.min(1, Math.max(0, (p - 0.7) / 0.2));
        this.crane.rotation.y = THREE.MathUtils.lerp(swingOutAngle, 0, p4);

        // Phase 5: Return to idle (0.8 -> 1.0)
        const p5 = Math.min(1, Math.max(0, (p - 0.8) / 0.2));
        this.mesh.position.lerpVectors(this.p_reload_start, this.p_idle, p5);
        this.mesh.quaternion.slerpQuaternions(this.q_reload_start, this.q_idle, p5);
    }
    
    updateInspectAnimation(p) {
        const p1_end = 0.2, p2_end = 0.7, p3_end = 1.0;
        
        if (p < p1_end) { // Move to center
            const progress = p / p1_end;
            this.mesh.position.lerpVectors(this.p_idle, this.p_inspect_center, progress);
            this.mesh.quaternion.slerpQuaternions(this.q_idle, this.q_inspect_start, progress);
        } else if (p < p2_end) { // Roll
            const progress = (p - p1_end) / (p2_end - p1_end);
            this.mesh.quaternion.slerpQuaternions(this.q_inspect_start, this.q_inspect_roll, progress);
            this.cylinder.rotation.y += 0.05 * (1.0 - progress);
        } else { // Return to idle
            const progress = (p - p2_end) / (p3_end - p2_end);
            this.mesh.position.lerpVectors(this.p_inspect_center, this.p_idle, progress);
            this.mesh.quaternion.slerpQuaternions(this.q_inspect_roll, this.q_idle, progress);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/Revolver.js ===


=== FILE: src/game/weapons/Sai.js ===
--------------------------------------------------
// ~ src/game/weapons/Sai.js
import * as THREE from 'three';
import { Weapon } from './Weapon.js';
import { GAME_CONFIG } from '../../shared/config.js';
import { BleedingEffect } from '../effects/BleedingEffect.js'; // Import BleedingEffect

export class Sai extends Weapon {
    constructor() {
        super(null, {
            name: 'Twin Sai',
            damage: GAME_CONFIG.SAI.DAMAGE,
            cooldown: GAME_CONFIG.SAI.COOLDOWN,
        });

        this.swingRange = GAME_CONFIG.SAI.RANGE;
        
        this.state = 'idle'; // idle, swinging, inspecting
        this.animationProgress = 0;
        this.animationDuration = 0;

        // Internal helpers
        this._forward = new THREE.Vector3();
        this._npcPos = new THREE.Vector3();
        
        this._defineKeyframes();
        this.createMesh(); // Creates this.mesh, this.leftSai, this.rightSai
        
        this.mesh.position.copy(this.idlePosition);
        this.mesh.quaternion.copy(this.qIdle);
    }

    _defineKeyframes() {
        // Sai Group Base position and rotation
        // Adjusted to be further forward and slightly more centered.
        this.idlePosition = new THREE.Vector3(0.0, -0.4, -0.8);
        this.qIdle = new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.05, 0, 0)); // Slight downward tilt

        // Individual Sai offsets within the group (these will be animated)
        // More spaced apart horizontally and slightly forward.
        this.leftSaiIdlePos = new THREE.Vector3(-0.35, -0.05, 0.05);
        this.rightSaiIdlePos = new THREE.Vector3(0.35, -0.05, 0.05);

        // --- Swing Animation ---
        this.swingDuration = 0.4;
        this.hitTiming = 100; // ms (when hit detection occurs)

        // Attack keyframes (for individual Sais, relative to group)
        // Wind-up: Sais draw back and turn slightly.
        this.leftSaiWindUpRot = new THREE.Quaternion().setFromEuler(new THREE.Euler(0.4, 0.4, 0.1));
        this.rightSaiWindUpRot = new THREE.Quaternion().setFromEuler(new THREE.Euler(0.4, -0.4, -0.1));

        // Impact: Sais thrust forward, rotating to meet the target.
        this.leftSaiImpactRot = new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.1, -0.2, 0.0)); // Less Z rotation, more focused
        this.rightSaiImpactRot = new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.1, 0.2, 0.0)); // Less Z rotation, more focused

        // --- Inspect Animation ---
        this.inspectDuration = 3.0;
        this.inspectUpPos = new THREE.Vector3(0, -0.2, -0.6);
        this.qInspectUp = new THREE.Quaternion().setFromEuler(new THREE.Euler(0.2, 0, 0));

        this.leftSaiInspectRot = new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.PI * 0.5, 0, 0));
        this.rightSaiInspectRot = new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.PI * 0.5, 0, 0));
    }

    createMesh() {
        this.mesh = new THREE.Group(); // Parent group for both Sais

        const metalMat = new THREE.MeshStandardMaterial({ color: 0x999999, metalness: 0.9, roughness: 0.2 });
        const gripMat = new THREE.MeshStandardMaterial({ color: 0xAA0000, roughness: 0.9 }); // Red fabric look

        const createSingleSai = () => {
            const saiGroup = new THREE.Group();
            
            // Main Blade (longer and thinner box, positioned with its base at 0,0,0)
            const bladeGeo = new THREE.BoxGeometry(0.015, 0.4, 0.015);
            const blade = new THREE.Mesh(bladeGeo, metalMat);
            blade.position.y = 0.2; // Half its height to sit on the crossguard

            // Yoku (Crossguard) - central block
            const guardBaseGeo = new THREE.BoxGeometry(0.06, 0.02, 0.02); // Width, height, depth
            const guardBase = new THREE.Mesh(guardBaseGeo, metalMat);
            guardBase.position.y = 0; // At the junction of blade and hilt

            // Prongs (Yoku) - more realistic curved shape
            const prongRadius = 0.01;
            const prongCurvature = 0.05; // controls how much it curves outward
            const prongLength = 0.12;

            // Right Prong
            const rightProngGroup = new THREE.Group();
            const rProngMain = new THREE.Mesh(
                new THREE.CylinderGeometry(prongRadius, prongRadius, prongLength, 8),
                metalMat
            );
            rProngMain.position.set(prongLength / 2, 0, 0);
            rProngMain.rotation.z = Math.PI / 2;
            rightProngGroup.add(rProngMain);

            const rProngTip = new THREE.Mesh(
                new THREE.CylinderGeometry(prongRadius, prongRadius, prongLength * 0.5, 8),
                metalMat
            );
            rProngTip.position.set(prongLength * 0.8, prongCurvature, 0); // Position relative to main prong
            rProngTip.rotation.z = Math.PI / 2;
            rProngTip.rotation.y = Math.PI / 4; // Angle it slightly
            rightProngGroup.add(rProngTip);

            rightProngGroup.position.set(guardBase.geometry.parameters.width / 2, 0.01, 0); // Attach to right side of guardBase
            saiGroup.add(rightProngGroup);

            // Left Prong (mirrored)
            const leftProngGroup = new THREE.Group();
            const lProngMain = new THREE.Mesh(
                new THREE.CylinderGeometry(prongRadius, prongRadius, prongLength, 8),
                metalMat
            );
            lProngMain.position.set(-prongLength / 2, 0, 0);
            lProngMain.rotation.z = Math.PI / 2;
            leftProngGroup.add(lProngMain);

            const lProngTip = new THREE.Mesh(
                new THREE.CylinderGeometry(prongRadius, prongRadius, prongLength * 0.5, 8),
                metalMat
            );
            lProngTip.position.set(-prongLength * 0.8, prongCurvature, 0);
            lProngTip.rotation.z = Math.PI / 2;
            lProngTip.rotation.y = -Math.PI / 4; // Angle it slightly
            leftProngGroup.add(lProngTip);

            leftProngGroup.position.set(-guardBase.geometry.parameters.width / 2, 0.01, 0); // Attach to left side of guardBase
            saiGroup.add(leftProngGroup);
            
            // Hilt (wrapped handle)
            const hiltGeo = new THREE.CylinderGeometry(0.018, 0.018, 0.15, 8);
            const hilt = new THREE.Mesh(hiltGeo, gripMat);
            hilt.position.y = -0.075; // Half of its height

            // Pommel (metal cap at the end of the hilt)
            const pommelGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.01, 8);
            const pommel = new THREE.Mesh(pommelGeo, metalMat);
            pommel.position.y = -0.15;

            saiGroup.add(blade, guardBase, hilt, pommel);
            saiGroup.scale.setScalar(1.0); 
            saiGroup.castShadow = true;
            return saiGroup;
        };

        this.leftSai = createSingleSai();
        this.rightSai = createSingleSai();

        // Initial positions within the parent group
        this.leftSai.position.copy(this.leftSaiIdlePos);
        this.rightSai.position.copy(this.rightSaiIdlePos);

        this.mesh.add(this.leftSai, this.rightSai);
    }

    attack() {
        if (!this.canAttack() || this.state !== 'idle') return false;
        
        this.state = 'swinging';
        this.animationDuration = this.swingDuration;
        this.animationProgress = 0;
        this.triggerCooldown();
        setTimeout(() => { if (this.state === 'swinging') this.detectHit(); }, this.hitTiming);
        return true;
    }

    inspect() {
        // Only allow inspect from idle state and if not in water
        if (this.state !== 'idle' || this.wielder.isInWater) return;
        this.state = 'inspecting';
        this.animationDuration = this.inspectDuration;
        this.animationProgress = 0;
    }

    detectHit() {
        if (!this.wielder) return;

        this.wielder.camera.getWorldDirection(this._forward);
        const playerPos = this.wielder.physics.body.position;

        for (const npc of this.wielder.world.getEnemies()) {
            if (npc.isDead || !npc.physics.body) continue;

            this._npcPos.copy(npc.physics.body.position);
            const distance = playerPos.distanceTo(this._npcPos);

            if (distance < this.swingRange + npc.physics.body.shapes[0].radius) {
                const toNPC = this._npcPos.clone().sub(playerPos).normalize();
                if (this._forward.dot(toNPC) > 0.64) { // Roughly in a 50-degree cone in front
                    let damage = this.damage;
                    if (this.wielder.statusEffects.has('stonePlating')) {
                        const effect = this.wielder.statusEffects.get('stonePlating');
                        damage *= (1 + effect.properties.meleeDamageBoost);
                    }
                    if (this.wielder.isSlamming) {
                        damage *= GAME_CONFIG.SAI.SLAM_DAMAGE_MULTIPLIER;
                    }
                    npc.takeDamage(damage);

                    // Apply bleeding effect if enemy HP is low
                    if (npc.health.currentHealth / npc.health.maxHealth < GAME_CONFIG.BLEEDING.HP_THRESHOLD_PERCENT) {
                        // Only add if not already bleeding to prevent stacking/refreshing
                        if (!npc.statusEffects.has('bleeding')) {
                            const bleedingEffect = new BleedingEffect(npc);
                            npc.statusEffects.addEffect(bleedingEffect);
                        }
                    }
                }
            }
        }
    }

    update(deltaTime) {
        super.update(deltaTime); // Update cooldown timer

        if (this.state === 'idle') {
            // Lerp group to idle position
            this.mesh.position.lerp(this.idlePosition, 10 * deltaTime);
            this.mesh.quaternion.slerp(this.qIdle, 10 * deltaTime);

            // Also lerp individual sais back to their idle positions/rotations within the group
            this.leftSai.position.lerp(this.leftSaiIdlePos, 10 * deltaTime);
            this.rightSai.position.lerp(this.rightSaiIdlePos, 10 * deltaTime);
            this.leftSai.quaternion.slerp(new THREE.Quaternion(), 10 * deltaTime);
            this.rightSai.quaternion.slerp(new THREE.Quaternion(), 10 * deltaTime);
            return;
        }

        this.animationProgress += deltaTime;
        const p = Math.min(this.animationProgress / this.animationDuration, 1.0); // Normalized progress

        switch(this.state) {
            case 'swinging':
                this.updateSwingAnimation(p);
                break;
            case 'inspecting':
                this.updateInspectAnimation(p);
                break;
        }
        
        if (p >= 1.0) {
            this.state = 'idle';
        }
    }

    updateSwingAnimation(p) {
        const windUpPhaseEnd = 0.25;
        const impactPhaseEnd = 0.7; // Duration of the actual thrust

        // Group movement (slight overall motion)
        this.mesh.position.y = this.idlePosition.y + Math.sin(p * Math.PI) * 0.05; // Up and down slightly
        this.mesh.position.z = this.idlePosition.z + Math.sin(p * Math.PI) * 0.1; // Forward and back slightly

        // Individual Sai animations
        let leftSaiPos = new THREE.Vector3(), rightSaiPos = new THREE.Vector3();
        let leftSaiRot = new THREE.Quaternion(), rightSaiRot = new THREE.Quaternion();
        let easedProgress;

        if (p < windUpPhaseEnd) {
            // Wind-up phase: pull back and turn
            easedProgress = 1 - Math.pow(1 - p / windUpPhaseEnd, 3);
            leftSaiPos.lerpVectors(this.leftSaiIdlePos, new THREE.Vector3(-0.4, 0.1, 0.1), easedProgress);
            rightSaiPos.lerpVectors(this.rightSaiIdlePos, new THREE.Vector3(0.4, 0.1, 0.1), easedProgress);
            leftSaiRot.slerpQuaternions(new THREE.Quaternion(), this.leftSaiWindUpRot, easedProgress);
            rightSaiRot.slerpQuaternions(new THREE.Quaternion(), this.rightSaiWindUpRot, easedProgress);
        } else if (p < impactPhaseEnd) {
            // Impact/Thrust phase: thrust forward, focusing on piercing motion
            easedProgress = (p - windUpPhaseEnd) / (impactPhaseEnd - windUpPhaseEnd);
            // Strong forward movement (Z-axis)
            leftSaiPos.lerpVectors(new THREE.Vector3(-0.4, 0.1, 0.1), new THREE.Vector3(-0.15, 0.0, -0.6), easedProgress); // Increased Z thrust
            rightSaiPos.lerpVectors(new THREE.Vector3(0.4, 0.1, 0.1), new THREE.Vector3(0.15, 0.0, -0.6), easedProgress); // Increased Z thrust
            
            // Aiming rotations (yaw inward, slight pitch down)
            leftSaiRot.slerpQuaternions(this.leftSaiWindUpRot, this.leftSaiImpactRot, easedProgress);
            rightSaiRot.slerpQuaternions(this.rightSaiWindUpRot, this.rightSaiImpactRot, easedProgress);
        } else {
            // Recovery phase: return to idle
            easedProgress = (p - impactPhaseEnd) / (1.0 - impactPhaseEnd);
            leftSaiPos.lerpVectors(new THREE.Vector3(-0.15, 0.0, -0.6), this.leftSaiIdlePos, easedProgress);
            rightSaiPos.lerpVectors(new THREE.Vector3(0.15, 0.0, -0.6), this.rightSaiIdlePos, easedProgress);
            leftSaiRot.slerpQuaternions(this.leftSaiImpactRot, new THREE.Quaternion(), easedProgress);
            rightSaiRot.slerpQuaternions(this.rightSaiImpactRot, new THREE.Quaternion(), easedProgress);
        }

        this.leftSai.position.copy(leftSaiPos);
        this.rightSai.position.copy(rightSaiPos);
        this.leftSai.quaternion.copy(leftSaiRot);
        this.rightSai.quaternion.copy(rightSaiRot);
    }
    
    updateInspectAnimation(p) {
        const upPhaseEnd = 0.2;
        const mainInspectEnd = 0.8;
    
        let easedProgress;
        
        // Group movement
        if (p < upPhaseEnd) {
            easedProgress = 1 - Math.pow(1 - p / upPhaseEnd, 3);
            this.mesh.position.lerpVectors(this.idlePosition, this.inspectUpPos, easedProgress);
            this.mesh.quaternion.slerpQuaternions(this.qIdle, this.qInspectUp, easedProgress);
        } else if (p < mainInspectEnd) {
            easedProgress = (p - upPhaseEnd) / (mainInspectEnd - upPhaseEnd);
            // Oscillate around inspectUpPos
            this.mesh.position.copy(this.inspectUpPos);
            this.mesh.quaternion.slerpQuaternions(this.qInspectUp, this.qInspectUp, easedProgress); // Stay at up rotation
            
            // Individual Sais rotate around their own axes
            this.leftSai.rotation.y = Math.sin(easedProgress * Math.PI * 4) * Math.PI * 0.1;
            this.rightSai.rotation.y = -Math.sin(easedProgress * Math.PI * 4) * Math.PI * 0.1;
            
            this.leftSai.rotation.z = Math.sin(easedProgress * Math.PI * 2) * Math.PI * 0.05;
            this.rightSai.rotation.z = Math.sin(easedProgress * Math.PI * 2) * Math.PI * 0.05;

        } else {
            // Return to idle
            easedProgress = (p - mainInspectEnd) / (1.0 - mainInspectEnd);
            this.mesh.position.lerpVectors(this.inspectUpPos, this.idlePosition, easedProgress);
            this.mesh.quaternion.slerpQuaternions(this.qInspectUp, this.qIdle, easedProgress);

            this.leftSai.quaternion.slerp(new THREE.Quaternion(), easedProgress);
            this.rightSai.quaternion.slerp(new THREE.Quaternion(), easedProgress);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/Sai.js ===


=== FILE: src/game/weapons/Weapon.js ===
--------------------------------------------------
/**
 * Base class for all weapons. Handles shared logic like cooldowns.
 */
export class Weapon {
    constructor(wielder, { name, damage, cooldown }) {
        this.wielder = wielder; // Can be null initially
        this.name = name || 'Unnamed Weapon';
        this.damage = damage || 10;
        this.cooldown = cooldown || 0.5;
        this.cooldownTimer = this.cooldown;
        this.mesh = null; // To be created by subclasses
    }

    canAttack() {
        return this.cooldownTimer >= this.cooldown;
    }

    attack() {
        throw new Error("Weapon.attack() must be implemented by subclasses.");
    }

    inspect() {
        // Base implementation does nothing. Can be overridden by subclasses.
    }

    triggerCooldown() {
        this.cooldownTimer = 0;
    }

    update(deltaTime) {
        if (this.cooldownTimer < this.cooldown) {
            this.cooldownTimer += deltaTime;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/Weapon.js ===


=== FILE: src/game/weapons/WeaponFactory.js ===
--------------------------------------------------
import { Katana } from './Katana.js';
import { Revolver } from './Revolver.js';
import { Sai } from './Sai.js'; // Import the new Sai weapon

const WeaponMap = {
    'WEAPON_001': Katana,
    'WEAPON_REVOLVER': Revolver,
    'WEAPON_SAI': Sai, // Add Sai to the map
};

/**
 * A factory for creating weapon instances from their IDs.
 */
export class WeaponFactory {
    /**
     * Creates a weapon instance for a given weapon ID.
     * @param {string} weaponId - The ID of the weapon (e.g., 'WEAPON_001').
     * @returns {import('./Weapon.js').Weapon | null} An instance of the weapon, or null if the ID is not found.
     */
    static create(weaponId) {
        const WeaponClass = WeaponMap[weaponId];

        if (WeaponClass) {
            return new WeaponClass();
        }

        console.warn(`WeaponFactory: No class found for weapon ID: ${weaponId}`);
        return null;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/WeaponFactory.js ===


=== FILE: src/game/world/LevelManager.js ===
--------------------------------------------------
// src/game/world/LevelManager.js

 import * as THREE from 'three';
    import * as CANNON from 'cannon-es';
    import { NPCPrefab } from '../prefabs/NPCPrefab.js';
    import { COLLISION_GROUPS, RENDERING_LAYERS } from '../../shared/CollisionGroups.js';
    import { Water } from 'three/addons/objects/Water.js';
    
    export class LevelManager {
        constructor(world) {
            this.world = world;
            this.scene = world.scene;
            this.waterfallTextures = null; // Cache for waterfall textures
            this.cubeTextureLoader = new THREE.CubeTextureLoader();
            this.waterfallShaders = null;
        }
    
        async init() {
            if (this.waterfallShaders) return;
            const [vertexShader, fragmentShader] = await Promise.all([
                fetch('./src/client/rendering/shaders/waterfall.vert').then(res => res.text()),
                fetch('./src/client/rendering/shaders/waterfall.frag').then(res => res.text())
            ]);
            this.waterfallShaders = { vertexShader, fragmentShader };
        }
    
        async build(levelData) {
            this.world.levelName = levelData.name || 'Unnamed Level';
            this.world.spawnPoint.copy(levelData.spawnPoint);
            this.world.deathSpawnPoint.copy(levelData.deathSpawnPoint || levelData.spawnPoint);
    
            const sceneSetupResult = await this._setupScene(levelData.settings);
            
            (levelData.objects || []).map(d => this.createObject(d)).forEach(e => this.world.add(e));
            (levelData.npcs || []).map(d => this.createNPC(d)).forEach(e => this.world.add(e));
            (levelData.triggers || []).map(d => this.createTrigger(d, 'Trigger')).forEach(e => this.world.add(e));
            (levelData.deathTriggers || []).map(d => this.createTrigger(d, 'DeathTrigger')).forEach(e => this.world.add(e));
    
            if (this.world.initialEnemyCount !== undefined) {
                this.world.initialEnemyCount = this.world.getNPCs().filter(n => n.team === 'enemy').length;
                this.world.enemiesKilled = 0;
            }
    
            return sceneSetupResult;
        }
    
        async _setupScene(settings) {
            // Dispose previous background if it was a texture
            if (this.scene.background && this.scene.background.isTexture) {
                this.scene.background.dispose();
            }
    
            if (settings.skybox) {
                try {
                    // Defensively ensure the path has a trailing slash.
                    const path = settings.skybox.endsWith('/') ? settings.skybox : `${settings.skybox}/`;
                    const urls = ['px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'].map(file => path + file);
                    this.scene.background = await this.cubeTextureLoader.loadAsync(urls);
                } catch (error) {
                    console.warn(`Could not load skybox from ${settings.skybox}. Defaulting to background color.`, error);
                    this.scene.background = new THREE.Color(parseInt(settings.backgroundColor, 16));
                }
            } else {
                this.scene.background = new THREE.Color(parseInt(settings.backgroundColor, 16));
            }
    
            this.scene.fog = new THREE.Fog(parseInt(settings.fogColor, 16), settings.fogNear, settings.fogFar);
            
            const existingLights = this.scene.children.filter(c => c.isLight);
            existingLights.forEach(l => {
                if(l.target) this.scene.remove(l.target);
                this.scene.remove(l);
            });
    
            const ambientLight = new THREE.AmbientLight(parseInt(settings.ambientLight.color, 16), settings.ambientLight.intensity);
    
            const directionalLights = (settings.directionalLights || []).map(lightData => 
                this.createDirectionalLight(lightData)
            );
    
            return { ambientLight, directionalLights };
        }
        
        createDirectionalLight(lightData) {
            const light = new THREE.DirectionalLight(parseInt(lightData.color, 16), lightData.intensity);
            light.position.set(lightData.position.x, lightData.position.y, lightData.position.z);
            if (lightData.targetPosition) light.target.position.set(lightData.targetPosition.x, lightData.targetPosition.y, lightData.targetPosition.z);
            light.castShadow = true;
            light.shadow.camera.layers.enable(RENDERING_LAYERS.NO_REFLECTION);
            light.userData.definition = lightData;
            return light;
        }
    
        recreateEntity(definition) {
            switch(definition.type) {
                case 'Water':
                case 'Waterfall':
                case 'Box':
                case 'Plane':
                    return this.createObject(definition);
                case 'Dummy':
                    return this.createNPC(definition);
                case 'Trigger':
                    return this.createTrigger(definition, 'Trigger');
                case 'DeathTrigger':
                    return this.createTrigger(definition, 'DeathTrigger');
                case 'DirectionalLight': {
                    const light = this.createDirectionalLight(definition);
                    return this.world.createDirectionalLightWithHelper(light);
                }
                default:
                    return null;
            }
        }
        
        createProgrammaticTexture(drawFn, size = 256) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            drawFn(ctx, size);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
    
        getWaterfallTextures() {
            if (!this.waterfallTextures) {
                const flowTexture = this.createProgrammaticTexture((ctx, size) => {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, size, size);
                    ctx.fillStyle = 'black';
                    for (let i = 0; i < 1000; i++) {
                        const x = Math.random() * size;
                        const y = Math.random() * size;
                        const w = Math.random() * 2 + 1;
                        const h = Math.random() * 30 + 10;
                        ctx.fillRect(x, y, w, h);
                    }
                });
    
                const noiseTexture = this.createProgrammaticTexture((ctx, size) => {
                    for (let i = 0; i < 10000; i++) {
                        const x = Math.random() * size;
                        const y = Math.random() * size;
                        const c = Math.floor(Math.random() * 128 + 128);
                        ctx.fillStyle = `rgb(${c},${c},${c})`;
                        ctx.fillRect(x, y, 2, 2);
                    }
                });
    
                this.waterfallTextures = { flowTexture, noiseTexture };
            }
            return this.waterfallTextures;
        }
    
        createWaterfall(objData) {
            if (!this.waterfallShaders) {
                console.error("Waterfall shaders have not been pre-loaded. LevelManager.init() must be called.");
                const fallbackMaterial = new THREE.MeshBasicMaterial({ color: 0x00A3FF, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                const fallbackMesh = new THREE.Mesh(new THREE.PlaneGeometry(objData.size[0], objData.size[1]), fallbackMaterial);
                return { type: 'Waterfall', mesh: fallbackMesh, definition: objData };
            }
    
            const { flowTexture, noiseTexture } = this.getWaterfallTextures();
            const waterfallMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uFlowTexture: { value: flowTexture },
                    uNoiseTexture: { value: noiseTexture },
                },
                vertexShader: this.waterfallShaders.vertexShader,
                fragmentShader: this.waterfallShaders.fragmentShader,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false
            });
    
            const waterfallMesh = new THREE.Mesh(new THREE.PlaneGeometry(objData.size[0], objData.size[1]), waterfallMaterial);
            
            const entity = { id: THREE.MathUtils.generateUUID(), type: 'Waterfall', mesh: waterfallMesh, definition: objData };
    
            entity.mesh.position.set(objData.position.x, objData.position.y, objData.position.z);
            if (objData.quaternion) {
                entity.mesh.quaternion.set(objData.quaternion.x, objData.quaternion.y, objData.quaternion.z, objData.quaternion.w);
            } else if (objData.rotation) {
                const euler = new THREE.Euler(THREE.MathUtils.degToRad(objData.rotation.x || 0), THREE.MathUtils.degToRad(objData.rotation.y || 0), THREE.MathUtils.degToRad(objData.rotation.z || 0), 'YXZ');
                entity.mesh.quaternion.setFromEuler(euler);
            }
    
            entity.mesh.castShadow = false;
            entity.mesh.receiveShadow = false;
            entity.mesh.layers.enable(RENDERING_LAYERS.NO_REFLECTION);
            
            const link = { type: 'Waterfall', entity };
            entity.userData = { gameEntity: link };
            entity.mesh.userData.gameEntity = link;
            
            return entity;
        }
    
        createWater(objData) {
            const size = (objData.size || [1, 1, 1]).map(s => Math.abs(s) || 0.1);
            const position = new CANNON.Vec3(objData.position.x, objData.position.y, objData.position.z);
            
            const cannonQuat = new CANNON.Quaternion();
            if (objData.quaternion) {
                cannonQuat.set(objData.quaternion.x, objData.quaternion.y, objData.quaternion.z, objData.quaternion.w);
            } else if (objData.rotation) {
                const euler = new THREE.Euler(THREE.MathUtils.degToRad(objData.rotation.x), THREE.MathUtils.degToRad(objData.rotation.y), THREE.MathUtils.degToRad(objData.rotation.z), 'YXZ');
                cannonQuat.setFromEuler(euler.x, euler.y, euler.z, euler.order);
            }
            
            const shape = new CANNON.Box(new CANNON.Vec3(size[0] / 2, size[1] / 2, size[2] / 2));
            const body = new CANNON.Body({
                type: CANNON.Body.STATIC, isTrigger: true, shape, position, quaternion: cannonQuat,
                collisionFilterGroup: COLLISION_GROUPS.WATER,
                collisionFilterMask: COLLISION_GROUPS.PLAYER | COLLISION_GROUPS.ENEMY | COLLISION_GROUPS.ALLY,
            });
    
            let sunLight = this.world.scene.children.find(c => c.isDirectionalLight);
            if (!sunLight) {
                sunLight = new THREE.DirectionalLight(0xffffff, 1);
                sunLight.position.set(0, 100, 0);
            }
            const waterSunColor = new THREE.Color(sunLight.color).multiplyScalar(0.3);
    
            const waterMesh = new Water(new THREE.PlaneGeometry(size[0], size[2]), {
                // OPTIMIZATION: Lowered texture resolution for reflections/refractions
                textureWidth: 256, 
                textureHeight: 256,
                waterNormals: new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; }),
                sunDirection: sunLight.position.clone().normalize(),
                sunColor: waterSunColor, 
                waterColor: 0x005577,
                // OPTIMIZATION: Reduced distortion scale to look better with lower res textures
                distortionScale: 2.0, 
                fog: !!this.world.scene.fog, 
                alpha: 0.9,
            });
            
            waterMesh.layers.disable(RENDERING_LAYERS.NO_REFLECTION);
    
            const entity = { id: THREE.MathUtils.generateUUID(), type: 'Water', mesh: waterMesh, body, definition: objData };
            
            // --- POSITIONING FIX ---
            // Calculate the world-space "up" vector of the rotated volume
            const upVector = new THREE.Vector3(0, 1, 0);
            upVector.applyQuaternion(new THREE.Quaternion().copy(cannonQuat));
    
            // The water surface should be at the center of the volume, offset by half the height along the volume's up direction.
            const waterSurfacePosition = new THREE.Vector3().copy(position).add(upVector.multiplyScalar(size[1] / 2));
            entity.mesh.position.copy(waterSurfacePosition);
            
            // Apply the volume's rotation, then rotate the plane to be horizontal relative to the volume
            entity.mesh.quaternion.copy(cannonQuat);
            entity.mesh.rotateX(-Math.PI / 2);
    
            const helperMaterial = new THREE.MeshBasicMaterial({ color: 0x2288ee, transparent: true, opacity: 0.35, wireframe: true });
            const helperMesh = new THREE.Mesh(new THREE.BoxGeometry(...size), helperMaterial);
            helperMesh.position.copy(position);
            helperMesh.quaternion.copy(cannonQuat);
            entity.helperMesh = helperMesh;
            
            const link = { type: 'Water', entity };
            entity.userData = { gameEntity: link };
            entity.mesh.userData.gameEntity = link;
            entity.helperMesh.userData.gameEntity = link;
            if (!body.userData) body.userData = {};
            body.userData.entity = entity;
            
            return entity;
        }
    
        createObject(objData) {
            if (objData.type === 'Water') {
                return this.createWater(objData);
            }
            if (objData.type === 'Waterfall') {
                return this.createWaterfall(objData);
            }
    
            let mesh, body, shape;
            const mat = new THREE.MeshStandardMaterial({ color: parseInt(objData.material?.color, 16) || 0xcccccc, roughness: objData.material?.roughness ?? 0.8 });
            const size = (objData.size || [1,1,1]).map(s => Math.abs(s) || 0.1);
    
            if (objData.type === 'Plane') {
                mesh = new THREE.Mesh(new THREE.PlaneGeometry(size[0], size[1]), mat);
                shape = new CANNON.Plane();
            } else {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(...size), mat);
                shape = new CANNON.Box(new CANNON.Vec3(size[0] / 2, size[1] / 2, size[2] / 2));
            }
            
            body = new CANNON.Body({ mass: objData.physics?.mass ?? 0, shape, type: (objData.physics?.mass ?? 0) > 0 ? CANNON.Body.DYNAMIC : CANNON.Body.STATIC, collisionFilterGroup: COLLISION_GROUPS.WORLD });
            
            // --- ИСПРАВЛЕННАЯ ЛОГИКА ---
            mesh.position.set(objData.position.x, objData.position.y, objData.position.z);

            if (objData.quaternion) {
                mesh.quaternion.set(
                    objData.quaternion.x,
                    objData.quaternion.y,
                    objData.quaternion.z,
                    objData.quaternion.w
                );
            } else if (objData.rotation) { // Fallback for old levels
                const euler = new THREE.Euler(
                    THREE.MathUtils.degToRad(objData.rotation.x || 0),
                    THREE.MathUtils.degToRad(objData.rotation.y || 0),
                    THREE.MathUtils.degToRad(objData.rotation.z || 0),
                    'YXZ'
                );
                mesh.quaternion.setFromEuler(euler);
            }

            // ПРИНУДИТЕЛЬНАЯ СИНХРОНИЗАЦИЯ: Копируем трансформацию из mesh в body
            body.position.copy(mesh.position);
            body.quaternion.copy(mesh.quaternion);
            // --- КОНЕЦ ИСПРАВЛЕННОЙ ЛОГИКИ ---

            mesh.castShadow = true;
            mesh.receiveShadow = true;
    
            const entity = { type: 'Object', mesh, body, definition: objData };
            const link = { type: 'Object', entity };
            entity.userData = { gameEntity: link };
            mesh.userData.gameEntity = link;
            if (!body.userData) body.userData = {};
            body.userData.entity = entity;
            
            return entity;
        }
    
        createNPC(npcData) {
            return NPCPrefab.create(this.world, npcData);
        }
    
        createTrigger(triggerData, type) {
            const isDeathTrigger = type === 'DeathTrigger';
            const color = isDeathTrigger ? 0xff0000 : parseInt(triggerData.color || "0x00ff00", 16);
            const material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.35, wireframe: true, depthWrite: false });
            
            const size = (triggerData.size || [1,1,1]).map(s => Math.abs(s) || 0.1);
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(...size), material);
            mesh.position.set(triggerData.position.x, triggerData.position.y, triggerData.position.z);
    
            const shape = new CANNON.Box(new CANNON.Vec3(...size.map(s => s / 2)));
            const body = new CANNON.Body({ type: CANNON.Body.STATIC, isTrigger: true, shape, position: new CANNON.Vec3(triggerData.position.x, triggerData.position.y, triggerData.position.z), collisionFilterGroup: COLLISION_GROUPS.TRIGGER, collisionFilterMask: COLLISION_GROUPS.PLAYER | COLLISION_GROUPS.ENEMY | COLLISION_GROUPS.ALLY });
            
            if (triggerData.quaternion) {
                body.quaternion.set(triggerData.quaternion.x, triggerData.quaternion.y, triggerData.quaternion.z, triggerData.quaternion.w);
            } else if (triggerData.rotation) {
                const euler = new THREE.Euler(THREE.MathUtils.degToRad(triggerData.rotation.x || 0), THREE.MathUtils.degToRad(triggerData.rotation.y || 0), THREE.MathUtils.degToRad(triggerData.rotation.z || 0), 'YXZ');
                body.quaternion.setFromEuler(euler.x, euler.y, euler.z, euler.order);
            }
            mesh.quaternion.copy(body.quaternion);
            
            const entityType = isDeathTrigger ? 'DeathTrigger' : 'Trigger';
            const entity = { type: entityType, mesh, body, definition: triggerData, message: triggerData.message, duration: triggerData.duration, hasFired: false };
            entity.userData = { gameEntity: { type: entityType, entity } };
            mesh.userData.gameEntity = entity.userData.gameEntity;
            if (!body.userData) body.userData = {};
            body.userData.entity = entity;
            
            return entity;
        }
    }
--------------------------------------------------
=== END OF FILE: src/game/world/LevelManager.js ===


=== FILE: src/game/world/World.js ===
--------------------------------------------------
import * as THREE from 'three';
import { EventEmitter } from '../../shared/EventEmitter.js';
import { LevelManager } from './LevelManager.js';
import { PlayerPrefab } from '../prefabs/PlayerPrefab.js';
import { MovementSystem } from '../systems/MovementSystem.js';
import { AISystem } from '../systems/AISystem.js';
import { AbilitySystem } from '../systems/AbilitySystem.js';
import { WeaponSystem } from '../systems/WeaponSystem.js';
import { TargetingSystem } from '../systems/TargetingSystem.js';
import { DeathSystem } from '../systems/DeathSystem.js';
import { TriggerSystem } from '../systems/TriggerSystem.js';
import { OutOfBoundsSystem } from '../systems/OutOfBoundsSystem.js';
import { StatusEffectSystem } from '../systems/StatusEffectSystem.js';
import { WaterSystem } from '../systems/WaterSystem.js';
import { PlayerResourceSystem } from '../systems/PlayerResourceSystem.js';
import { AnimationSystem } from '../systems/AnimationSystem.js';
import { Fireball } from '../abilities/Fireball.js';
import { EnemyProjectile } from '../abilities/EnemyProjectile.js';
import { FireflyProjectile } from '../abilities/FireflyProjectile.js';

/**
 * Represents a single level instance, containing all entities, systems, and game state.
 */
export class World {
    constructor(core, game) {
        this.emitter = new EventEmitter(); // Composition
        this.core = core;
        this.game = game;
        this.scene = core.renderer.scene;
        this.physics = core.physics;
        
        this.levelName = '';
        this.spawnPoint = new THREE.Vector3();
        this.deathSpawnPoint = new THREE.Vector3();
        this.player = null;
        this.entities = new Set();
        this._entitiesByType = new Map();
        this.initialEnemyCount = 0;
        this.enemiesKilled = 0;
        this.lights = []; // To track lights for disposal

        this.levelManager = new LevelManager(this);
        this.systems = [
            new WaterSystem(),
            new MovementSystem(),
            new AISystem(),
            new AbilitySystem(),
            new PlayerResourceSystem(),
            new WeaponSystem(),
            new TargetingSystem(),
            new DeathSystem(),
            new OutOfBoundsSystem(),
            new StatusEffectSystem(),
            new AnimationSystem(),
        ];
        this.triggerSystem = new TriggerSystem(this);
    }

    // --- Event Emitter Delegation ---
    on(eventName, listener) { this.emitter.on(eventName, listener); }
    emit(eventName, data) { this.emitter.emit(eventName, data); }
    off(eventName, listener) { this.emitter.off(eventName, listener); }
    removeAllListeners() { this.emitter.removeAllListeners(); }

    async loadLevel(config) {
        let levelData;
        if (config.url) {
            const response = await fetch(config.url);
            if (!response.ok) throw new Error(`Failed to load level: ${response.statusText}`);
            levelData = await response.json();
        } else if (config.data) {
            levelData = config.data;
        } else {
            throw new Error('Level configuration must provide a URL or data.');
        }

        await this.levelManager.init();
        const { ambientLight, directionalLights } = await this.levelManager.build(levelData);

        // Add lights to scene and track them
        this.lights.push({ light: ambientLight });
        this.scene.add(ambientLight);
        directionalLights.forEach(dLight => {
            this.lights.push({ light: dLight, target: dLight.target });
            this.scene.add(dLight);
            this.scene.add(dLight.target);
        });

        this.player = PlayerPrefab.create(
            this,
            this.core.renderer.camera,
            this.game.viewModelScene,
            config.loadout
        );
        this.add(this.player);
    }
    
    onNPCDied(npc) {
        if (npc.team === 'enemy') {
            this.enemiesKilled++;
            if (this.initialEnemyCount > 0 && this.enemiesKilled >= this.initialEnemyCount) {
                this.emit('levelCompleted');
            }
        }
    }

    add(entity) {
        if (!entity || this.entities.has(entity)) return;
        this.entities.add(entity);
        if (entity.type) {
            if (!this._entitiesByType.has(entity.type)) {
                this._entitiesByType.set(entity.type, new Set());
            }
            this._entitiesByType.get(entity.type).add(entity);
        }
        
        if (entity.mesh) this.scene.add(entity.mesh);
        // Do NOT add helperMesh in the game world, only in the editor.
        // if (entity.helperMesh) this.scene.add(entity.helperMesh);
        const body = entity.physics?.body || entity.body;
        if (body) this.physics.addBody(body);

        this.emit('entityAdded', { entity });

        if (entity.type === 'npc') this.emit('npcSpawned', { npc: entity });
    }

    remove(entity) {
        if (!entity || !this.entities.has(entity)) return;
        this.emit('entityRemoved', { entity });
        if (entity.dispose) entity.dispose();
        else {
            if (entity.mesh) {
                this.scene.remove(entity.mesh);
                entity.mesh.geometry?.dispose();
                if (Array.isArray(entity.mesh.material)) entity.mesh.material.forEach(m => m.dispose());
                else entity.mesh.material?.dispose();
            }
             if (entity.helperMesh) this.scene.remove(entity.helperMesh);
            const body = entity.physics?.body || entity.body;
            if (body) this.physics.queueForRemoval(body);
        }
        
        this.entities.delete(entity);
        if (entity.type && this._entitiesByType.has(entity.type)) {
            this._entitiesByType.get(entity.type).delete(entity);
        }
    }

    getEntities() { return Array.from(this.entities); }
    getNPCs() { return Array.from(this._entitiesByType.get('npc') || []); }
    getEnemies() { return this.getNPCs().filter(npc => npc.team === 'enemy'); }
    getAllies() { return this.getNPCs().filter(npc => npc.team === 'player'); }
    getLevelObjects() { return Array.from(this._entitiesByType.get('Object') || []); }
    getTriggers() { return Array.from(this._entitiesByType.get('Trigger') || []); }
    getDeathTriggers() { return Array.from(this._entitiesByType.get('DeathTrigger') || []); }
    getWaterVolumes() { return Array.from(this._entitiesByType.get('Water') || []); }
    getWaterfalls() { return Array.from(this._entitiesByType.get('Waterfall') || []); }

    resetPlayer() {
        if (this.player) {
            this.player.reset(this.deathSpawnPoint);
            this.emit('playerRespawned');
        }
    }

    createFireball(data) { new Fireball({ world: this, ...data }); }
    createEnemyProjectile(data) { new EnemyProjectile({ world: this, ...data }); }
    createFireflyProjectile(data) { new FireflyProjectile({ world: this, ...data }); }

    update(deltaTime) {
        const elapsedTime = this.core.clock.getElapsedTime();
        for (const system of this.systems) system.update(this, deltaTime);
        for (const entity of this.entities) if (entity.update) entity.update(deltaTime);

        const entitiesWithShaders = [...this.getWaterVolumes(), ...this.getWaterfalls()];
        for (const entity of entitiesWithShaders) {
            const uniforms = entity.mesh?.material?.uniforms;
            if (uniforms) {
                if (uniforms.time) { // For THREE.Water pools
                    uniforms.time.value = elapsedTime;
                }
                if (uniforms.uTime) { // For custom waterfall shader
                    uniforms.uTime.value = elapsedTime;
                }
            }
        }
    }
    
    dispose() {
        this.removeAllListeners();
        this.triggerSystem.dispose();
        
        // Dispose lights first
        this.lights.forEach(item => {
            this.scene.remove(item.light);
            if (item.target) this.scene.remove(item.target);
            item.light.dispose();
        });
        this.lights = [];

        [...this.entities].forEach(entity => this.remove(entity));
        this.scene.children.slice().forEach(child => {
            if (child.type !== 'PerspectiveCamera') this.scene.remove(child);
        });
        this.physics.world.bodies.forEach(body => this.physics.queueForRemoval(body));
        this.physics._removeQueuedBodies();
        this.systems = [];
    }
}
--------------------------------------------------
=== END OF FILE: src/game/world/World.js ===


=== FILE: src/shared/CollisionGroups.js ===
--------------------------------------------------
// Defines distinct bit Categ for physics objects.
// This allows fine-grained control over which objects can collide with each other.
// Each category should be a power of 2.

export const COLLISION_GROUPS = {
    WORLD:             1,
    PLAYER:            2,
    ALLY:              4,
    ENEMY:             8,
    PLAYER_PROJECTILE: 16,
    ENEMY_PROJECTILE:  32,
    TRIGGER:           64,
    VISION_BLOCKER:    128, // Blocks AI line of sight
    WATER:             256,
};

export const RENDERING_LAYERS = {
    DEFAULT: 0,
    NO_REFLECTION: 1,
};
--------------------------------------------------
=== END OF FILE: src/shared/CollisionGroups.js ===


=== FILE: src/shared/config.js ===
--------------------------------------------------
// This file centralizes all game balance and configuration constants.
// Modifying these values will directly impact gameplay without needing to change core logic.

export const GAME_CONFIG = {
    // General world settings
    DEATH_Y: -100, // Y-coordinate below which entities are considered out of bounds

    // General physics
    GRAVITY: 9.82,

    // Player movement parameters
    PLAYER: {
        MAX_HEALTH: 1000,
        MAX_ENERGY: 1000,
        MAX_OXYGEN: 1000,
        ENERGY_REGEN_RATE: 25, // points per second
        ENERGY_REGEN_DELAY: 5.0, // seconds after last ability use
        OXYGEN_CONSUMPTION_RATE: 50, // 1000 / 20 seconds = 50/s
        OXYGEN_REGEN_RATE: 200, // points per second
        OXYGEN_DAMAGE_PER_SECOND: 75,
        
        FOV: 75, // Default field of view
        SPEED: 8.0, // meters per second
        SWIM_SPEED: 6.0, // base vertical/horizontal speed in water
        SWIM_FORCE_MULTIPLIER: 80, // Multiplier for vertical force application
        JUMP_HEIGHT: 8.0, // initial vertical velocity on jump
        MAX_JUMPS: 2,
        
        DASH_SPEED_MULTIPLIER: 4.0,
        DASH_DURATION: 0.2, // seconds
        DASH_COOLDOWN: 2.0, // seconds
        
        DOUBLE_JUMP_COOLDOWN: 1.5, // seconds
        DOUBLE_TAP_WINDOW: 300, // milliseconds
        
        GROUND_SLAM_VELOCITY: -25.0, // downward velocity on slam
        
        RADIUS: 0.8, // for physics body
        MASS: 70, // kg
        DEFAULT_DAMPING: 0.01,
    },

    // Weapon parameters
    KATANA: {
        DAMAGE: 250,
        COOLDOWN: 0.6, // seconds
        RANGE: 4.0, // meters
        SLAM_DAMAGE_MULTIPLIER: 2.0,
    },
    REVOLVER: { // Added for completeness, but not used by class directly yet
        DAMAGE: 100,
        COOLDOWN: 0.5,
        MAGAZINE_SIZE: 6,
        RESERVE_AMMO: 24,
    },
    SAI: {
        DAMAGE: 150,
        COOLDOWN: 0.7, // Slightly longer cooldown than Katana due to dual hit/bleed potential
        RANGE: 2.5, // Shorter range than Katana as it's more of a thrust
        SLAM_DAMAGE_MULTIPLIER: 1.5, // Less powerful slam than Katana
    },
    
    // Ability-specific parameters
    WAVE_POWER: {
        WIDTH: 8.0, // meters
        LENGTH: 25.0, // meters
        IMPULSE_FORWARD: 3000, // in kg*m/s
        IMPULSE_UPWARD: 1000, // in kg*m/s
        DAMAGE: 200,
        KNOCKBACK_DURATION: 1.0, // seconds
    },

    // Status Effect parameters
    BLEEDING: {
        DURATION: 10.0, // seconds
        DAMAGE_PER_SECOND: 5, // Total damage over duration
        TICK_INTERVAL: 1.0, // seconds between each damage tick
        DAMAGE_PER_TICK: 5, // Calculated: DAMAGE_PER_SECOND * TICK_INTERVAL
        HP_THRESHOLD_PERCENT: 0.5, // Apply bleeding if enemy HP is below this percentage
    },

    // NPC base parameters
    NPC: {
        BASE: {
            MAX_HEALTH: 500,
            SPEED: 7.0,
            MASS: 80,
            RADIUS: 0.8,
        },
        RANGED: {
            PROJECTILE_DAMAGE: 100,
            PROJECTILE_SPEED: 40,
        },
        MELEE: {
            DAMAGE: 150,
        }
    },
    
    // Targeting system parameters
    TARGETING: {
        MAX_RANGE: 100, // meters
        MAX_ANGLE_RAD: Math.atan(0.26), // Approx. 15 degrees tan(15 deg)
    },

    // HUD and UI
    UI: {
        RESPAWN_COOLDOWN: 5.0,
    }
};
--------------------------------------------------
=== END OF FILE: src/shared/config.js ===


=== FILE: src/shared/EventEmitter.js ===
--------------------------------------------------
/**
 * A simple event emitter class for handling custom events.
 * This allows for decoupled communication between different parts of the application.
 */
export class EventEmitter {
    constructor() {
        this.events = {};
    }

    /**
     * Registers a listener for a specific event.
     * @param {string} eventName - The name of the event.
     * @param {Function} listener - The callback function to execute.
     */
    on(eventName, listener) {
        if (!this.events[eventName]) {
            this.events[eventName] = [];
        }
        this.events[eventName].push(listener);
    }

    /**
     * Emits an event, calling all registered listeners with the provided data.
     * @param {string} eventName - The name of the event to emit.
     * @param {*} [data] - Optional data to pass to the listeners.
     */
    emit(eventName, data) {
        const listeners = this.events[eventName];
        if (listeners) {
            listeners.forEach(listener => listener(data));
        }
    }

    /**
     * Removes a specific listener for an event.
     * @param {string} eventName - The name of the event.
     * @param {Function} listenerToRemove - The listener function to remove.
     */
    off(eventName, listenerToRemove) {
        const listeners = this.events[eventName];
        if (listeners) {
            this.events[eventName] = listeners.filter(listener => listener !== listenerToRemove);
        }
    }

    /**
     * Removes all listeners for all events.
     */
    removeAllListeners() {
        this.events = {};
    }
}
--------------------------------------------------
=== END OF FILE: src/shared/EventEmitter.js ===


=== FILE: src/shared/util.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * A collection of common utility functions.
 */

export const Util = {
    /**
     * Calculates the launch velocity for a projectile to hit a target, considering gravity.
     * @param {THREE.Vector3} startPos - The starting position of the projectile.
     * @param {THREE.Vector3} targetPos - The target position.
     * @param {number} projectileSpeed - The initial speed of the projectile.
     * @param {number} gravity - The magnitude of gravity (should be positive).
     * @returns {THREE.Vector3|null} The initial velocity vector, or null if the target is unreachable.
     */
    calculateBallisticLaunchVelocity(startPos, targetPos, projectileSpeed, gravity) {
        const delta = new THREE.Vector3().subVectors(targetPos, startPos);
        const deltaXZ = new THREE.Vector2(delta.x, delta.z);
        const distXZ = deltaXZ.length();

        const v = projectileSpeed;
        const g = gravity;
        const y = delta.y;
        const x = distXZ;

        const discriminant = v**4 - g * (g * x**2 + 2 * y * v**2);
        
        if (discriminant < 0) {
            // Target is out of range
            return null;
        }

        // We choose the lower angle for a more direct shot. 
        // Use + for a higher, arcing shot.
        const angle = Math.atan2(v**2 - Math.sqrt(discriminant), g * x);
        
        const Vy = v * Math.sin(angle);
        const Vxz = v * Math.cos(angle);
        
        const dirXZ = deltaXZ.normalize();
        
        return new THREE.Vector3(dirXZ.x * Vxz, Vy, dirXZ.y * Vxz);
    }
};
--------------------------------------------------
=== END OF FILE: src/shared/util.js ===


================================================================================
Snapshot Complete.
