Flutter Project Snapshot (Python Script)
Project Root: C:\Users\levndays\Desktop\elementals\elementals
Snapshot created on: 2025-07-03T14:23:17.641794
================================================================================

=== FILE: card-inspector.html ===
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELEMENTALS - Card Inspector</title>
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/card-inspector.css">
    <link rel="icon" href="data:,">
</head>
<body class="inspector-page">

    <div id="inspector-container">
        <header id="inspector-header">
            <h1 id="card-name-title">Card Inspector</h1>
            <button id="exit-btn" class="button-secondary">Back to Loadout</button>
        </header>

        <main id="inspector-main">
            <canvas id="inspector-canvas"></canvas>
            <div id="inspector-prompt">Loading Card...</div>
        </main>
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
        }
    }
    </script>
    <script type="module" src="src/client/ui/card_inspector_main.js"></script>

</body>
</html>
--------------------------------------------------
=== END OF FILE: card-inspector.html ===


=== FILE: create_snapshot.py ===
--------------------------------------------------
[Content Omitted - Generated/Tooling File]

--------------------------------------------------
=== END OF FILE: create_snapshot.py ===


=== FILE: editor.html ===
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elementals - Level Editor</title>
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/editor.css">
    <link rel="icon" href="data:,">
</head>
<body>
    <div id="editor-container">
        <!-- TOP MENU BAR -->
        <div id="editor-menu-bar">
            <details class="menu-dropdown">
                <summary>File</summary>
                <div class="menu-content">
                    <button id="menu-file-new">New Level</button>
                    <button id="menu-file-open">Open...</button>
                    <input type="file" id="editor-file-input" accept=".json" style="display: none;">
                    <button id="menu-file-save">Save</button>
                    <hr>
                    <button id="menu-file-play">Play Level (Debug)</button>
                    <hr>
                    <button id="menu-file-exit">Exit to Main Menu</button>
                </div>
            </details>
            <details class="menu-dropdown">
                <summary>Edit</summary>
                <div class="menu-content">
                    <button id="menu-edit-undo" disabled>Undo (Ctrl+Z)</button>
                    <button id="menu-edit-redo" disabled>Redo (Ctrl+Y)</button>
                    <hr>
                    <button id="menu-edit-copy" disabled>Copy (Ctrl+C)</button>
                    <button id="menu-edit-paste">Paste (Ctrl+V)</button>
                    <button id="menu-edit-delete" disabled>Delete (Del)</button>
                </div>
            </details>
            <details class="menu-dropdown">
                <summary>View</summary>
                <div class="menu-content checkbox-menu">
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-grid" checked><label for="view-toggle-grid">Grid</label></div>
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-light-helpers" checked><label for="view-toggle-light-helpers">Light Helpers</label></div>
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-spawn-helpers" checked><label for="view-toggle-spawn-helpers">Spawn Helpers</label></div>
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-msg-triggers" checked><label for="view-toggle-msg-triggers">Message Triggers</label></div>
                    <div class="checkbox-row"><input type="checkbox" id="view-toggle-death-triggers" checked><label for="view-toggle-death-triggers">Death Zones</label></div>
                </div>
            </details>
             <details class="menu-dropdown">
                <summary>Help</summary>
                <div class="menu-content">
                    <button id="menu-help-metrics">Player Metrics Info</button>
                </div>
            </details>
        </div>

        <!-- TOOLBAR -->
        <div id="editor-toolbar">
            <div class="toolbar-group">
                <button id="tool-translate" class="active" title="Translate (T)">T</button>
                <button id="tool-rotate" title="Rotate (R)">R</button>
                <button id="tool-scale" title="Scale (S)">S</button>
            </div>
            <div class="separator"></div>
            <div class="toolbar-group">
                 <button id="tool-space" title="Toggle Space (Q)">World</button>
            </div>
            <div class="separator"></div>
            <div class="toolbar-group snap-group">
                 <input type="checkbox" id="snap-toggle" title="Enable Snapping">
                 <label for="snap-toggle">Enable Snapping</label>
                 <input type="number" id="snap-translation-input" step="0.25" value="1" title="Grid Snap (m)">
                 <input type="number" id="snap-rotation-input" step="5" value="15" title="Angle Snap (°)">
            </div>
        </div>

        <!-- OUTLINER PANEL (Left) -->
        <div id="editor-outliner" class="side-panel">
            <div class="panel-header">OUTLINER</div>
            <div class="panel-content" id="outliner-content">
                <!-- Dynamically populated tree view -->
            </div>
        </div>

        <!-- VIEWPORT (Center) -->
        <div id="editor-viewport">
            <canvas id="game-canvas"></canvas>
            <!-- REWORKED: Single create button and context menu -->
            <div id="create-button-container">
                <button id="create-button" title="Create Object">+</button>
                <div id="create-context-menu" class="context-menu" style="display: none;">
                    <div class="context-menu-section">Primitives</div>
                    <button data-action="addBox">Box</button>
                    <div class="context-menu-section">Lights</div>
                    <button data-action="addDirectionalLight">Directional Light</button>
                    <div class="context-menu-section">Actors</div>
                    <button data-action="addEnemy">Enemy</button>
                    <div class="context-menu-section">Volumes</div>
                    <button data-action="addMessageTrigger">Message Trigger</button>
                    <button data-action="addDeathTrigger">Death Zone</button>
                    <div class="context-menu-section">Scene Points</div>
                    <button data-action="setSpawnPointToCamera">Set Initial Spawn</button>
                    <button data-action="setDeathSpawnPointToCamera">Set Death Spawn</button>
                </div>
            </div>
        </div>

        <!-- INSPECTOR PANEL (Right) -->
        <div id="editor-inspector" class="side-panel">
            <div class="panel-header">INSPECTOR</div>
            <div class="panel-content" id="inspector-content">
                <!-- Dynamically populated properties -->
                <div class="placeholder-text">Select an object to view its properties.</div>
            </div>
        </div>
        
        <!-- ASSET BROWSER (Bottom) - REMOVED for new Create button -->
        <div id="editor-asset-browser" style="display: none;"></div>

        <!-- STATUS BAR (Bottom Edge) -->
        <div id="editor-status-bar">
            <span id="status-message">Ready.</span>
        </div>
    </div>

    <!-- INFO MODAL (Unchanged) -->
    <div id="editor-info-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <span class="modal-close-btn">×</span>
            <h3>Player Movement Metrics</h3>
            <pre id="info-modal-text"></pre>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
            "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>
    
    <script type="module" src="src/editor/editor_main.js"></script>
</body>
</html>
--------------------------------------------------
=== END OF FILE: editor.html ===


=== FILE: index.html ===
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELEMENTALS</title>
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/game.css">
    <link rel="icon" href="data:,">
</head>
<body class="">
    <!-- Menu System (wrapper) -->
    <div id="menu-system">
        <!-- Main Menu -->
        <div id="main-menu" class="menu-screen">
            <h1>ELEMENTALS</h1>
            <div class="menu-options">
                <button id="play-btn">Play</button>
                <button id="loadout-btn">Loadout</button>
                <button id="editor-btn">Level Editor</button>
            </div>
        </div>
        <!-- Level Select -->
        <div id="level-select-menu" class="menu-screen" style="display: none;">
            <h2>Select Level</h2>
            <div id="level-list" class="menu-list">
                <!-- Dynamically populated -->
            </div>
            <div class="menu-options" style="margin-top: 20px;">
                 <button id="load-custom-level-btn">Load Custom Level</button>
            </div>
            <input type="file" id="custom-level-input" accept=".json" style="display: none;">
            <button class="back-button" data-target="main-menu">Back</button>
        </div>
        <!-- Pause Menu -->
        <div id="pause-menu" class="menu-screen" style="display: none;">
            <h2>Paused</h2>
            <div class="menu-options">
                <button id="resume-btn">Resume</button>
                <button id="pause-quit-btn">Quit to Menu</button>
            </div>
        </div>
        <!-- Death Screen -->
        <div id="death-screen" class="menu-screen" style="display: none;">
            <h2>YOU DIED</h2>
            <p id="respawn-timer-text">Respawning in 5...</p>
            <div class="menu-options">
                <button id="death-quit-btn">Return to Menu</button>
            </div>
        </div>
    </div>

    <!-- In-Game UI & VFX -->
    <div id="screen-overlay" class="vfx-overlay"></div>
    <div id="vfx-dash-forward" class="vfx-overlay"></div>
    <div id="vfx-dash-sideways" class="vfx-overlay"></div>
    <div id="vfx-jump-wind" class="vfx-overlay"></div>
    <div id="vfx-ground-slam" class="vfx-overlay"></div>
    <div id="vfx-earth-buff" class="vfx-overlay"></div>
    <div id="target-frame"></div>
    <div id="tutorial-text-container" style="display: none;">
        <p id="tutorial-text"></p>
    </div>
    
    <!-- Crosshair & Movement Cooldowns -->
    <div id="crosshair-container">
        <div id="jump-cooldown-indicator" class="movement-cooldown">
            <svg viewBox="-5 -5 110 110">
                <path class="cooldown-track" d="M 50,0 A 50,50 0 0 0 50,100" />
                <path class="cooldown-progress" d="M 50,0 A 50,50 0 0 0 50,100" />
            </svg>
        </div>
        <div id="crosshair"></div>
        <div id="dash-cooldown-indicator" class="movement-cooldown">
            <svg viewBox="-5 -5 110 110">
                <path class="cooldown-track" d="M 50,0 A 50,50 0 0 1 50,100" />
                <path class="cooldown-progress" d="M 50,0 A 50,50 0 0 1 50,100" />
            </svg>
        </div>
    </div>

    <canvas id="game-canvas"></canvas>

    <!-- Game HUD -->
    <div id="game-hud">
        <div id="hud-top-left" class="hud-corner">
            <div id="health-bar-container" class="resource-bar-container">
                <div id="health-bar"></div>
            </div>
            <div id="energy-bar-container" class="resource-bar-container">
                <div id="energy-bar"></div>
            </div>
        </div>

        <div id="hud-top-center" class="hud-corner">
            <div id="enemy-counter"></div>
        </div>

        <div id="hud-top-right" class="hud-corner">
            <canvas id="minimap-canvas" width="180" height="180"></canvas>
        </div>
        
        <div id="hud-bottom-right" class="hud-corner">
            <div id="ammo-counter" style="display: none;">
                <span id="ammo-mag"></span> / <span id="ammo-reserve"></span>
            </div>
        </div>
        
        <div id="hud-bottom-center" class="hud-corner">
            <div id="abilities-container">
                <div id="ability-0" class="ability-slot">
                    <svg class="cooldown-ring" viewBox="0 0 36 36">
                        <circle class="cooldown-track" cx="18" cy="18" r="15.9155" />
                        <circle class="cooldown-ring-circle" cx="18" cy="18" r="15.9155" />
                    </svg>
                    <span class="ability-icon"></span>
                </div>
                <div id="ability-1" class="ability-slot">
                     <svg class="cooldown-ring" viewBox="0 0 36 36">
                        <circle class="cooldown-track" cx="18" cy="18" r="15.9155" />
                        <circle class="cooldown-ring-circle" cx="18" cy="18" r="15.9155" />
                    </svg>
                    <span class="ability-icon"></span>
                </div>
                <div id="ability-2" class="ability-slot">
                     <svg class="cooldown-ring" viewBox="0 0 36 36">
                        <circle class="cooldown-track" cx="18" cy="18" r="15.9155" />
                        <circle class="cooldown-ring-circle" cx="18" cy="18" r="15.9155" />
                    </svg>
                    <span class="ability-icon"></span>
                </div>
                <div id="ability-3" class="ability-slot">
                     <svg class="cooldown-ring" viewBox="0 0 36 36">
                        <circle class="cooldown-track" cx="18" cy="18" r="15.9155" />
                        <circle class="cooldown-ring-circle" cx="18" cy="18" r="15.9155" />
                    </svg>
                    <span class="ability-icon"></span>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
            "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>
    
    <script type="module" src="src/client/client_main.js"></script>
</body>
</html>
--------------------------------------------------
=== END OF FILE: index.html ===


=== FILE: loadout.html ===
--------------------------------------------------
<!-- loadout.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELEMENTALS - Loadout</title>
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/loadout.css">
    <link rel="icon" href="data:,">
</head>
<body class="loadout-page">

    <div id="loadout-screen">

        <header id="loadout-header">
            <div id="loadout-manager" class="header-section">
                <select id="loadout-select-dropdown"></select>
                <input type="text" id="loadout-name-input" placeholder="New Loadout Name...">
                <button id="save-loadout-btn">Save</button>
            </div>
            <h1 class="loadout-title">LOADOUT</h1>
            <div id="nav-controls" class="header-section">
                <button id="back-to-menu-btn">Main Menu</button>
                <button id="play-game-btn" class="play-button" disabled>Play</button>
            </div>
        </header>

        <main id="loadout-main-content">
            <!-- Left Panel: Player & Equipped -->
            <div id="player-panel">
                 <div id="player-preview-container">
                    <canvas id="player-preview-canvas"></canvas>
                 </div>
                 <div id="equipped-slots-container">
                    <div class="equipped-slot" data-slot-index="0" data-slot-type="ability" title="Ability Slot 1"></div>
                    <div class="equipped-slot" data-slot-index="1" data-slot-type="ability" title="Ability Slot 2"></div>
                    <div class="equipped-slot" data-slot-index="2" data-slot-type="ability" title="Ability Slot 3"></div>
                    <div class="equipped-slot" data-slot-index="3" data-slot-type="ability" title="Ability Slot 4"></div>
                    <div class="slot-separator">+</div>
                    <div class="equipped-slot weapon-slot" data-slot-type="weapon" title="Primary Weapon">
                        <!-- This container will be populated by LoadoutUI.js -->
                    </div>
                </div>
                <div id="synergy-display">
                    <h3 id="synergy-name"></h3>
                    <p id="synergy-description"></p>
                </div>
            </div>

            <!-- Right Panel: Inventory & Details -->
            <div id="inventory-panel">
                <div class="panel-header">
                    <h2>INVENTORY</h2>
                </div>
                <div id="inventory-grid">
                    <!-- Dynamically populated inventory slots -->
                </div>
                <div id="card-details-panel">
                    <div id="details-view-2d">
                        <div id="details-content">
                            <h3 id="details-name">SELECT A CARD</h3>
                            <p id="details-element-tier">Click a card to see its details.</p>
                            <div id="details-stats">
                                <span id="details-cost"></span>
                                <span id="details-cooldown"></span>
                            </div>
                            <hr>
                            <p id="details-description"></p>
                            <p id="details-flavor-text"></p>
                        </div>
                        <div id="details-footer">
                            <button id="inspect-card-btn" disabled>Inspect</button>
                        </div>
                    </div>
                    <!-- The 3D view is now a modal -->
                </div>
            </div>
        </main>
    </div>

    <!-- Inspector Modal -->
    <div id="inspector-modal" class="inspector-modal-overlay">
        <div class="inspector-modal-content">
            <button id="inspector-modal-close-btn" class="inspector-modal-close">×</button>
            <canvas id="inspection-canvas"></canvas>
        </div>
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
        }
    }
    </script>
    <script type="module" src="src/client/ui/loadout_main.js"></script>

</body>
</html>
--------------------------------------------------
=== END OF FILE: loadout.html ===


=== FILE: .github/workflows/static.yml ===
--------------------------------------------------
# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

--------------------------------------------------
=== END OF FILE: .github/workflows/static.yml ===


=== FILE: css/card-inspector.css ===
--------------------------------------------------
.inspector-page {
    background-color: var(--color-bg-darkest);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    padding: 0;
    overflow: hidden;
}

#inspector-container {
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-rows: auto 1fr;
    grid-template-columns: 100%;
    color: var(--color-text-light);
}

#inspector-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 24px;
    background-color: var(--color-bg-dark);
    border-bottom: 1px solid var(--color-border);
    z-index: 10;
}

#inspector-header h1 {
    margin: 0;
    font-size: 1.5rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--color-accent);
}

#inspector-header button {
    padding: 8px 16px;
    font-size: 14px;
    font-weight: 600;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    border: none;
    transition: background-color 0.2s, transform 0.2s;
}
.button-secondary { background-color: var(--color-bg-light); color: var(--color-text-light); }
.button-secondary:hover { background-color: var(--color-bg-mid); }

#inspector-main {
    position: relative;
    overflow: hidden;
}

#inspector-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
}

#inspector-prompt {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: var(--color-text-dark);
    font-size: 1.2rem;
    font-weight: 600;
    pointer-events: none;
    transition: opacity 0.5s;
}
--------------------------------------------------
=== END OF FILE: css/card-inspector.css ===


=== FILE: css/common.css ===
--------------------------------------------------
/* --- Google Font Import --- */
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

/* --- GLOBAL VARIABLES & DEFAULTS --- */
:root {
    --font-primary: 'Poppins', sans-serif;
    
    --color-bg-darkest: hsl(230, 10%, 8%);
    --color-bg-dark:   hsl(230, 10%, 12%);
    --color-bg-mid:    hsl(230, 10%, 18%);
    --color-bg-light:  hsl(230, 10%, 25%);

    --color-border:    hsl(230, 10%, 10%);
    
    --color-text-light:  hsl(230, 20%, 95%);
    --color-text-mid:    hsl(230, 10%, 70%);
    --color-text-dark:   hsl(230, 10%, 50%);
    
    --color-accent:      hsl(190, 100%, 50%); /* Bright Cyan/Blue */
    --color-accent-hover:hsl(190, 100%, 60%);
    --color-accent-text: hsl(230, 20%, 5%);
    
    /* REWORKED: New, more vibrant elemental colors */
    --color-accent-fire:   hsl(25, 100%, 55%);  /* #FF771A */
    --color-accent-water:  hsl(195, 100%, 50%); /* #00A3FF */
    --color-accent-air:    hsl(180, 80%, 85%);  /* #B3FCFC */
    --color-accent-earth:  hsl(35, 45%, 50%);   /* #B39159 */
    --color-accent-utility:hsl(265, 90%, 65%);  /* #A16BFF */

    --color-delete:      hsl(0, 80%, 60%);
    --color-delete-hover:hsl(0, 80%, 70%);

    --border-radius-sm: 4px;
    --border-radius-md: 8px;
}

/* --- GLOBAL RESETS & BASE STYLES --- */
*, *::before, *::after {
    box-sizing: border-box;
}

body {
    margin: 0;
    overflow: hidden;
    background-color: var(--color-bg-darkest);
    color: var(--color-text-light);
    font-family: var(--font-primary);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    cursor: default;
}

canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* --- CUSTOM SCROLLBAR --- */
::-webkit-scrollbar {
    width: 8px;
}
::-webkit-scrollbar-track {
    background: var(--color-bg-darkest);
}
::-webkit-scrollbar-thumb {
    background: var(--color-bg-light);
    border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
    background: var(--color-bg-mid);
}

/* --- COMMON COMPONENT STYLES: MODAL --- */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: hsla(230, 20%, 5%, 0.6);
    backdrop-filter: blur(8px);
    z-index: 1000;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: modal-fade-in 0.3s ease-out;
}

@keyframes modal-fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
}

.modal-content {
    background-color: var(--color-bg-dark);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md);
    padding: 24px;
    width: 90%;
    max-width: 550px;
    color: var(--color-text-light);
    position: relative;
    box-shadow: 0 10px 30px hsla(0, 0%, 0%, 0.5);
    transform: scale(0.95);
    animation: modal-scale-up 0.3s ease-out forwards;
}

@keyframes modal-scale-up {
    from { transform: scale(0.95); }
    to { transform: scale(1); }
}

.modal-close-btn {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 28px;
    font-weight: bold;
    color: var(--color-text-dark);
    cursor: pointer;
    transition: color 0.2s, transform 0.2s;
}
.modal-close-btn:hover {
    color: var(--color-text-light);
    transform: scale(1.1);
}

.modal-content h3 {
    margin-top: 0;
    color: var(--color-accent);
    border-bottom: 1px solid var(--color-bg-light);
    padding-bottom: 12px;
    margin-bottom: 16px;
    font-size: 1.5rem;
}

#info-modal-text {
    font-family: 'Consolas', 'Courier New', monospace;
    white-space: pre-wrap;
    font-size: 13px;
    line-height: 1.7;
    margin: 0;
    color: var(--color-text-mid);
}
--------------------------------------------------
=== END OF FILE: css/common.css ===


=== FILE: css/editor.css ===
--------------------------------------------------
/* --- EDITOR CONTAINER & LAYOUT --- */
#editor-container {
    position: absolute;
    inset: 0;
    display: grid;
    grid-template-columns: 260px 1fr 320px;
    grid-template-rows: auto auto 1fr;
    grid-template-areas:
        "menu menu menu"
        "toolbar toolbar toolbar"
        "outliner viewport inspector";
    background-color: var(--color-bg-darkest);
    color: var(--color-text-light);
    z-index: 100;
}

/* --- GRID AREA ASSIGNMENTS --- */
#editor-menu-bar { grid-area: menu; }
#editor-toolbar { grid-area: toolbar; }
#editor-outliner { grid-area: outliner; }
#editor-viewport { grid-area: viewport; position: relative; overflow: hidden; }
#editor-inspector { grid-area: inspector; }

/* --- GENERAL PANEL STYLES --- */
.side-panel {
    background-color: var(--color-bg-dark);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border-right: 1px solid var(--color-border);
}
#editor-inspector { border-right: none; border-left: 1px solid var(--color-border); }

.panel-header {
    background-color: var(--color-bg-light);
    padding: 8px 12px;
    font-weight: 600;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.8px;
    border-bottom: 1px solid var(--color-border);
    flex-shrink: 0;
}

.panel-content {
    padding: 8px;
    overflow-y: auto;
    flex-grow: 1;
}

.panel-content .placeholder-text {
    color: var(--color-text-dark);
    font-size: 13px;
    text-align: center;
    margin-top: 20px;
    padding: 0 10px;
}

/* --- MENU BAR (TOP) --- */
#editor-menu-bar {
    display: flex;
    background-color: var(--color-bg-mid);
    border-bottom: 1px solid var(--color-border);
    padding: 0 5px;
    flex-shrink: 0;
}
.menu-dropdown { position: relative; }
.menu-dropdown summary {
    padding: 8px 12px;
    cursor: pointer;
    list-style: none;
    font-size: 13px;
    font-weight: 600;
    transition: background-color 0.2s;
    user-select: none;
}
.menu-dropdown summary::-webkit-details-marker { display: none; }

.menu-dropdown:hover > summary, .menu-dropdown[open] > summary {
    background-color: var(--color-accent);
    color: var(--color-accent-text);
}
.menu-content {
    position: absolute;
    top: 100%;
    left: 0;
    background-color: var(--color-bg-mid);
    border: 1px solid var(--color-border);
    box-shadow: 0 8px 20px hsla(0,0%,0%,0.4);
    min-width: 200px;
    padding: 6px;
    z-index: 1010;
    display: flex;
    flex-direction: column;
    border-radius: 0 0 var(--border-radius-md) var(--border-radius-md);
}
.menu-content button {
    background: none;
    border: none;
    color: var(--color-text-light);
    padding: 8px 12px;
    text-align: left;
    width: 100%;
    cursor: pointer;
    font-family: inherit;
    font-size: 13px;
    border-radius: var(--border-radius-sm);
}
.menu-content button:hover:not(:disabled) { background-color: var(--color-accent); color: var(--color-accent-text); }
.menu-content button:disabled { color: var(--color-text-dark); cursor: not-allowed; }
.menu-content hr { border: none; border-top: 1px solid var(--color-bg-light); margin: 6px 0; }
.checkbox-menu .checkbox-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 12px;
    cursor: pointer;
    border-radius: var(--border-radius-sm);
}
.checkbox-menu .checkbox-row:hover { background-color: var(--color-bg-light); }

/* --- TOOLBAR (BELOW MENU) --- */
#editor-toolbar {
    display: flex;
    align-items: center;
    padding: 6px;
    gap: 8px;
    background-color: var(--color-bg-dark);
    border-bottom: 1px solid var(--color-border);
}
.toolbar-group { display: flex; gap: 4px; align-items: center; }
#editor-toolbar .separator { border-right: 1px solid var(--color-border); height: 24px; }
#editor-toolbar button {
    background-color: var(--color-bg-light);
    border: 1px solid var(--color-border);
    color: var(--color-text-light);
    padding: 6px 10px;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    font-family: inherit;
    font-weight: 700;
    min-width: 32px;
    transition: background-color 0.2s, color 0.2s;
}
#editor-toolbar button:hover { background-color: var(--color-bg-mid); }
#editor-toolbar button.active { background-color: var(--color-accent); color: var(--color-accent-text); border-color: var(--color-accent); }
.snap-group input[type="number"] {
    background-color: var(--color-bg-darkest);
    border: 1px solid var(--color-border);
    color: var(--color-text-light);
    font-family: inherit;
    padding: 6px;
    border-radius: var(--border-radius-sm);
    width: 50px;
}
.snap-group label {
    font-size: 12px;
    font-weight: 600;
    color: var(--color-text-mid);
    user-select: none;
    margin-left: 8px;
    cursor: pointer;
}
.snap-group input[type="checkbox"] {
    width: auto;
    cursor: pointer;
    margin: 0;
    margin-left: 8px;
}

/* --- VIEWPORT CREATE BUTTON & MENU --- */
#create-button-container {
    position: absolute;
    top: 15px;
    left: 15px;
    z-index: 500;
}
#create-button {
    width: 44px; height: 44px;
    border-radius: 50%;
    background-color: var(--color-accent);
    color: var(--color-accent-text);
    border: none;
    font-size: 28px;
    font-weight: 700;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 4px 15px hsla(190, 100%, 50%, 0.3);
    transition: background-color 0.2s, transform 0.2s;
}
#create-button:hover { background-color: var(--color-accent-hover); transform: scale(1.05); }

.context-menu {
    position: absolute;
    top: 55px;
    left: 0;
    min-width: 220px;
    background-color: var(--color-bg-mid);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md);
    box-shadow: 0 5px 15px hsla(0,0%,0%,0.4);
    padding: 6px;
    display: flex;
    flex-direction: column;
}
.context-menu-section {
    font-size: 10px;
    text-transform: uppercase;
    color: var(--color-text-dark);
    padding: 8px 12px 4px;
    font-weight: 700;
}
.context-menu button {
    background: none; border: none; color: var(--color-text-light); padding: 8px 12px;
    text-align: left; width: 100%; cursor: pointer; font-family: inherit;
    font-size: 13px; border-radius: var(--border-radius-sm);
}
.context-menu button:hover { background-color: var(--color-accent); color: var(--color-accent-text); }

/* --- OUTLINER --- */
#outliner-content details { margin-bottom: 5px; }
#outliner-content summary {
    font-weight: 700;
    cursor: pointer;
    padding: 6px;
    border-radius: var(--border-radius-sm);
    font-size: 11px;
    text-transform: uppercase;
    color: var(--color-text-dark);
    letter-spacing: 0.5px;
}
#outliner-content summary:hover { background-color: var(--color-bg-light); }
.outliner-item {
    padding: 6px 10px;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    font-size: 13px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    transition: background-color 0.15s;
    margin-left: 10px;
}
.outliner-item:hover { background-color: var(--color-bg-light); }
.outliner-item.selected { background-color: var(--color-accent); color: var(--color-accent-text); font-weight: 600; }

/* --- INSPECTOR --- */
#inspector-content { display: flex; flex-direction: column; gap: 16px; }
.prop-group { display: flex; flex-direction: column; gap: 6px; }
#inspector-content label { font-size: 11px; color: var(--color-text-dark); text-transform: uppercase; font-weight: 600; }
#inspector-content input, #inspector-content .delete-button {
    background-color: var(--color-bg-darkest);
    border: 1px solid var(--color-border);
    color: var(--color-text-light);
    padding: 8px;
    border-radius: var(--border-radius-sm);
    font-family: inherit;
    font-size: 13px;
    width: 100%;
}
#inspector-content input:focus { border-color: var(--color-accent); outline: none; }
#inspector-content input[type="color"] { padding: 2px; height: 32px; }
.prop-input-group { display: flex; gap: 6px; }
.prop-input-group input { text-align: center; }

#inspector-content hr { border: none; border-top: 1px solid var(--color-bg-light); margin: 0; }
.delete-button {
    background-color: var(--color-delete);
    border: 1px solid var(--color-delete);
    cursor: pointer;
    font-weight: 700;
    margin-top: auto; /* Pushes to the bottom */
    transition: background-color 0.2s;
}
.delete-button:hover { background-color: var(--color-delete-hover); }
--------------------------------------------------
=== END OF FILE: css/editor.css ===


=== FILE: css/game.css ===
--------------------------------------------------
/* css/game.css */
/* --- GAMEPLAY STATE --- */
body:not(.game-active) #game-hud,
body:not(.game-active) #crosshair-container,
body:not(.game-active) #target-frame,
body:not(.game-active) #tutorial-text-container {
    display: none !important;
}

/* --- IN-GAME VFX --- */
.vfx-overlay {
    position: absolute; inset: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 99; opacity: 0;
}
#screen-overlay.active {
    opacity: 1; animation: damage-pulse 0.3s ease-out forwards;
    background-image: radial-gradient(circle at 50% 50%, transparent 60%, hsla(0, 100%, 50%, 0.7) 95%);
}
@keyframes damage-pulse {
    from { opacity: 1; transform: scale(1); }
    to { opacity: 0; transform: scale(1.2); }
}
#vfx-dash-forward.active {
    opacity: 1;
    background: radial-gradient(ellipse at center, transparent 30%, hsla(190, 100%, 70%, 0.2) 100%);
    clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);
    animation: dash-forward-zoom 0.25s ease-out forwards;
}
@keyframes dash-forward-zoom {
    from { transform: scale(0.5, 2); opacity: 1; }
    to { transform: scale(2, 2); opacity: 0; }
}
#vfx-dash-sideways::before, #vfx-dash-sideways::after {
    content: ''; position: absolute; top: 50%; height: 2px; width: 40vw;
    background: linear-gradient(to right, transparent, hsla(190, 100%, 70%, 0.9) 70%, transparent);
    opacity: 0; will-change: transform, opacity;
}
#vfx-dash-sideways.active.left-to-right::before, #vfx-dash-sideways.active.left-to-right::after { animation: whoosh-lr 0.25s ease-out forwards; }
#vfx-dash-sideways.active.right-to-left::before, #vfx-dash-sideways.active.right-to-left::after { animation: whoosh-rl 0.25s ease-out forwards; }
@keyframes whoosh-lr {
    0%   { transform: translateX(-60vw) scaleX(0.3); opacity: 0.5; }
    20%  { transform: translateX(-30vw) scaleX(1); opacity: 1; }
    100% { transform: translateX(60vw) scaleX(0.3); opacity: 0; }
}
@keyframes whoosh-rl {
    0%   { transform: translateX(60vw) scaleX(0.3); opacity: 0.5; }
    20%  { transform: translateX(30vw) scaleX(1); opacity: 1; }
    100% { transform: translateX(-60vw) scaleX(0.3); opacity: 0; }
}
#vfx-jump-wind.active {
    opacity: 0.4;
    background-image: radial-gradient(ellipse at 50% 150%, hsla(190, 100%, 80%, 0.5) 0%, transparent 60%);
    animation: jump-wind-effect 0.4s ease-in-out forwards;
}
@keyframes jump-wind-effect {
    from { opacity: 0.4; transform: scaleY(1); }
    to { opacity: 0; transform: scaleY(1.5); }
}
#vfx-ground-slam.active {
    opacity: 1;
    background: radial-gradient(ellipse at 50% 100%, hsla(190, 100%, 80%, 0.4) 0%, transparent 60%);
    animation: ground-slam-shockwave 0.4s ease-out forwards;
}
@keyframes ground-slam-shockwave {
    from { transform: scale(0); opacity: 1; }
    to { transform: scale(2); opacity: 0; }
}

#vfx-earth-buff.active {
    opacity: 1;
    background-image: radial-gradient(ellipse at center, transparent 70%, hsla(35, 45%, 50%, 0.6) 100%);
    animation: earth-buff-pulse 3s infinite ease-in-out;
    transition: opacity 0.5s ease-out;
}
@keyframes earth-buff-pulse {
    0% { transform: scale(1.0); opacity: 0.8; }
    50% { transform: scale(1.02); opacity: 1.0; }
    100% { transform: scale(1.0); opacity: 0.8; }
}


/* REWORKED: CROSSHAIR & TARGETING */
#crosshair-container {
    position: absolute;
    inset: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none;
    z-index: 10;
}

#crosshair {
    width: 4px; height: 4px;
    background-color: hsla(0, 0%, 100%, 0.8);
    border-radius: 50%;
    box-shadow: 0 0 5px hsla(0, 0%, 100%, 0.5);
    flex-shrink: 0;
}

.movement-cooldown {
    position: absolute; /* REWORKED: Position on top of each other */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 60px; height: 60px;
    opacity: 0;
    transition: opacity 0.3s ease;
}
.movement-cooldown.on-cooldown { opacity: 0.8; }
.movement-cooldown svg { width: 100%; height: 100%; }
.movement-cooldown path {
    fill: none;
    stroke-linecap: round;
    stroke-width: 8;
}
.movement-cooldown .cooldown-track {
    stroke: hsla(230, 10%, 12%, 0.7);
}
.movement-cooldown .cooldown-progress {
    stroke: var(--color-accent);
    stroke-dasharray: 157; /* pi * r (3.14 * 50) */
    stroke-dashoffset: 157; /* Starts empty */
    transition: stroke-dashoffset 0.1s linear;
}

#target-frame {
    position: absolute; border: 2px solid var(--color-accent);
    border-radius: 50%;
    box-shadow: 0 0 10px var(--color-accent), inset 0 0 10px var(--color-accent);
    display: none; transform: translate(-50%, -50%);
    transition: width 0.1s linear, height 0.1s linear;
    animation: target-frame-pulse 2s infinite ease-in-out;
}
@keyframes target-frame-pulse {
    0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    50% { opacity: 0.7; transform: translate(-50%, -50%) scale(0.95); }
}

/* REWORKED GAME HUD LAYOUT */
#game-hud {
    position: absolute; inset: 0; pointer-events: none; z-index: 10;
    font-family: var(--font-primary);
}
.hud-corner {
    position: absolute;
    display: flex;
    flex-direction: column;
    padding: 20px;
}
#hud-top-left {
    top: 0; left: 0;
    gap: 8px;
    padding: 30px;
}
#hud-top-center {
    top: 0; left: 50%; transform: translateX(-50%);
}
#hud-top-right {
    top: 0; right: 0; align-items: flex-end;
}
#hud-bottom-center {
    bottom: 0; left: 50%; transform: translateX(-50%);
    align-items: center;
}
#hud-bottom-right {
    bottom: 0; right: 0; align-items: flex-end;
    justify-content: flex-end;
}

/* HUD WIDGETS */
#minimap-canvas {
    width: 180px; height: 180px;
    background-color: hsla(230, 10%, 8%, 0.5);
    border: 2px solid var(--color-border);
    border-radius: 50%;
    box-shadow: 0 0 15px hsla(0, 0%, 0%, 0.5);
}

#enemy-counter {
    background-color: hsla(230, 10%, 8%, 0.7);
    padding: 8px 20px;
    border-radius: var(--border-radius-sm);
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--color-text-mid);
    text-shadow: 1px 1px 2px black;
    letter-spacing: 1px;
    text-transform: uppercase;
}

.resource-bar-container {
    width: 320px; height: 12px;
    background-color: var(--color-bg-dark);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-sm);
    padding: 2px;
    box-shadow: inset 0 1px 2px hsla(0,0%,0%,0.5);
}
#health-bar, #energy-bar {
    height: 100%; border-radius: 2px;
    transition: width 0.2s ease-out;
}
#health-bar { background: linear-gradient(to right, hsl(0, 100%, 60%), hsl(0, 100%, 75%)); }
#energy-bar { background: linear-gradient(to right, hsl(190, 100%, 45%), hsl(190, 100%, 65%)); }
.resource-text { display: none; }

#energy-bar-container.flash-error #energy-bar {
    animation: energy-flash-red 1s ease-out;
}

@keyframes energy-flash-red {
  16%, 50%, 83% {
    background: linear-gradient(to right, hsl(0, 100%, 60%), hsl(0, 100%, 75%));
  }
}

/* REWORKED: Abilities Container & Slots */
#abilities-container {
    display: flex; gap: 16px;
}
.ability-slot {
    width: 64px; height: 64px;
    background-color: var(--color-bg-darkest);
    border: 2px solid var(--color-bg-light);
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    position: relative; overflow: hidden;
    transition: border-color 0.2s, box-shadow 0.2s, transform 0.2s;
    box-shadow: inset 0 0 10px hsla(0,0%,0%,0.6);
}
.ability-slot.ready { border-color: var(--color-text-light); }

.ability-icon {
    width: 100%;
    height: 100%;
    z-index: 2;
    background-size: 80%;
    background-position: center;
    background-repeat: no-repeat;
    /* For loading state */
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--color-text-dark);
}

.cooldown-ring {
    position: absolute; width: 100%; height: 100%;
    transform: rotate(-90deg); z-index: 1;
}
.cooldown-ring .cooldown-track {
    stroke-width: 4;
    stroke: hsla(230, 10%, 18%, 0.8);
    fill: none;
}
.cooldown-ring-circle {
    fill: none;
    stroke-width: 5;
    stroke-linecap: round;
    stroke-dasharray: 100 100;
    stroke-dashoffset: 100; /* Starts empty */
    transition: stroke-dashoffset 0.1s linear;
}

/* Elemental Slot Styling */
.ability-slot.selected { transform: scale(1.1); }
.ability-slot.element-fire .cooldown-ring-circle { stroke: var(--color-accent-fire); }
.ability-slot.element-fire.selected { border-color: var(--color-accent-fire); box-shadow: 0 0 15px var(--color-accent-fire); }
.ability-slot.element-water .cooldown-ring-circle { stroke: var(--color-accent-water); }
.ability-slot.element-water.selected { border-color: var(--color-accent-water); box-shadow: 0 0 15px var(--color-accent-water); }
.ability-slot.element-air .cooldown-ring-circle { stroke: var(--color-accent-air); }
.ability-slot.element-air.selected { border-color: var(--color-accent-air); box-shadow: 0 0 15px var(--color-accent-air); }
.ability-slot.element-earth .cooldown-ring-circle { stroke: var(--color-accent-earth); }
.ability-slot.element-earth.selected { border-color: var(--color-accent-earth); box-shadow: 0 0 15px var(--color-accent-earth); }
.ability-slot.element-utility .cooldown-ring-circle { stroke: var(--color-accent-utility); }
.ability-slot.element-utility.selected { border-color: var(--color-accent-utility); box-shadow: 0 0 15px var(--color-accent-utility); }

.ability-slot:not([class*='element-']) .cooldown-ring-circle {
    stroke: var(--color-accent);
}
.ability-slot:not([class*='element-']).selected {
    border-color: var(--color-accent);
    box-shadow: 0 0 15px var(--color-accent);
}

.ability-slot.flash-cooldown-error {
  animation: flash-border-red 0.6s ease-out;
}

@keyframes flash-border-red {
  25%, 75% {
    border-color: hsl(0, 80%, 60%);
    box-shadow: inset 0 0 10px hsla(0,0%,0%,0.6), 0 0 15px hsl(0, 80%, 60%);
  }
}

/* NEW: Ammo Counter */
#ammo-counter {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--color-text-light);
    text-shadow: 2px 2px 5px hsla(0, 0%, 0%, 0.7);
    text-align: right;
    margin-bottom: 20px;
}
#ammo-counter.reloading #ammo-mag {
    color: var(--color-accent-fire);
    animation: ammo-reloading-pulse 1s infinite;
}
@keyframes ammo-reloading-pulse {
    50% { opacity: 0.6; }
}
#ammo-mag {
    font-size: 3rem;
    color: var(--color-accent);
}

/* --- PAUSE & DEATH SCREENS --- */
#pause-menu h2 { color: var(--color-text-light); }
#death-screen h2 { color: var(--color-accent-fire); text-shadow: 0 0 20px var(--color-accent-fire); }
#respawn-timer-text { font-size: 1.5rem; color: var(--color-text-mid); }

/* --- TUTORIAL TEXT --- */
#tutorial-text-container {
    position: absolute; bottom: 25%; left: 50%;
    transform: translateX(-50%); width: 90%; max-width: 600px;
    background-color: hsla(230, 10%, 12%, 0.8);
    border-left: 4px solid var(--color-accent);
    padding: 20px 25px; border-radius: var(--border-radius-sm);
    z-index: 50; transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    backdrop-filter: blur(5px);
}
#tutorial-text {
    color: var(--color-text-light); font-size: 1.1rem; line-height: 1.6; margin: 0;
}
#tutorial-text kbd {
    background-color: var(--color-text-light); color: var(--color-bg-darkest);
    border-radius: var(--border-radius-sm); padding: 2px 6px;
    font-weight: bold; font-size: 0.9em;
    border-bottom: 2px solid var(--color-text-mid);
}
#tutorial-text-container.level-complete {
    border-left-color: gold;
    background-color: hsla(45, 100%, 50%, 0.1);
}
#tutorial-text-container.level-complete #tutorial-text {
    font-size: 2.5rem; text-align: center; color: gold;
    font-weight: 700; text-shadow: 0 0 15px gold;
}
--------------------------------------------------
=== END OF FILE: css/game.css ===


=== FILE: css/loadout.css ===
--------------------------------------------------
/* css/loadout.css */
/* css/loadout.css */
.loadout-page {
    background-color: var(--color-bg-darkest);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
}

#loadout-screen {
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-rows: auto 1fr;
    color: var(--color-text-light);
}

/* --- HEADER --- */
#loadout-header {
    grid-row: 1;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 24px;
    background-color: var(--color-bg-dark);
    border-bottom: 1px solid var(--color-border);
    z-index: 10;
}
.header-section { flex: 1; display: flex; gap: 10px; align-items: center; }
.header-section:last-child { justify-content: flex-end; }
.header-section:first-child { justify-content: flex-start; }
#loadout-header h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; text-transform: uppercase; color: var(--color-accent); flex: 0; white-space: nowrap; padding: 0 40px;}
#loadout-manager select, #loadout-manager input { background: var(--color-bg-darkest); border: 1px solid var(--color-border); color: var(--color-text-light); padding: 8px 12px; border-radius: var(--border-radius-sm); font-family: inherit; }
#loadout-manager button, #nav-controls button { padding: 8px 16px; font-size: 14px; font-weight: 600; border-radius: var(--border-radius-sm); cursor: pointer; border: none; transition: background-color 0.2s, transform 0.2s; }
#save-loadout-btn, #play-game-btn.play-button { background-color: var(--color-accent); color: var(--color-accent-text); }
#back-to-menu-btn { background-color: var(--color-bg-light); color: var(--color-text-light); }
#play-game-btn:disabled { background-color: var(--color-bg-darkest); color: var(--color-text-dark); cursor: not-allowed; }

/* --- MAIN 2-COLUMN LAYOUT --- */
#loadout-main-content {
    grid-row: 2;
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 20px;
    padding: 20px;
    overflow: hidden;
}
#player-panel {
    background-color: var(--color-bg-dark);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md);
    display: flex;
    flex-direction: column;
    gap: 20px; 
    padding: 20px;
}

/* --- PLAYER PANEL (LEFT) --- */
#player-preview-container { flex-grow: 1; position: relative; background-color: var(--color-bg-darkest); border-radius: var(--border-radius-md); overflow: hidden; }
#player-preview-canvas { position: absolute; inset: 0; width: 100%; height: 100%; }
#equipped-slots-container { display: flex; justify-content: center; align-items: center; gap: 15px; padding: 10px 0; }

.equipped-slot {
    width: 85px;
    height: 119px;
    border-radius: var(--border-radius-sm);
    background-color: var(--color-bg-darkest);
    border: 2px dashed var(--color-bg-light);
    transition: all 0.2s;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}
.equipped-slot:hover, .equipped-slot.drag-over { border-color: var(--color-accent); background-color: hsla(190, 100%, 50%, 0.1); transform: scale(1.05); }

.equipped-slot:has(.card-item) {
    border-color: transparent;
    background-color: transparent;
}
.equipped-slot .card-item { width: 100%; height: 100%; }

/* NEW: Separator Style */
.slot-separator {
    font-size: 2rem;
    color: var(--color-text-dark);
    font-weight: 200;
    margin: 0 -5px; /* Pull it closer to the slots */
}

#synergy-display { padding: 15px; border-radius: var(--border-radius-sm); text-align: center; transition: all 0.3s; background-color: var(--color-bg-darkest); border: 1px solid var(--color-border); }
#synergy-display.synergy-valid { background: hsla(150, 70%, 40%, 0.15); border-color: hsla(150, 70%, 40%, 0.8); }
#synergy-display.synergy-invalid { background: hsla(0, 70%, 50%, 0.15); border-color: hsla(0, 70%, 50%, 0.8); }
#synergy-name { margin: 0 0 5px 0; font-size: 18px; font-weight: bold; }
#synergy-display.synergy-valid #synergy-name { color: hsl(150, 70%, 60%); }
#synergy-display.synergy-invalid #synergy-name { color: hsl(0, 70%, 60%); }
#synergy-description { margin: 0; font-size: 14px; color: var(--color-text-mid); }

/* --- INVENTORY & DETAILS PANEL (RIGHT) --- */
#inventory-panel {
    display: flex;
    flex-direction: column;
    background-color: var(--color-bg-dark);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md);
    overflow: hidden;
    transition: background-color 0.2s ease-out;
}
#inventory-panel.inventory-drag-over { background-color: var(--color-bg-mid); }
#inventory-panel .panel-header { padding: 12px 15px; border-bottom: 1px solid var(--color-border); flex-shrink: 0; }
#inventory-panel h2 { margin: 0; font-size: 1rem; text-transform: uppercase; letter-spacing: 1px; color: var(--color-text-mid); }
#inventory-grid {
    flex-grow: 1;
    overflow-y: auto;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    grid-auto-rows: 140px;
    gap: 15px;
    padding: 15px;
}
.inventory-slot { border: 1px solid var(--color-bg-light); border-radius: var(--border-radius-sm); background-color: var(--color-bg-darkest); display: flex; justify-content: center; align-items: center; }
.inventory-slot .card-item { width: 100%; height: 100%; }

/* --- CARD DETAILS SUB-PANEL --- */
#card-details-panel {
    flex-shrink: 0;
    height: 280px;
    border-top: 1px solid var(--color-border);
    background-color: var(--color-bg-dark);
    position: relative;
}
#details-view-2d { padding: 20px; display: flex; flex-direction: column; height: 100%; }
#details-content { flex-grow: 1; overflow-y: auto; }
#details-name { font-size: 1.5rem; margin: 0 0 5px 0; color: var(--color-text-light); text-shadow: 0 0 10px var(--color-accent); }
#details-element-tier { font-size: 0.9rem; color: var(--color-text-mid); margin-bottom: 10px; }
#details-stats { display: flex; gap: 20px; font-weight: bold; font-size: 0.9rem; color: var(--color-text-mid); }
#details-description { font-size: 0.95rem; line-height: 1.6; color: var(--color-text-mid); }
#details-flavor-text { font-style: italic; color: var(--color-text-dark); border-left: 3px solid var(--color-bg-light); padding-left: 10px; margin-top: 10px; font-size: 0.85rem; }
#details-footer { margin-top: auto; padding-top: 15px; }
#details-footer button { width: 100%; padding: 10px; font-size: 14px; font-weight: 600; cursor: pointer; background-color: var(--color-bg-light); color: var(--color-text-light); border: 1px solid var(--color-border); border-radius: var(--border-radius-sm); transition: all 0.2s; }
#details-footer button:not(:disabled):hover { background-color: var(--color-accent); color: var(--color-accent-text); }
#details-footer button:disabled { background-color: var(--color-bg-darkest); color: var(--color-text-dark); cursor: not-allowed; }

/* --- CARD ITEM STYLES --- */
.card-item {
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    height: 100%;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
    overflow: hidden;
    color: white;
    box-shadow: inset 0 0 20px 10px hsla(0, 0%, 0%, 0.2);
    border: 1px solid transparent;
}
.card-item.dragging { opacity: 0.5; transform: scale(0.95); }
.card-item.selected, .inventory-slot:hover .card-item { transform: scale(1.05); border-color: var(--color-accent); }

.card-item::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background-color: var(--color-text-dark);
    z-index: 2;
}
.card-item.tier-1::after { background-color: hsl(210, 80%, 60%); }
.card-item.tier-2::after { background-color: hsl(290, 80%, 65%); }
.card-item.tier-3::after { background-color: hsl(0, 80%, 60%); }

.card-item-icon {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-size: 85%;
    background-position: center;
    background-repeat: no-repeat;
    opacity: 0.8;
    transition: all 0.3s;
}
.card-item:hover .card-item-icon {
    opacity: 1;
    transform: scale(1.1);
}

.card-item-text {
    position: relative;
    z-index: 1;
    padding: 8px;
    background: linear-gradient(to top, hsla(0, 0%, 0%, 0.8), transparent);
}
.card-item-name, .card-item-type {
    display: block;
    text-align: left;
    text-shadow: 1px 1px 3px hsla(0, 0%, 0%, 0.6);
    line-height: 1.2;
}
.card-item-name {
    font-weight: 700;
    font-size: 0.8rem;
    text-transform: uppercase;
}
.card-item-type {
    font-weight: 400;
    font-size: 0.65rem;
    padding-bottom: 5px;
}

/* Elemental/Ability Card Backgrounds */
.card-item.element-fire    { background-color: hsl(25, 100%, 55%); }
.card-item.element-water   { background-color: hsl(195, 100%, 50%); }
.card-item.element-air     { background-color: hsl(180, 80%, 85%); }
.card-item.element-earth   { background-color: hsl(35, 45%, 50%); }
.card-item.element-utility { background-color: hsl(265, 90%, 65%); }

/* Weapon Card Overrides */
.card-item.type-weapon {
    background: linear-gradient(145deg, hsl(230, 10%, 28%), hsl(230, 10%, 18%));
    border: 1px solid hsl(230, 10%, 12%);
}
.card-item.type-weapon::after {
    background-color: var(--color-text-dark);
}
.card-item.type-weapon.tier-1::after { background-color: hsl(210, 10%, 60%); }
.card-item.type-weapon.tier-2::after { background-color: hsl(210, 10%, 85%); }
.card-item.type-weapon.tier-3::after { background-color: hsl(0, 0%, 100%); }

.card-item.type-weapon .card-item-icon {
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="rgba(255,255,255,0.8)"><path d="M22,4 C22,4 18,1 18,1 C18,1 14,4 14,4 C14,4 14,14 14,14 C14,14 12,16 12,16 C12,16 11,23 11,23 L13,23 L13,16 C13,16 18,16 18,16 C18,16 22,13 22,13 C22,13 22,4 22,4 Z M10,14 L10,23 L8,23 L8,14 C8,14 2,14 2,14 C2,14 2,4 2,4 C2,4 6,1 6,1 C6,1 10,4 10,4 L10,14 Z"/></svg>');
    background-size: 65%;
    opacity: 0.6;
}


/* --- INSPECTOR MODAL --- */
.inspector-modal-overlay {
    position: fixed; inset: 0; background-color: hsla(230, 20%, 5%, 0.6);
    backdrop-filter: blur(8px); z-index: 2000;
    justify-content: center; align-items: center;
    display: none;
}
.inspector-modal-overlay.active {
    display: flex;
    animation: modal-fade-in 0.3s ease-out;
}
@keyframes modal-fade-in { from { opacity: 0; } to { opacity: 1; } }

.inspector-modal-content {
    width: 90vw; height: 90vh; max-width: 1400px; max-height: 900px;
    background-color: var(--color-bg-darkest); border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md); position: relative;
    box-shadow: 0 10px 40px hsla(0, 0%, 0%, 0.5); overflow: hidden;
    animation: modal-scale-up 0.3s ease-out forwards;
}
@keyframes modal-scale-up { from { transform: scale(0.95); } to { transform: scale(1); } }
.inspector-modal-close {
    position: absolute; top: 10px; right: 15px; width: 40px; height: 40px;
    background: hsla(0, 0%, 100%, 0.1); border: none; border-radius: 50%;
    color: var(--color-text-light); font-size: 28px; font-weight: 300;
    line-height: 40px; text-align: center; cursor: pointer; z-index: 10;
    transition: background-color 0.2s, transform 0.2s;
}
.inspector-modal-close:hover { background: var(--color-accent); color: var(--color-accent-text); transform: rotate(90deg); }
#inspection-canvas { position: absolute; inset: 0; width: 100%; height: 100%; }
--------------------------------------------------
=== END OF FILE: css/loadout.css ===


=== FILE: css/menu.css ===
--------------------------------------------------
/* --- MENU SYSTEM --- */
#menu-system {
    position: absolute;
    inset: 0;
    z-index: 200;
    pointer-events: none; /* Wrapper is non-interactive */
}

.menu-screen {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    background-color: hsla(230, 10%, 8%, 0.7);
    backdrop-filter: blur(10px);
    color: var(--color-text-light);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    pointer-events: auto; /* Individual screens are interactive */
    animation: menu-fade-in 0.5s ease-out;
}

@keyframes menu-fade-in {
    from { opacity: 0; transform: scale(0.98); }
    to { opacity: 1; transform: scale(1); }
}

.menu-screen h1, .menu-screen h2 {
    margin: 0 0 50px 0;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
}

.menu-screen h1 {
    font-size: 6rem;
    color: var(--color-accent);
    text-shadow: 0 0 20px hsla(190, 100%, 50%, 0.5), 0 0 40px hsla(190, 100%, 50%, 0.3);
}

.menu-screen h2 {
    font-size: 4rem;
    color: var(--color-text-light);
    text-shadow: 0 0 10px hsla(0, 0%, 100%, 0.2);
}

.menu-options {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-top: 20px;
}

.menu-screen button {
    padding: 14px 30px;
    font-size: 1.2rem;
    font-weight: 600;
    font-family: inherit;
    background-color: var(--color-bg-mid);
    color: var(--color-text-light);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-sm);
    min-width: 300px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
}

.menu-screen button:not(:disabled):hover {
    background-color: var(--color-accent);
    border-color: var(--color-accent-hover);
    color: var(--color-accent-text);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px hsla(190, 100%, 50%, 0.2);
}

.menu-screen button:disabled {
    background-color: var(--color-bg-light);
    color: var(--color-text-dark);
    cursor: not-allowed;
}

/* --- LEVEL SELECT SPECIFICS --- */
#level-list {
    width: 90%;
    max-width: 450px;
    max-height: 50vh;
    overflow-y: auto;
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius-md);
    padding: 10px;
    background-color: var(--color-bg-dark);
    margin-bottom: 20px;
}

#level-list button {
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 10px;
}
#level-list button:last-child {
    margin-bottom: 0;
}

.back-button {
    margin-top: 20px;
    background-color: var(--color-bg-light) !important;
}

.back-button:hover {
    background-color: var(--color-text-dark) !important;
    border-color: var(--color-text-dark) !important;
    color: var(--color-text-light) !important;
    box-shadow: none !important;
}
--------------------------------------------------
=== END OF FILE: css/menu.css ===


=== FILE: data/abilities.json ===
--------------------------------------------------
{
    "WEAPON_001": {
        "id": "WEAPON_001",
        "name": "Katana",
        "type": "Weapon",
        "element": "Utility",
        "tier": 3,
        "description": "A sharp, reliable blade for close-quarters combat. Does not consume energy.",
        "flavor": "An elegant weapon for a more civilized age. A very, very close-range age."
    },
    "WEAPON_REVOLVER": {
        "id": "WEAPON_REVOLVER",
        "name": "Revolver",
        "type": "Weapon",
        "element": "Fire",
        "tier": 2,
        "description": "A powerful handgun with 6 rounds. Press [R] to reload.",
        "flavor": "Six shots. More than enough to kill anything that moves."
    },
    "FIRE_001": {
        "id": "FIRE_001",
        "name": "Fireball",
        "type": "Ability",
        "element": "Fire",
        "tier": 1,
        "energyCost": 100,
        "cooldown": 0.5,
        "description": "Launch a sphere of raw flame that explodes on impact, leaving a burning area.",
        "flavor": "Simple, effective, and very, very hot."
    },
    "FIRE_002": {
        "id": "FIRE_002",
        "name": "Fireflies",
        "type": "Ability",
        "element": "Fire",
        "tier": 2,
        "energyCost": 300,
        "cooldown": 10.0,
        "description": "Release a swarm of homing cinders that seek out a locked-on target.",
        "flavor": "Why aim when they can do it for you?"
    },
    "EARTH_001": {
        "id": "EARTH_001",
        "name": "Stone Plating",
        "type": "Ability",
        "element": "Earth",
        "tier": 2,
        "energyCost": 500,
        "cooldown": 30.0,
        "description": "Hit hard and absorb damage at the cost of slower movement",
        "flavor": "Patience is a virtue. So is being made of rock."
    },
    "WATER_001": {
        "id": "WATER_001",
        "name": "Wave Power",
        "type": "Ability",
        "element": "Water",
        "tier": 2,
        "energyCost": 400,
        "cooldown": 8.0,
        "description": "When used on the ground, release a forceful wave in front of you that knocks enemies back.",
        "flavor": "Get out of the way."
    }
}
--------------------------------------------------
=== END OF FILE: data/abilities.json ===


=== FILE: data/player-profile.json ===
--------------------------------------------------
{
  "inventory": [
    "WEAPON_001",
    "WEAPON_REVOLVER",
    "FIRE_001",
    "FIRE_002",
    "EARTH_001",
    "WATER_001"
  ],
  "savedLoadouts": {
    "My First Build": {
      "name": "My First Build",
      "weapon": "WEAPON_001",
      "cards": [
        "FIRE_001",
        "FIRE_002",
        "EARTH_001",
        "WATER_001"
      ]
    },
    "Gunslinger": {
      "name": "Gunslinger",
      "weapon": "WEAPON_REVOLVER",
      "cards": [
        "FIRE_001",
        null,
        null,
        null
      ]
    }
  },
  "activeLoadoutName": "My First Build"
}
--------------------------------------------------
=== END OF FILE: data/player-profile.json ===


=== FILE: levels/level-stadium.json ===
--------------------------------------------------
{
  "name": "Corrupt Arena",
  "spawnPoint": {
    "x": 0,
    "y": 3,
    "z": 0
  },
  "deathSpawnPoint": {
    "x": 0,
    "y": 3,
    "z": 0
  },
  "settings": {
    "backgroundColor": "0x1d2938",
    "fogColor": "0x1d2938",
    "fogNear": 50,
    "fogFar": 250,
    "ambientLight": {
      "color": "0x607080",
      "intensity": 0.8
    },
    "directionalLights": [
      {
        "color": "0xffffff",
        "intensity": 1.5,
        "position": {
          "x": 0,
          "y": 100,
          "z": 0
        },
        "targetPosition": {
          "x": 0,
          "y": 0,
          "z": 0
        }
      }
    ]
  },
  "objects": [
    {
      "type": "Plane",
      "name": "Ground Plane",
      "size": [
        250,
        250
      ],
      "position": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "rotation": {
        "x": -90,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x334455"
      },
      "physics": {
        "mass": 0
      },
      "editorSelectable": false
    },
    {
      "type": "Box",
      "name": "Arena_Playfield",
      "size": [
        110,
        1,
        70
      ],
      "position": {
        "x": 0,
        "y": 0.5,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x4CAF50"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier1_Z_Positive",
      "size": [
        130,
        2,
        20
      ],
      "position": {
        "x": 0,
        "y": 8,
        "z": 45
      },
      "rotation": {
        "x": -29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x607D8B"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier1_Z_Negative",
      "size": [
        130,
        2,
        20
      ],
      "position": {
        "x": 0,
        "y": 8,
        "z": -45
      },
      "rotation": {
        "x": 29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x607D8B"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier1_X_Positive",
      "size": [
        20,
        2,
        70
      ],
      "position": {
        "x": 65,
        "y": 8,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 29.999999999999993
      },
      "material": {
        "color": "0x607D8B"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier1_X_Negative",
      "size": [
        20,
        2,
        70
      ],
      "position": {
        "x": -65,
        "y": 8,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": -29.999999999999993
      },
      "material": {
        "color": "0x607D8B"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier2_Z_Positive",
      "size": [
        150,
        2,
        20
      ],
      "position": {
        "x": 0,
        "y": 18,
        "z": 55
      },
      "rotation": {
        "x": -29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x455A64"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier2_Z_Negative",
      "size": [
        150,
        2,
        20
      ],
      "position": {
        "x": 0,
        "y": 18,
        "z": -55
      },
      "rotation": {
        "x": 29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x455A64"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier2_X_Positive",
      "size": [
        20,
        2,
        70
      ],
      "position": {
        "x": 75,
        "y": 18,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 29.999999999999993
      },
      "material": {
        "color": "0x455A64"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Stand_Tier2_X_Negative",
      "size": [
        20,
        2,
        70
      ],
      "position": {
        "x": -75,
        "y": 18,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": -29.999999999999993
      },
      "material": {
        "color": "0x455A64"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "OuterWall_Z_Positive",
      "size": [
        190,
        64,
        4
      ],
      "position": {
        "x": 0,
        "y": 32,
        "z": 80
      },
      "rotation": {
        "x": 45.00000000000001,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x263238"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "OuterWall_Z_Negative",
      "size": [
        190,
        64,
        4
      ],
      "position": {
        "x": 0,
        "y": 32,
        "z": -80
      },
      "rotation": {
        "x": -45.00000000000001,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x263238"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "OuterWall_X_Positive",
      "size": [
        4,
        64,
        160
      ],
      "position": {
        "x": 95,
        "y": 32,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": -45.00000000000001
      },
      "material": {
        "color": "0x263238"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "OuterWall_X_Negative",
      "size": [
        4,
        64,
        160
      ],
      "position": {
        "x": -95,
        "y": 32,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 45.00000000000001
      },
      "material": {
        "color": "0x263238"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Roof",
      "size": [
        192,
        4,
        162
      ],
      "position": {
        "x": 0,
        "y": 50,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x1A2228"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Divider_Z_Positive",
      "size": [
        2,
        25,
        20
      ],
      "position": {
        "x": 0,
        "y": 18,
        "z": 55
      },
      "rotation": {
        "x": -29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x37474F"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Divider_Z_Negative",
      "size": [
        2,
        25,
        20
      ],
      "position": {
        "x": 0,
        "y": 18,
        "z": -55
      },
      "rotation": {
        "x": 29.999999999999996,
        "y": 0,
        "z": 0
      },
      "material": {
        "color": "0x37474F"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Divider_X_Positive",
      "size": [
        20,
        25,
        2
      ],
      "position": {
        "x": 75,
        "y": 18,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": 29.999999999999993
      },
      "material": {
        "color": "0x37474F"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Divider_X_Negative",
      "size": [
        20,
        25,
        2
      ],
      "position": {
        "x": -75,
        "y": 18,
        "z": 0
      },
      "rotation": {
        "x": 0,
        "y": 0,
        "z": -29.999999999999993
      },
      "material": {
        "color": "0x37474F"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Center_Cover",
      "size": [
        20,
        4,
        20
      ],
      "position": {
        "x": 0,
        "y": 2,
        "z": 0
      },
      "material": {
        "color": "0x546E7A"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Corner_Cover_PZ_PX",
      "size": [
        8,
        3,
        8
      ],
      "position": {
        "x": 40,
        "y": 1.5,
        "z": 25
      },
      "material": {
        "color": "0x546E7A"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Corner_Cover_PZ_NX",
      "size": [
        8,
        3,
        8
      ],
      "position": {
        "x": -40,
        "y": 1.5,
        "z": 25
      },
      "material": {
        "color": "0x546E7A"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Corner_Cover_NZ_PX",
      "size": [
        8,
        3,
        8
      ],
      "position": {
        "x": 40,
        "y": 1.5,
        "z": -25
      },
      "material": {
        "color": "0x546E7A"
      },
      "physics": {
        "mass": 0
      }
    },
    {
      "type": "Box",
      "name": "Corner_Cover_NZ_NX",
      "size": [
        8,
        3,
        8
      ],
      "position": {
        "x": -40,
        "y": 1.5,
        "z": -25
      },
      "material": {
        "color": "0x546E7A"
      },
      "physics": {
        "mass": 0
      }
    }
  ],
  "enemies": [
    {
      "type": "Dummy",
      "position": {
        "x": 20,
        "y": 3,
        "z": 0
      }
    },
    {
      "type": "Dummy",
      "position": {
        "x": -20,
        "y": 3,
        "z": 0
      }
    },
    {
      "type": "Dummy",
      "position": {
        "x": 50,
        "y": 12,
        "z": 25
      }
    },
    {
      "type": "Dummy",
      "position": {
        "x": -50,
        "y": 12,
        "z": 25
      }
    },
    {
      "type": "Dummy",
      "position": {
        "x": 50,
        "y": 12,
        "z": -25
      }
    },
    {
      "type": "Dummy",
      "position": {
        "x": -50,
        "y": 12,
        "z": -25
      }
    },
    {
      "type": "Dummy",
      "position": {
        "x": 0,
        "y": 22,
        "z": 45
      }
    },
    {
      "type": "Dummy",
      "position": {
        "x": 0,
        "y": 22,
        "z": -45
      }
    }
  ],
  "triggers": [],
  "deathTriggers": []
}
--------------------------------------------------
=== END OF FILE: levels/level-stadium.json ===


=== FILE: levels/level-tutorial.json ===
--------------------------------------------------
{
    "name": "Tutorial",
    "spawnPoint": { "x": 0, "y": 2, "z": 0 },
    "deathSpawnPoint": { "x": 0, "y": 2, "z": 0 },
    "settings": {
        "backgroundColor": "0x19142B",
        "fogColor": "0x19142B",
        "fogNear": 30,
        "fogFar": 200,
        "ambientLight": {
            "color": "0x6A4C8A",
            "intensity": 0.8
        },
        "directionalLights": [
            {
                "color": "0xFF8C4C",
                "intensity": 6.0,
                "position": { "x": -150, "y": 80, "z": -50 },
                "targetPosition": { "x": 0, "y": 0, "z": 0 }
            }
        ]
    },
    "objects": [
        { "type": "Box", "name": "Start_Platform", "size": [10, 2, 10], "position": { "x": 0, "y": 0, "z": 0 }, "material": {"color": "0x445566"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Jump_Platform_1", "size": [6, 2, 6], "position": { "x": 0, "y": 0, "z": 15 }, "material": {"color": "0x445566"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Jump_Platform_2", "size": [6, 2, 6], "position": { "x": 0, "y": 4, "z": 30 }, "material": {"color": "0x445566"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Dash_Platform_1", "size": [6, 2, 6], "position": { "x": 0, "y": 4, "z": 50 }, "material": {"color": "0x445566"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Slam_Tower_Base", "size": [8, 10, 8], "position": { "x": 20, "y": 5, "z": 50 }, "material": {"color": "0x5A5A5A"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Slam_Tower_Ledge", "size": [4, 2, 4], "position": { "x": 20, "y": 12, "z": 45 }, "material": {"color": "0x555555"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Slam_Tower_Top", "size": [8, 2, 8], "position": { "x": 20, "y": 18, "z": 50 }, "material": {"color": "0x445566"}, "physics": {"mass": 0}},
        { "type": "Box", "name": "Arena_Platform", "size": [30, 2, 30], "position": { "x": 20, "y": -2, "z": 80 }, "material": {"color": "0x455A64"}, "physics": {"mass": 0}}
    ],
    "enemies": [
        { "type": "Dummy", "position": { "x": 15, "y": 1, "z": 85 }},
        { "type": "Dummy", "position": { "x": 25, "y": 1, "z": 85 }},
        { "type": "Dummy", "position": { "x": 20, "y": 1, "z": 95 }}
    ],
    "triggers": [
        { "type": "Trigger", "name": "Move_Tuto", "position": {"x": 0, "y": 3, "z": 2}, "size": [10, 5, 4], "message": "Use <kbd>WASD</kbd> to move and your <kbd>Mouse</kbd> to look around.", "duration": 8, "color": "0x2ed573"},
        { "type": "Trigger", "name": "Jump_Tuto", "position": {"x": 0, "y": 3, "z": 10}, "size": [8, 5, 4], "message": "Press <kbd>Space</kbd> to jump across the gap.", "duration": 6, "color": "0x2ed573"},
        { "type": "Trigger", "name": "DoubleJump_Tuto", "position": {"x": 0, "y": 3, "z": 22}, "size": [8, 5, 4], "message": "This gap is higher. Press <kbd>Space</kbd> again in mid-air to double jump.", "duration": 8, "color": "0x2ed573"},
        { "type": "Trigger", "name": "Dash_Tuto", "position": {"x": 0, "y": 7, "z": 40}, "size": [8, 5, 4], "message": "Double-tap a movement key (<kbd>W</kbd>,<kbd>A</kbd>,<kbd>S</kbd>, or <kbd>D</kbd>) to dash.", "duration": 8, "color": "0x2ed573"},
        { "type": "Trigger", "name": "Slam_Tuto", "position": {"x": 20, "y": 15, "z": 50}, "size": [10, 10, 10], "message": "Get to the top of the tower, then jump and hold <kbd>L-Shift</kbd> in mid-air to ground slam onto the arena below.", "duration": 10, "color": "0x2ed573"},
        { "type": "Trigger", "name": "Combat_Tuto", "position": {"x": 20, "y": 2, "z": 70}, "size": [30, 8, 4], "message": "Destroy the dummies to complete the tutorial. <kbd>LMB</kbd> to attack, <kbd>RMB</kbd> to use abilities. <kbd>1-4</kbd> to select abilities.", "duration": 10, "color": "0xff4757"}
    ],
    "deathTriggers": [
        { "type": "DeathTrigger", "name": "Death_Zone", "position": { "x": 10, "y": -15, "z": 50 }, "size": [100, 2, 120] }
    ]
}
--------------------------------------------------
=== END OF FILE: levels/level-tutorial.json ===


=== FILE: levels/manifest.json ===
--------------------------------------------------
[
  {
    "name": "Tutorial",
    "path": "./levels/level-tutorial.json"
  },
  {
    "name": "Corrupt Arena",
    "path": "./levels/level-stadium.json"
  }
]
--------------------------------------------------
=== END OF FILE: levels/manifest.json ===


=== FILE: src/client/client_main.js ===
--------------------------------------------------
// src/client/client_main.js
import * as THREE from 'three';
import { Renderer } from '../core/Renderer.js';
import { Physics } from '../core/Physics.js';
import { InputManager } from '../core/InputManager.js';
import { AssetManager } from '../core/AssetManager.js';
import { Game } from '../game/Game.js';
import { UIManager } from './ui/UIManager.js';
import { VFXManager } from './rendering/VFXManager.js';
import { VFXSystem } from './systems/VFXSystem.js';
import { WorldUISystem } from './systems/WorldUISystem.js';
import { PhysicsSyncSystem } from '../game/systems/PhysicsSyncSystem.js';
import { AbilityIconService } from './ui/AbilityIconService.js';

class App {
    constructor() {
        this.clock = new THREE.Clock();
        this.core = {};
        this.game = null;
        this.ui = null;
        this.vfxManager = null;
        this.vfxSystem = null;
        this.worldUISystem = null;
        this.physicsSyncSystem = null;
        this.abilityIconService = null;
    }

    async init() {
        // 1. Initialize Core Engine Modules
        const canvas = document.getElementById('game-canvas');
        this.core.renderer = new Renderer(canvas);
        this.core.physics = new Physics();
        this.core.input = new InputManager();
        this.core.assets = new AssetManager();
        
        // 2. Initialize UI & VFX Managers
        this.abilityIconService = new AbilityIconService();
        this.ui = new UIManager(this.abilityIconService);
        this.vfxManager = new VFXManager(this.core.renderer.scene);
        
        // 3. Initialize Client-side Systems
        this.physicsSyncSystem = new PhysicsSyncSystem();
        this.worldUISystem = new WorldUISystem(this.core.renderer.scene);
        
        // 4. Initialize Game State Manager
        this.game = new Game(this.core, this.ui);

        // 5. Hook up client-side systems to game events
        this.game.on('worldCreated', (world) => {
            if (this.vfxSystem) this.vfxSystem.dispose();
            
            this.vfxSystem = new VFXSystem(world, this.vfxManager);
            this.worldUISystem.registerWorld(world);
        });

        // 6. Load initial assets, set up game, start loop
        await this.game.init();

        this.core.renderer.renderer.setAnimationLoop(() => this.animate());
    }

    animate() {
        const deltaTime = this.clock.getDelta();
        
        // 1. Process inputs
        if (this.game.world?.player) {
            this.game.playerController.update(deltaTime);
        }

        // 2. Update game logic
        if (this.game.world) {
            this.game.update(deltaTime);
        }

        // 3. Step physics
        this.core.physics.update(deltaTime);
        
        // 4. Sync visuals
        if (this.game.world) {
            this.physicsSyncSystem.update(this.game.world);
        }

        // 5. Update client systems & UI
        this.vfxManager.update(deltaTime);
        this.vfxSystem?.update(deltaTime);
        this.worldUISystem?.update(deltaTime);
        this.ui.update(this.game);

        // 6. Render
        this.core.renderer.render();

        // 7. Reset input deltas
        this.core.input.update();
    }
}

const app = new App();
window.app = app; 
app.init().catch(err => console.error("Application failed to initialize:", err));
--------------------------------------------------
=== END OF FILE: src/client/client_main.js ===


=== FILE: src/client/entities/PlayerController.js ===
--------------------------------------------------
// src/client/entities/PlayerController.js

import * as THREE from 'three';
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Handles client-side player input and translates it into commands for the player entity.
 * This class acts as the bridge between the InputManager and the player's state/actions.
 */
export class PlayerController {
    constructor(inputManager) {
        this.input = inputManager;
        this.player = null; // Will be attached by the game state

        // --- Internal State for Input Processing ---
        this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
        this.keyLastPress = {};
        this.keyPreviousState = {};
        
        // --- PERFORMANCE: Reusable Vectors ---
        this._forward = new THREE.Vector3();
        this._right = new THREE.Vector3();
        this._moveDirection = new THREE.Vector3();
        this._upVector = new THREE.Vector3(0, 1, 0);
        
        // --- Event Handlers ---
        this._onSinglePress = this._onSinglePress.bind(this);
    }

    /**
     * Attaches the controller to a specific player entity.
     * @param {Player} player - The player entity to control.
     */
    attach(player) {
        this.player = player;
        // Sync the controller's euler angles with the player's camera on attach
        this.euler.setFromQuaternion(this.player.camera.quaternion);
        this.input.on('singlePress', this._onSinglePress);
    }

    /**
     * Detaches the controller from the player entity.
     */
    detach() {
        this.input.off('singlePress', this._onSinglePress);
        this.player = null;
    }

    /**
     * Called every frame to process inputs and update the attached player.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    update(deltaTime) {
        if (!this.player || this.player.isDead || !document.pointerLockElement) {
            return;
        }

        this._handleLook();
        this._handleMovement(deltaTime);
        this._handleActions();
    }

    /**
     * Processes mouse movement to update the player's view direction.
     */
    _handleLook() {
        const PI_2 = Math.PI / 2;
        this.euler.y -= this.input.mouse.movementX * 0.002;
        this.euler.x -= this.input.mouse.movementY * 0.002;
        this.euler.x = Math.max(-PI_2, Math.min(PI_2, this.euler.x));
        
        this.player.setLookDirection(this.euler);
    }

    /**
     * Processes keyboard inputs for movement, jumping, and dashing.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    _handleMovement(deltaTime) {
        const xInput = (this.input.keys['KeyD'] ? 1 : 0) - (this.input.keys['KeyA'] ? 1 : 0);
        const zInput = (this.input.keys['KeyW'] ? 1 : 0) - (this.input.keys['KeyS'] ? 1 : 0);

        this.player.camera.getWorldDirection(this._forward);
        this._forward.y = 0;
        this._forward.normalize();
        
        // The "right" vector is the cross product of forward and up.
        this._right.crossVectors(this._forward, this._upVector).normalize();

        this._moveDirection.set(0, 0, 0);
        if (zInput) this._moveDirection.add(this._forward.clone().multiplyScalar(zInput));
        if (xInput) this._moveDirection.add(this._right.clone().multiplyScalar(xInput));
        
        if (this._moveDirection.lengthSq() > 0) {
            this._moveDirection.normalize();
        }

        this.player.setMoveDirection(this._moveDirection);

        this._handleDashInput();

        if (this.input.keys['ShiftLeft']) {
            this.player.requestSlam(true);
        } else {
            this.player.requestSlam(false);
        }
    }

    /**
     * Checks for double-tap inputs to trigger a dash.
     */
    _handleDashInput() {
        const now = performance.now();
        ['KeyW', 'KeyA', 'KeyS', 'KeyD'].forEach(key => {
            const isPressed = this.input.keys[key];
            if (isPressed && !this.keyPreviousState[key]) {
                if (now - (this.keyLastPress[key] || 0) < GAME_CONFIG.PLAYER.DOUBLE_TAP_WINDOW) {
                    // Pass the current intended move direction to the dash function
                    this.player.dash(this._moveDirection);
                }
                this.keyLastPress[key] = now;
            }
            this.keyPreviousState[key] = isPressed;
        });
    }
    
    _onSinglePress(event) {
        if (!this.player || this.player.isDead) return;
        
        if (event.code === 'Space') {
            this.player.jump();
        }
        
        if (event.code === 'KeyR') {
            this.player.reloadWeapon();
        }

        if (event.code === 'KeyF') {
            this.player.inspectWeapon();
        }
    }

    /**
     * Processes mouse clicks and number keys for attacks and ability selection.
     */
    _handleActions() {
        if (this.input.mouse.leftClick) {
            this.player.weapon?.attack();
        }

        if (this.input.mouse.rightClick) {
            this.player.useSelectedAbility();
        }

        for (let i = 1; i <= 4; i++) {
            if (this.input.keys[`Digit${i}`]) {
                this.player.selectAbility(i - 1);
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/client/entities/PlayerController.js ===


=== FILE: src/client/rendering/BulletTracer.js ===
--------------------------------------------------
import * as THREE from 'three';

export class BulletTracer {
    constructor({ scene, weapon, hitPoint }) {
        this.scene = scene;
        this.lifetime = 0.2; // Very short-lived
        this.elapsedTime = 0;

        const startPoint = new THREE.Vector3(0, 0, -0.27);
        weapon.mesh.localToWorld(startPoint);
        
        const distance = startPoint.distanceTo(hitPoint);
        const direction = new THREE.Vector3().subVectors(hitPoint, startPoint).normalize();
        
        const material = new THREE.MeshBasicMaterial({ color: 0xffffaf, transparent: true, opacity: 0.8 });
        const geometry = new THREE.CylinderGeometry(0.01, 0.01, distance, 4);
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(startPoint).add(direction.clone().multiplyScalar(distance / 2));
        
        const orientation = new THREE.Matrix4();
        const offsetRotation = new THREE.Matrix4();
        orientation.lookAt(startPoint, hitPoint, new THREE.Object3D().up);
        offsetRotation.makeRotationX(Math.PI / 2);
        orientation.multiply(offsetRotation);
        this.mesh.quaternion.setFromRotationMatrix(orientation);

        this.scene.add(this.mesh);
    }

    update(deltaTime) {
        this.elapsedTime += deltaTime;
        if (this.elapsedTime >= this.lifetime) {
            this.cleanup();
            return false; // Signal to VFXManager to remove
        }
        this.mesh.material.opacity = 1.0 - (this.elapsedTime / this.lifetime);
        return true;
    }

    cleanup() {
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/BulletTracer.js ===


=== FILE: src/client/rendering/CardObject.js ===
--------------------------------------------------
import * as THREE from 'three';
import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
import { ShaderLib } from './shaders/ShaderLib.js';

export class CardObject {
    constructor(cardData, faceMaterial, backMaterial) {
        this.cardData = cardData;
        this.faceMaterial = faceMaterial;
        this.backMaterial = backMaterial;

        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4, metalness: 0.2 });
        const geometry = new RoundedBoxGeometry(1.25, 1.75, 0.02, 5, 0.04);
        this.mesh = new THREE.Mesh(geometry, [
            bodyMaterial, bodyMaterial, bodyMaterial, bodyMaterial,
            this.faceMaterial, this.backMaterial,
        ]);
    }

    static async create(cardData) {
        const [
            vertexShader, fragShaderSource, backVertexShader, backFragmentShader
        ] = await Promise.all([
            fetch('./src/client/rendering/shaders/card.vert').then(res => res.text()),
            fetch('./src/client/rendering/shaders/card.frag').then(res => res.text()),
            fetch('./src/client/rendering/shaders/card_back.vert').then(res => res.text()),
            fetch('./src/client/rendering/shaders/card_back.frag').then(res => res.text())
        ]);
        
        const finalFragmentShader = ShaderLib.noise + '\n' + fragShaderSource;
        const finalBackFragmentShader = ShaderLib.noise + '\n' + backFragmentShader;
        
        const elementMap = { Fire: 0, Water: 1, Air: 2, Earth: 3, Utility: 4 };
        const elementColors = { Fire: new THREE.Color('#FF771A'), Water: new THREE.Color('#00A3FF'), Air: new THREE.Color('#B3FCFC'), Earth: new THREE.Color('#B39159'), Utility: new THREE.Color('#A16BFF'), Default: new THREE.Color('#FFFFFF')};

        const elementId = elementMap[cardData.element] ?? 5;
        const elementColor = elementColors[cardData.element] || elementColors.Default;
        const textTexture = new THREE.CanvasTexture(await this.createTextCanvas(cardData));
        textTexture.wrapS = THREE.ClampToEdgeWrapping;
        textTexture.wrapT = THREE.ClampToEdgeWrapping;

        const faceMaterial = new THREE.ShaderMaterial({ vertexShader, fragmentShader: finalFragmentShader, uniforms: { uTime: { value: 0 }, uElementColor: { value: elementColor }, uElementId: { value: elementId }, uTextTexture: { value: textTexture }}, transparent: true });
        const backMaterial = new THREE.ShaderMaterial({ vertexShader: backVertexShader, fragmentShader: finalBackFragmentShader, uniforms: { uTime: { value: 0 }, uElementColor: { value: elementColor }} });
        
        return new CardObject(cardData, faceMaterial, backMaterial);
    }

    static async createTextCanvas(cardData) {
        const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d'), w = 512, h = 717;
        canvas.width = w; canvas.height = h;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.textAlign = 'center';
        ctx.font = 'bold 50px Poppins'; ctx.textBaseline = 'top'; ctx.fillText(cardData.name, w / 2, 50);
        ctx.textAlign = 'left';
        
        // REWORK: Reduced font size and line height for description
        ctx.font = '26px Poppins';
        this.wrapText(ctx, cardData.description || '', 60, 480, 400, 32);

        ctx.font = 'bold 32px Poppins'; ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        const statsY = 620;
        this.drawLightningIcon(ctx, 60, statsY + 16);
        ctx.fillText(cardData.energyCost || '0', 90, statsY);
        this.drawClockIcon(ctx, w - 140, statsY + 16);
        ctx.textAlign = 'right';
        ctx.fillText(`${cardData.cooldown || '0'}s`, w - 60, statsY);
        return canvas;
    }

    static wrapText(ctx, text, x, y, maxW, lineH) {
        const words = text.split(' '); let line = '';
        for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            if (ctx.measureText(testLine).width > maxW && n > 0) {
                ctx.fillText(line, x, y); line = words[n] + ' '; y += lineH;
            } else { line = testLine; }
        }
        ctx.fillText(line, x, y);
    }

    static drawLightningIcon(ctx, x, y) {
        ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 3; ctx.beginPath();
        ctx.moveTo(x + 6, y - 12); ctx.lineTo(x - 2, y); ctx.lineTo(x + 4, y); ctx.lineTo(x - 4, y + 12);
        ctx.stroke(); ctx.restore();
    }

    static drawClockIcon(ctx, x, y) {
        ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 3; ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2); ctx.moveTo(x, y); ctx.lineTo(x, y - 6); ctx.moveTo(x, y); ctx.lineTo(x + 4, y);
        ctx.stroke(); ctx.restore();
    }
    
    update(deltaTime) {
        if (this.faceMaterial) this.faceMaterial.uniforms.uTime.value += deltaTime;
        if (this.backMaterial) this.backMaterial.uniforms.uTime.value += deltaTime;
    }

    dispose() {
        this.mesh.geometry.dispose();
        if (this.faceMaterial) {
            this.faceMaterial.uniforms.uTextTexture.value?.dispose();
            this.faceMaterial.dispose();
        }
        this.backMaterial?.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/CardObject.js ===


=== FILE: src/client/rendering/CardParticleSystem.js ===
--------------------------------------------------
import * as THREE from 'three';

export class CardParticleSystem {
    constructor(scene, element) {
        this.scene = scene;
        this.element = element;
        this.isStreamType = ['Air', 'Water'].includes(this.element);

        if (this.isStreamType) {
            this.streamGroup = new THREE.Group();
            this.streams = [];
            const streamMaterial = new THREE.MeshBasicMaterial({ map: this.createStreamTexture(), blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, color: this.element === 'Air' ? 0xB3FCFC : 0x00A3FF });
            const streamGeometry = new THREE.PlaneGeometry(1, 1);
            for (let i = 0; i < 50; i++) {
                const streamMesh = new THREE.Mesh(streamGeometry, streamMaterial.clone());
                streamMesh.userData.velocity = new THREE.Vector3();
                streamMesh.userData.phase = Math.random() * Math.PI * 2;
                this.initStreamParticle(streamMesh);
                this.streams.push(streamMesh);
                this.streamGroup.add(streamMesh);
            }
            this.scene.add(this.streamGroup);
        } else {
            this.particleCount = 50;
            this.velocities = [];
            this.lifetimes = [];
            const elementColors = { Fire: '#FF771A', Earth: '#B39159', Utility: '#A16BFF', Default: '#FFFFFF' };
            this.color = elementColors[element] || elementColors.Default;
            const positions = new Float32Array(this.particleCount * 3);
            const opacities = new Float32Array(this.particleCount);
            for (let i = 0; i < this.particleCount; i++) this.initPointParticle(i, positions, opacities);
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('alpha', new THREE.BufferAttribute(opacities, 1));
            const material = new THREE.PointsMaterial({ color: this.color, size: 0.08, map: this.createPointTexture(), blending: THREE.AdditiveBlending, depthWrite: false, transparent: true });
            this.points = new THREE.Points(geometry, material);
            this.scene.add(this.points);
        }
    }

    initPointParticle(i, positions, opacities) {
        const i3 = i * 3;
        positions[i3] = (Math.random() - 0.5) * 2;
        positions[i3 + 1] = (Math.random() - 0.5) * 1.5 - 1.0;
        positions[i3 + 2] = (Math.random() - 0.5) * 0.5;
        this.velocities[i] = new THREE.Vector3((Math.random() - 0.5) * 0.1, Math.random() * 0.4 + 0.2, (Math.random() - 0.5) * 0.1);
        this.lifetimes[i] = Math.random() * 3.0 + 1.0;
        opacities[i] = 1.0;
    }

    initStreamParticle(stream) {
        const lifetime = Math.random() * 3.0 + 2.5;
        stream.userData.lifetime = stream.userData.initialLifetime = lifetime;
        stream.position.set((Math.random() - 0.5) * 4.0, -2.5 + (Math.random() - 0.5), (Math.random() - 0.5) * 2.0);
        stream.scale.set(0.01 + Math.random() * 0.01, 0.8 + Math.random() * 1.0, 1);
        stream.userData.velocity.set((Math.random() - 0.5) * 0.1, 0.3 + Math.random() * 0.3, (Math.random() - 0.5) * 0.05);
        stream.rotation.y = (Math.random() - 0.5) * Math.PI;
    }

    createPointTexture() {
        const canvas = document.createElement('canvas'), size = 64; canvas.width = size; canvas.height = size;
        const context = canvas.getContext('2d'), gradient = context.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
        gradient.addColorStop(0, 'rgba(255,255,255,1)'); gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.6, 'rgba(255,255,255,0.5)'); gradient.addColorStop(1, 'rgba(255,255,255,0)');
        context.fillStyle = gradient; context.fillRect(0, 0, size, size);
        return new THREE.CanvasTexture(canvas);
    }
    
    createStreamTexture() {
        const canvas = document.createElement('canvas'), w = 2, h = 128; canvas.width = w; canvas.height = h;
        const context = canvas.getContext('2d'), gradient = context.createLinearGradient(0, 0, 0, h);
        gradient.addColorStop(0, 'rgba(255,255,255,0)'); gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.8, 'rgba(255,255,255,0.8)'); gradient.addColorStop(1, 'rgba(255,255,255,0)');
        context.fillStyle = gradient; context.fillRect(0, 0, w, h);
        return new THREE.CanvasTexture(canvas);
    }
    
    update(deltaTime) {
        if (this.isStreamType) {
            for (const stream of this.streams) {
                stream.userData.lifetime -= deltaTime;
                if (stream.userData.lifetime <= 0) this.initStreamParticle(stream);
                stream.position.addScaledVector(stream.userData.velocity, deltaTime);
                stream.position.x += Math.sin(stream.position.y * 0.5 + stream.userData.phase) * 0.008;
                stream.material.opacity = Math.sin((1.0 - (stream.userData.lifetime / stream.userData.initialLifetime)) * Math.PI) * 0.6;
            }
        } else {
            const positions = this.points.geometry.attributes.position.array;
            const opacities = this.points.geometry.attributes.alpha.array;
            for (let i = 0; i < this.particleCount; i++) {
                if ((this.lifetimes[i] -= deltaTime) <= 0) this.initPointParticle(i, positions, opacities);
                const i3 = i * 3;
                positions[i3] += this.velocities[i].x * deltaTime;
                positions[i3 + 1] += this.velocities[i].y * deltaTime;
                positions[i3 + 2] += this.velocities[i].z * deltaTime;
                opacities[i] = Math.max(0, this.lifetimes[i] / 3.0);
            }
            this.points.geometry.attributes.position.needsUpdate = true;
            this.points.geometry.attributes.alpha.needsUpdate = true;
        }
    }

    dispose() {
        if (this.isStreamType) {
            if (this.streams.length > 0) {
                this.streams[0].geometry.dispose();
                this.streams[0].material.map.dispose();
            }
            this.streams.forEach(stream => stream.material.dispose());
            this.scene.remove(this.streamGroup);
        } else if (this.points) {
            this.scene.remove(this.points);
            this.points.geometry.dispose();
            this.points.material.map.dispose();
            this.points.material.dispose();
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/CardParticleSystem.js ===


=== FILE: src/client/rendering/EnemyProjectileVisual.js ===
--------------------------------------------------
// src/client/rendering/EnemyProjectileVisual.js

import * as THREE from 'three';

/**
 * Manages the visual representation of an EnemyProjectile.
 * It creates the mesh and syncs its position with the logical entity's physics body.
 */
export class EnemyProjectileVisual {
    constructor(entity, scene) {
        this.entity = entity;
        this.scene = scene;

        const geometry = new THREE.SphereGeometry(0.2, 16, 16);
        const material = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 10 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;

        this.light = new THREE.PointLight(0x00ffff, 200, 20, 2);
        this.mesh.add(this.light);
        
        // Link mesh to entity for sync systems
        this.entity.mesh = this.mesh;
        this.mesh.userData.entity = this.entity;

        this.scene.add(this.mesh);
    }

    /**
     * Updates the visual's position to match its physics body.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    update(deltaTime) {
        if (!this.entity || this.entity.isDead || !this.entity.physics?.body) {
            // The logical entity might be removed before the visual.
            // The VFX system will call dispose() shortly.
            return;
        }
        this.mesh.position.copy(this.entity.physics.body.position);
    }

    /**
     * Cleans up Three.js resources when the visual is no longer needed.
     */
    dispose() {
        if (!this.scene) return; // Already disposed

        if (this.entity) {
            this.entity.mesh = null; // Unlink
        }

        this.scene.remove(this.mesh);
        this.mesh.geometry?.dispose();
        this.mesh.material?.dispose();
        this.light?.dispose();
        this.scene = null;
        this.entity = null;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/EnemyProjectileVisual.js ===


=== FILE: src/client/rendering/FireballVisual.js ===
--------------------------------------------------
// src/client/rendering/FireballVisual.js

import * as THREE from 'three';

/**
 * Manages the visual representation of a Fireball projectile.
 */
export class FireballVisual {
    constructor(fireballEntity, scene) {
        this.entity = fireballEntity;
        this.scene = scene;
        
        const geometry = new THREE.SphereGeometry(this.entity.RADIUS, 16, 16);
        const material = new THREE.MeshStandardMaterial({
            color: 0xff8800, emissive: 0xff4400, emissiveIntensity: 5
        });
        this.mesh = new THREE.Mesh(geometry, material);

        this.light = new THREE.PointLight(0xffaa33, 500, 100, 2);
        this.mesh.add(this.light);
        
        // Link mesh to entity for sync systems
        this.entity.mesh = this.mesh;
        this.mesh.userData.entity = this.entity;

        this.scene.add(this.mesh);
    }

    update(deltaTime) {
        if (!this.entity || (this.entity.isDead && this.entity.state === 'TRAVELING')) {
            // Logical entity was removed before visual could react, clean up.
            // The VFXManager will call dispose.
            return;
        }

        switch (this.entity.state) {
            case 'TRAVELING':
                if (this.entity.body) {
                    this.mesh.position.copy(this.entity.body.position);
                }
                break;
            case 'LINGERING':
                this.handleExplosion(deltaTime);
                break;
            case 'SHRINKING': // This state is now implicitly handled by LINGERING's end
                this.handleExplosion(deltaTime);
                break;
        }
    }

    handleExplosion(deltaTime) {
        this.mesh.position.copy(this.entity.aoeBody.position);

        const GROW_DURATION = 0.2;
        const SHRINK_DURATION = 0.5;
        const FINAL_SCALE = 40;

        // Growing phase
        if (this.entity.stateTimer < GROW_DURATION) {
            const progress = this.entity.stateTimer / GROW_DURATION;
            const scale = THREE.MathUtils.lerp(1, FINAL_SCALE, progress);
            this.mesh.scale.setScalar(scale);
            this.light.intensity = THREE.MathUtils.lerp(500, 2000, progress);
        } 
        // Lingering phase (includes shrinking at the end)
        else {
            const lingerTime = this.entity.stateTimer - GROW_DURATION;
            const lingerProgress = lingerTime / this.entity.LINGER_DURATION;
            
            // Pulse effect
            const pulse = Math.sin(lingerTime * Math.PI * 4) * 0.5 + 0.5;
            this.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(8, 12, pulse);
            
            // Shrink in the last part of the linger duration
            const shrinkStartTime = this.entity.LINGER_DURATION - SHRINK_DURATION;
            if (lingerTime > shrinkStartTime) {
                const shrinkProgress = (lingerTime - shrinkStartTime) / SHRINK_DURATION;
                const scale = THREE.MathUtils.lerp(FINAL_SCALE, 0, shrinkProgress);
                this.mesh.scale.setScalar(scale);
                this.light.intensity = THREE.MathUtils.lerp(2000, 0, shrinkProgress);
            } else {
                 this.mesh.scale.setScalar(FINAL_SCALE);
            }
        }
    }
    
    dispose() {
        if (!this.scene) return; // Already disposed

        if (this.entity) {
            this.entity.mesh = null; // Unlink
        }

        this.scene.remove(this.mesh);
        this.mesh.geometry?.dispose();
        this.mesh.material?.dispose();
        this.light?.dispose();
        this.scene = null;
        this.entity = null;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/FireballVisual.js ===


=== FILE: src/client/rendering/FireflyProjectileVisual.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Manages the visual representation of a FireflyProjectile.
 */
export class FireflyProjectileVisual {
    constructor(entity, scene) {
        this.entity = entity;
        this.scene = scene;

        const geometry = new THREE.SphereGeometry(0.15, 8, 8);
        const material = new THREE.MeshStandardMaterial({
            color: 0xffa500,
            emissive: 0xffa500,
            emissiveIntensity: 5,
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = false;
        
        this.light = new THREE.PointLight(0xffa500, 150, 10, 2);
        this.mesh.add(this.light);
        
        this.entity.mesh = this.mesh;
        this.mesh.userData.entity = this.entity;

        this.scene.add(this.mesh);
    }

    update(deltaTime) {
        if (!this.entity || this.entity.isDead || !this.entity.physics?.body) {
            return;
        }
        // Sync position and rotation from physics body
        this.mesh.position.copy(this.entity.physics.body.position);
        this.mesh.quaternion.copy(this.entity.physics.body.quaternion);
    }

    dispose() {
        if (!this.scene) return;
        if (this.entity) {
            this.entity.mesh = null;
        }
        this.scene.remove(this.mesh);
        this.mesh.geometry?.dispose();
        this.mesh.material?.dispose();
        this.light?.dispose();
        this.scene = null;
        this.entity = null;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/FireflyProjectileVisual.js ===


=== FILE: src/client/rendering/Minimap.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Renders the minimap onto a 2D canvas, showing the player, enemies, and level geometry.
 * It's updated by the UIManager with the latest game state.
 */
export class Minimap {
    constructor() {
        this.canvas = document.getElementById('minimap-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.size = this.canvas.width;
        this.worldScale = 30.0; // World units from center to edge of map

        // Style configuration
        this.bgColor = 'rgba(10, 10, 10, 0.7)';
        this.borderColor = 'rgba(255, 255, 255, 0.3)';
        this.playerColor = '#2ed573';
        this.enemyColor = '#ff4757';
        this.objectColor = 'rgba(255, 255, 255, 0.2)';

        // Reusable vector for performance
        this.playerForward = new THREE.Vector3();
    }

    /**
     * Updates and draws the minimap.
     * @param {Player} player The player instance from the game world.
     * @param {Enemy[]} enemies Array of enemy instances.
     * @param {Object[]} levelObjects Array of level object instances.
     */
    update(player, enemies, levelObjects) {
        if (!player || player.isDead || !this.ctx) {
            this.ctx?.clearRect(0, 0, this.size, this.size);
            return;
        }

        const playerPos = player.physics.body.position;
        player.camera.getWorldDirection(this.playerForward);
        this.playerForward.y = 0; // Flatten for 2D rotation
        this.playerForward.normalize();

        // Clear and draw background
        this.ctx.clearRect(0, 0, this.size, this.size);
        this.ctx.fillStyle = this.bgColor;
        this.ctx.beginPath();
        this.ctx.arc(this.size / 2, this.size / 2, this.size / 2, 0, Math.PI * 2);
        this.ctx.fill();

        // --- Transformation Setup ---
        const mapRadius = this.size / 2;
        const scale = mapRadius / this.worldScale;
        const rotationAngle = Math.atan2(this.playerForward.x, this.playerForward.z);

        this.ctx.save();
        this.ctx.translate(mapRadius, mapRadius);
        this.ctx.rotate(-rotationAngle); // Rotate canvas opposite to player's rotation

        // --- Draw Level Geometry ---
        this.ctx.fillStyle = this.objectColor;
        for (const obj of levelObjects) {
            if (!obj.mesh || !obj.definition) continue;

            const dx = obj.mesh.position.x - playerPos.x;
            const dz = obj.mesh.position.z - playerPos.z;

            if (Math.sqrt(dx * dx + dz * dz) > this.worldScale * 1.5) continue;

            const width = obj.definition.size[0] * scale;
            const depth = obj.definition.size[2] * scale;

            this.ctx.save();
            this.ctx.translate(dx * scale, -dz * scale);
            if (obj.definition.rotation) {
                this.ctx.rotate(THREE.MathUtils.degToRad(obj.definition.rotation.y || 0));
            }
            this.ctx.fillRect(-width / 2, -depth / 2, width, depth);
            this.ctx.restore();
        }

        // --- Draw Enemies ---
        this.ctx.fillStyle = this.enemyColor;
        for (const enemy of enemies) {
            if (enemy.isDead || !enemy.physics?.body) continue;

            const dx = enemy.physics.body.position.x - playerPos.x;
            const dz = enemy.physics.body.position.z - playerPos.z;

            if (Math.sqrt(dx * dx + dz * dz) < this.worldScale) {
                this.ctx.beginPath();
                this.ctx.arc(dx * scale, -dz * scale, 4, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.restore(); // Restore context to pre-rotation state

        // --- Draw Player (always at center, facing up) ---
        this.ctx.save();
        this.ctx.translate(mapRadius, mapRadius);
        this.ctx.fillStyle = this.playerColor;
        this.ctx.strokeStyle = '#FFFFFF';
        this.ctx.lineWidth = 1.5;
        this.ctx.beginPath();
        this.ctx.moveTo(0, -8);
        this.ctx.lineTo(6, 6);
        this.ctx.lineTo(-6, 6);
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.restore();

        // --- Draw Border ---
        this.ctx.strokeStyle = this.borderColor;
        this.ctx.lineWidth = 4;
        this.ctx.beginPath();
        this.ctx.arc(mapRadius, mapRadius, mapRadius - 2, 0, Math.PI * 2);
        this.ctx.stroke();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/Minimap.js ===


=== FILE: src/client/rendering/MuzzleFlash.js ===
--------------------------------------------------
import * as THREE from 'three';

export class MuzzleFlash {
    constructor({ scene, weapon, camera }) {
        this.scene = scene;
        this.lifetime = 0.1;
        this.elapsedTime = 0;
        
        const canvas = this.createCanvas();
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true });
        
        this.sprite = new THREE.Sprite(material);
        const scale = 0.4 + Math.random() * 0.2;
        this.sprite.scale.set(scale, scale, 1.0);
        this.sprite.material.rotation = Math.random() * Math.PI * 2;
        
        // Position it at the end of the weapon's barrel
        const barrelEndPosition = new THREE.Vector3(0, 0, -0.27); // Local offset from weapon mesh center
        weapon.mesh.localToWorld(barrelEndPosition);
        this.sprite.position.copy(barrelEndPosition);
        
        camera.add(this.sprite); // Add to camera to ensure it's always in viewmodel space
    }

    createCanvas() {
        const canvas = document.createElement('canvas');
        const size = 128;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
        gradient.addColorStop(0, 'rgba(255, 220, 180, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 180, 50, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 150, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        return canvas;
    }

    update(deltaTime) {
        this.elapsedTime += deltaTime;
        if (this.elapsedTime >= this.lifetime) {
            this.cleanup();
            return false; // Signal to VFXManager to remove
        }
        
        const progress = this.elapsedTime / this.lifetime;
        this.sprite.material.opacity = 1.0 - progress;
        this.sprite.scale.x = this.sprite.scale.y = (1.0 - progress) * 0.6;

        return true;
    }

    cleanup() {
        this.sprite.removeFromParent();
        this.sprite.material.map.dispose();
        this.sprite.material.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/MuzzleFlash.js ===


=== FILE: src/client/rendering/ParticleExplosion.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * A self-contained, programmatic particle explosion effect.
 * Its lifecycle is managed by the VFXManager.
 */
export class ParticleExplosion {
    constructor({ scene, position }) {
        this.scene = scene;
        this.LIFESPAN = 1.2;
        this.elapsedTime = 0;
        
        const particleCount = 200;
        const positions = new Float32Array(particleCount * 3);
        this.velocities = [];

        for (let i = 0; i < particleCount; i++) {
            const vec = new THREE.Vector3(
                Math.random() - 0.5,
                Math.random() - 0.5,
                Math.random() - 0.5
            ).normalize().multiplyScalar(Math.random() * 15 + 5);
            this.velocities.push(vec);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
            color: 0xff8800,
            size: 0.2,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });

        this.points = new THREE.Points(geometry, material);
        this.points.position.copy(position);
        this.scene.add(this.points);
    }

    /**
     * Updates the particle positions and opacity.
     * @param {number} deltaTime - Time elapsed since the last frame.
     * @returns {boolean} `false` if the effect is finished, otherwise `true`.
     */
    update(deltaTime) {
        this.elapsedTime += deltaTime;
        const progress = this.elapsedTime / this.LIFESPAN;

        if (progress >= 1) {
            this.cleanup();
            return false; // Signal to VFXManager to remove this effect
        }

        const positions = this.points.geometry.attributes.position.array;
        for (let i = 0; i < this.velocities.length; i++) {
            const i3 = i * 3;
            positions[i3] += this.velocities[i].x * deltaTime;
            positions[i3 + 1] += this.velocities[i].y * deltaTime;
            positions[i3 + 2] += this.velocities[i].z * deltaTime;
        }
        this.points.geometry.attributes.position.needsUpdate = true;
        this.points.material.opacity = 1.0 - progress;
        
        return true; // Effect is still active
    }

    /**
     * Removes the effect's assets from the scene and disposes of them.
     */
    cleanup() {
        this.scene.remove(this.points);
        this.points.geometry.dispose();
        this.points.material.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/ParticleExplosion.js ===


=== FILE: src/client/rendering/VFXManager.js ===
--------------------------------------------------
// src/client/rendering/VFXManager.js

import { ParticleExplosion } from './ParticleExplosion.js';
import { DamageNumber } from '../ui/DamageNumber.js';
import { FireballVisual } from './FireballVisual.js';
import { EnemyProjectileVisual } from './EnemyProjectileVisual.js';
import { FireflyProjectileVisual } from './FireflyProjectileVisual.js';
import { WaveVFX } from './WaveVFX.js';
import { MuzzleFlash } from './MuzzleFlash.js';
import { BulletTracer } from './BulletTracer.js';

/**
 * Manages the creation and lifecycle of all visual effects,
 * both DOM-based (CSS animations) and WebGL-based (particles).
 */
export class VFXManager {
    constructor(scene) {
        this.scene = scene;
        this.updatableEffects = [];
        this.entityVisuals = new Map(); // Map<entityId, visualComponent>

        this.domElements = {
            damage: document.getElementById('screen-overlay'),
            dashForward: document.getElementById('vfx-dash-forward'),
            dashSideways: document.getElementById('vfx-dash-sideways'),
            jump: document.getElementById('vfx-jump-wind'),
            slam: document.getElementById('vfx-ground-slam'),
            earthBuff: document.getElementById('vfx-earth-buff'),
        };
        this.setupVFXListeners();
    }

    /**
     * Adds 'animationend' listeners to automatically clean up CSS classes
     * after a DOM-based animation completes.
     */
    setupVFXListeners() {
        Object.values(this.domElements).forEach(element => {
            if (element) {
                element.addEventListener('animationend', () => {
                    // Don't remove 'active' from sustained effects like buffs
                    if (element.id !== 'vfx-earth-buff') {
                        element.classList.remove('active', 'right-to-left', 'left-to-right');
                    }
                });
            }
        });
    }

    /**
     * Triggers a DOM-based visual effect by adding CSS classes to an element.
     * @param {string} elementName - The key for the DOM element (e.g., 'damage', 'dashForward').
     * @param {...string} classes - Additional classes to add, like 'left-to-right'.
     */
    trigger(elementName, ...classes) {
        const element = this.domElements[elementName];
        if (!element) return;
        
        // This pattern reliably restarts a CSS animation
        element.classList.remove('active', 'right-to-left', 'left-to-right');
        void element.offsetWidth; // Force browser reflow
        element.classList.add('active', ...classes);
    }
    
    /**
     * Creates a new particle explosion effect at a given position.
     * @param {THREE.Vector3} position - The world position for the explosion.
     */
    createParticleExplosion(position) {
        const explosion = new ParticleExplosion({ scene: this.scene, position });
        this.updatableEffects.push(explosion);
    }

    /**
     * Creates a new wave visual effect.
     * @param {object} data - Data for the effect.
     * @param {THREE.Vector3} data.position - The starting position.
     * @param {THREE.Vector3} data.direction - The direction the wave travels.
     */
    createWaveEffect(data) {
        const wave = new WaveVFX(this.scene, data.position, data.direction);
        this.updatableEffects.push(wave);
    }

    /**
     * Creates a new damage number effect at a given position.
     * @param {object} data - The data for the damage number.
     * @param {THREE.Vector3} data.position - The world position for the effect.
     * @param {string} data.text - The text to display.
     */
    createDamageNumber({ position, text }) {
        const damageNumber = new DamageNumber({ scene: this.scene, position, text });
        this.updatableEffects.push(damageNumber);
    }
    
    /**
     * Creates muzzle flash and tracer effects for a weapon firing.
     * @param {object} data
     */
    createWeaponFireVFX({ weapon, hitPoint, camera }) {
        const muzzleFlash = new MuzzleFlash({ scene: this.scene, weapon, camera });
        this.updatableEffects.push(muzzleFlash);
        const tracer = new BulletTracer({ scene: this.scene, weapon, hitPoint });
        this.updatableEffects.push(tracer);
    }

    /**
     * Activates a sustained DOM-based visual effect by adding a CSS class.
     * @param {string} elementName - The key for the DOM element.
     */
    activateSustained(elementName) {
        const element = this.domElements[elementName];
        if (element && !element.classList.contains('active')) {
            element.classList.add('active');
        }
    }

    /**
     * Deactivates a sustained DOM-based visual effect by removing a CSS class.
     * @param {string} elementName - The key for the DOM element.
     */
    deactivateSustained(elementName) {
        const element = this.domElements[elementName];
        if (element) {
            element.classList.remove('active');
        }
    }

    createVisualForEntity(entity) {
        if (this.entityVisuals.has(entity.id)) return;

        let visual = null;
        switch (entity.constructor.name) {
            case 'Fireball':
                visual = new FireballVisual(entity, this.scene);
                break;
            case 'EnemyProjectile':
                visual = new EnemyProjectileVisual(entity, this.scene);
                break;
            case 'FireflyProjectile':
                visual = new FireflyProjectileVisual(entity, this.scene);
                break;
        }


        if (visual) {
            this.entityVisuals.set(entity.id, visual);
        }
    }

    removeVisualForEntity(entityId) {
        if (this.entityVisuals.has(entityId)) {
            const visual = this.entityVisuals.get(entityId);
            if (visual.dispose) {
                visual.dispose();
            }
            this.entityVisuals.delete(entityId);
        }
    }

    /**
     * Updates all active programmatic effects and removes any that have finished.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    update(deltaTime) {
        // Loop backwards to allow for safe removal of elements from the array
        for (let i = this.updatableEffects.length - 1; i >= 0; i--) {
            const effect = this.updatableEffects[i];
            const isAlive = effect.update(deltaTime);
            if (!isAlive) {
                this.updatableEffects.splice(i, 1);
            }
        }

        // Update persistent entity visuals
        for (const visual of this.entityVisuals.values()) {
            if (visual.update) {
                visual.update(deltaTime);
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/VFXManager.js ===


=== FILE: src/client/rendering/WaveVFX.js ===
--------------------------------------------------
// src/client/rendering/WaveVFX.js
import * as THREE from 'three';
import { GAME_CONFIG } from '../../shared/config.js';

// Asynchronously load shaders once
const vertexShaderPromise = fetch('./src/client/rendering/shaders/wave.vert').then(res => res.text());
const fragmentShaderPromise = fetch('./src/client/rendering/shaders/wave.frag').then(res => res.text());

export class WaveVFX {
    constructor(scene, position, direction) {
        this.scene = scene;
        this.lifetime = 1.0;
        this.elapsedTime = 0;
        this.isReady = false;

        this.init(position, direction);
    }

    async init(position, direction) {
        const config = GAME_CONFIG.WAVE_POWER;
        
        // Geometry is in XY plane by default. Animation (using vUv.y) runs along its height (local Y).
        const geometry = new THREE.PlaneGeometry(config.WIDTH, config.LENGTH, 20, 20);
        // Rotate the geometry itself so it lies flat on the XZ plane.
        // The original local Y-axis now points along the world +Z axis.
        geometry.rotateX(-Math.PI / 2);

        const vertexShader = await vertexShaderPromise;
        const fragmentShader = await fragmentShaderPromise;

        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uProgress: { value: 0 },
                uColor: { value: new THREE.Color(0x00A3FF) },
                uLength: { value: config.LENGTH }
            },
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        this.mesh = new THREE.Mesh(geometry, material);
        
        // Position the mesh's center so its back edge starts at the player.
        this.mesh.position.copy(position).add(direction.clone().multiplyScalar(config.LENGTH / 2));

        // The animation is reversed in the shader to move along local -Z.
        // We align the mesh's local -Z axis with the world 'direction' vector.
        const animationDirectionLocal = new THREE.Vector3(0, 0, -1);
        this.mesh.quaternion.setFromUnitVectors(animationDirectionLocal, direction.clone().setY(0).normalize());
        
        this.scene.add(this.mesh);
        this.isReady = true;
    }

    update(deltaTime) {
        if (!this.isReady) return true;

        this.elapsedTime += deltaTime;
        if (this.elapsedTime >= this.lifetime) {
            this.cleanup();
            return false;
        }
        
        const progress = this.elapsedTime / this.lifetime;
        this.mesh.material.uniforms.uTime.value = this.elapsedTime;
        this.mesh.material.uniforms.uProgress.value = progress;

        return true;
    }

    cleanup() {
        if (!this.mesh) return;
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.mesh = null;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/WaveVFX.js ===


=== FILE: src/client/rendering/shaders/card.frag ===
--------------------------------------------------
uniform float uTime;
uniform vec3 uElementColor;
uniform int uElementId; // 0:Fire, 1:Water, 2:Air, 3:Earth, 4:Utility
uniform sampler2D uTextTexture;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vViewDirection;

// Note: The noise function is prepended in CardObject.js

#define PI 3.14159265359

float circleSDF(vec2 p, float r) { return length(p) - r; }
float boxSDF(vec2 p, vec2 b) { vec2 d = abs(p) - b; return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0); }
float lineSDF(vec2 p, vec2 a, vec2 b) { vec2 pa = p - a, ba = b - a; float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0); return length(pa - ba * h); }

mat2 rotate2d(float angle) { return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); }
float opUnion(float d1, float d2) { return min(d1, d2); }
float opSubtraction(float d1, float d2) { return max(-d1, d2); }

float fireSigil(vec2 p) {
    p.y -= 0.1; float finalShape = 1.0;
    for(int i = 0; i < 3; i++) {
        float angle = (float(i) / 3.0) * (2.0 * PI) + uTime * 0.5;
        vec2 rp = p * rotate2d(angle); rp.y -= 0.35;
        float flame = opUnion(opUnion(circleSDF(rp, 0.08), boxSDF(rp - vec2(0.0, 0.1), vec2(0.02, 0.1))), circleSDF(rp - vec2(0.0, 0.25), 0.03));
        finalShape = opUnion(finalShape, flame);
    }
    return finalShape;
}
float waterSigil(vec2 p) {
    float wave1 = p.y + sin(p.x * 5.0 + uTime * 2.0) * 0.1 - 0.2;
    float wave2 = p.y + cos(p.x * 4.0 - uTime * 1.5) * 0.1;
    float wave3 = p.y + sin(p.x * 6.0 + uTime * 1.0) * 0.1 + 0.2;
    float d = 1.0; d = opUnion(d, abs(wave1) - 0.02); d = opUnion(d, abs(wave2) - 0.02); d = opUnion(d, abs(wave3) - 0.02);
    d = max(d, abs(p.x) - 0.4); d = max(d, abs(p.y) - 0.4);
    return d;
}
float airSigil(vec2 p) {
    float d = 1.0;
    for(int i = 0; i < 5; i++) {
        float fi = float(i); float t = uTime * 0.3 + fi * 0.5; vec2 lp = p * rotate2d(t * 2.0);
        lp.x -= (sin(t) + 1.0) * 0.2;
        d = opUnion(d, boxSDF(lp, vec2(0.2, 0.01)));
    }
    return d;
}

// REWORK: Replaced with an additive construction of four independently trembling squares.
float earthSigil(vec2 p) {
    vec2 b = vec2(0.08); // half-width of each square
    float c = 0.2;       // center offset for each square
    float trembleAmount = 0.02;

    // Unique 2D noise offsets for each square's center
    vec2 offset1 = (vec2(cnoise(vec2(uTime * 5.0, 1.0)), cnoise(vec2(uTime * 5.0, 1.5))) - 0.5) * trembleAmount;
    vec2 offset2 = (vec2(cnoise(vec2(uTime * 5.0, 2.0)), cnoise(vec2(uTime * 5.0, 2.5))) - 0.5) * trembleAmount;
    vec2 offset3 = (vec2(cnoise(vec2(uTime * 5.0, 3.0)), cnoise(vec2(uTime * 5.0, 3.5))) - 0.5) * trembleAmount;
    vec2 offset4 = (vec2(cnoise(vec2(uTime * 5.0, 4.0)), cnoise(vec2(uTime * 5.0, 4.5))) - 0.5) * trembleAmount;

    float d1 = boxSDF(p - (vec2(c, c) + offset1), b);
    float d2 = boxSDF(p - (vec2(-c, c) + offset2), b);
    float d3 = boxSDF(p - (vec2(-c, -c) + offset3), b);
    float d4 = boxSDF(p - (vec2(c, -c) + offset4), b);

    return min(min(d1, d2), min(d3, d4));
}

float utilitySigil(vec2 p) {
    p *= rotate2d(uTime * 0.2); float d = 1.0;
    for(int i=0; i<6; i++) { d = opUnion(d, lineSDF(p * rotate2d(float(i) * PI / 3.0), vec2(0.0), vec2(0.3, 0.0)) - 0.02); }
    return opSubtraction(d, circleSDF(p, 0.15));
}

void main() {
    vec2 p = vUv * 2.0 - 1.0; p.y *= 1.75 / 1.25;
    float noise = cnoise(vUv * vec2(3.0, 4.0) + uTime * 0.1);
    vec3 bgColor = mix(vec3(0.05, 0.06, 0.08), uElementColor * 0.5, smoothstep(0.3, 1.0, noise));

    vec2 sigilP = p; sigilP.y -= 0.2;
    float d;
    if (uElementId == 0) d = fireSigil(sigilP);
    else if (uElementId == 1) d = waterSigil(sigilP);
    else if (uElementId == 2) d = airSigil(sigilP);
    else if (uElementId == 3) d = earthSigil(sigilP);
    else if (uElementId == 4) d = utilitySigil(sigilP);
    else d = circleSDF(sigilP, 0.2);

    vec3 sigilColor = uElementColor * 1.5;
    float sigil = 1.0 - smoothstep(-0.01, 0.01, d);
    float glow = (1.0 - smoothstep(-0.1, 0.1, d)) * (sin(uTime * 2.0) * 0.2 + 0.8);
    vec3 finalColor = mix(mix(bgColor, sigilColor * 0.2, glow), sigilColor, sigil);

    vec4 textColor = texture2D(uTextTexture, vUv);
    finalColor = mix(finalColor, textColor.rgb, textColor.a);
    finalColor += pow(1.0 - dot(vNormal, vViewDirection), 3.0) * uElementColor * 0.3;
    gl_FragColor = vec4(finalColor, 1.0);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/card.frag ===


=== FILE: src/client/rendering/shaders/card.vert ===
--------------------------------------------------
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vViewDirection;

void main() {
    vUv = uv;
    vNormal = normalize(normalMatrix * normal);
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    vViewDirection = normalize(cameraPosition - worldPosition.xyz);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/card.vert ===


=== FILE: src/client/rendering/shaders/card_back.frag ===
--------------------------------------------------
uniform float uTime;
uniform vec3 uElementColor;
varying vec2 vUv;

// Note: The noise function is prepended in CardObject.js

void main() {
    float flowingNoise = cnoise(vUv * vec2(1.5, 6.0) + vec2(0.0, uTime * -0.15));
    float bands = smoothstep(0.4, 0.6, flowingNoise);
    vec3 baseColor = vec3(0.08, 0.09, 0.12);
    vec3 finalColor = mix(baseColor, uElementColor * 0.7, bands);
    float borderX = smoothstep(0.0, 0.15, vUv.x) * smoothstep(1.0, 0.85, vUv.x);
    float borderY = smoothstep(0.0, 0.15, vUv.y) * smoothstep(1.0, 0.85, vUv.y);
    float border = borderX * borderY;
    finalColor = mix(uElementColor * 0.2, finalColor, border);
    gl_FragColor = vec4(finalColor, 1.0);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/card_back.frag ===


=== FILE: src/client/rendering/shaders/card_back.vert ===
--------------------------------------------------
varying vec2 vUv;

void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/card_back.vert ===


=== FILE: src/client/rendering/shaders/ShaderLib.js ===
--------------------------------------------------
export const ShaderLib = {
    noise: `
    // Classic Perlin 2D Noise by Stefan Gustavson
    vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
    vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
    float cnoise(vec2 P){
        vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
        vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
        Pi = permute(Pi);
        vec4 ix = Pi.xzxz;
        vec4 iy = Pi.yyww;
        vec4 fx = Pf.xzxz;
        vec4 fy = Pf.yyww;
        vec4 i = permute(permute(ix) + iy);
        vec4 gx = 2.0 * fract(i * (1.0 / 41.0)) - 1.0;
        vec4 gy = abs(gx) - 0.5;
        vec4 tx = floor(gx + 0.5);
        gx = gx - tx;
        vec2 g00 = vec2(gx.x,gy.x);
        vec2 g10 = vec2(gx.y,gy.y);
        vec2 g01 = vec2(gx.z,gy.z);
        vec2 g11 = vec2(gx.w,gy.w);
        vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
        g00 *= norm.x;
        g01 *= norm.y;
        g10 *= norm.z;
        g11 *= norm.w;
        float n00 = dot(g00, vec2(fx.x, fy.x));
        float n10 = dot(g10, vec2(fx.y, fy.y));
        float n01 = dot(g01, vec2(fx.z, fy.z));
        float n11 = dot(g11, vec2(fx.w, fy.w));
        vec2 fade_xy = fade(Pf.xy);
        vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
        float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
        return 2.3 * n_xy;
    }
    `
};
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/ShaderLib.js ===


=== FILE: src/client/rendering/shaders/sigil.frag ===
--------------------------------------------------
// + src/client/rendering/shaders/sigil.frag
precision mediump float;

uniform vec3 uElementColor;
uniform int uElementId; // 0:Fire, 1:Water, 2:Air, 3:Earth, 4:Utility
varying vec2 vUv;

#define PI 3.14159265359

// SDF (Signed Distance Function) primitives
float circleSDF(vec2 p, float r) { return length(p) - r; }
float boxSDF(vec2 p, vec2 b) { vec2 d = abs(p) - b; return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0); }
float lineSDF(vec2 p, vec2 a, vec2 b) { vec2 pa = p - a; vec2 ba = b - a; float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0); return length(pa - ba * h); }

mat2 rotate2d(float angle) { return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); }
float opUnion(float d1, float d2) { return min(d1, d2); }
float opSubtraction(float d1, float d2) { return max(-d1, d2); }

// Sigil definitions (static versions)
float fireSigil(vec2 p) {
    p.y -= 0.1; float finalShape = 1.0;
    for(int i = 0; i < 3; i++) {
        float angle = (float(i) / 3.0) * (2.0 * PI);
        vec2 rp = p * rotate2d(angle); rp.y -= 0.35;
        float flame = opUnion(opUnion(circleSDF(rp, 0.08), boxSDF(rp - vec2(0.0, 0.1), vec2(0.02, 0.1))), circleSDF(rp - vec2(0.0, 0.25), 0.03));
        finalShape = opUnion(finalShape, flame);
    }
    return finalShape;
}
float waterSigil(vec2 p) {
    float wave1 = p.y + sin(p.x * 5.0) * 0.1 - 0.2;
    float wave2 = p.y + cos(p.x * 4.0) * 0.1;
    float wave3 = p.y + sin(p.x * 6.0) * 0.1 + 0.2;
    float d = 1.0; d = opUnion(d, abs(wave1) - 0.02); d = opUnion(d, abs(wave2) - 0.02); d = opUnion(d, abs(wave3) - 0.02);
    d = max(d, abs(p.x) - 0.4); d = max(d, abs(p.y) - 0.4);
    return d;
}
float airSigil(vec2 p) {
    float d = 1.0;
    for(int i = 0; i < 5; i++) {
        float fi = float(i); float t = fi * 0.5; vec2 lp = p * rotate2d(t * 2.0);
        lp.x -= (sin(t) + 1.0) * 0.2;
        d = opUnion(d, boxSDF(lp, vec2(0.2, 0.01)));
    }
    return d;
}
float earthSigil(vec2 p) { return opSubtraction(opSubtraction(boxSDF(p, vec2(0.25, 0.25)), circleSDF(p, 0.15)), boxSDF(abs(p) - 0.25, vec2(0.05))); }
float utilitySigil(vec2 p) {
    float d = 1.0;
    for(int i=0; i<6; i++) { d = opUnion(d, lineSDF(p * rotate2d(float(i) * PI / 3.0), vec2(0.0), vec2(0.3, 0.0)) - 0.02); }
    return opSubtraction(d, circleSDF(p, 0.15));
}

void main() {
    vec2 p = vUv * 2.0 - 1.0; // Remap UV from [0,1] to [-1,1]
    
    float d;
    if (uElementId == 0) d = fireSigil(p);
    else if (uElementId == 1) d = waterSigil(p);
    else if (uElementId == 2) d = airSigil(p);
    else if (uElementId == 3) d = earthSigil(p);
    else if (uElementId == 4) d = utilitySigil(p);
    else discard; // If no valid ID, pixel is transparent

    float alpha = 1.0 - smoothstep(-0.02, 0.02, d);
    
    if (alpha < 0.01) {
        discard;
    }

    gl_FragColor = vec4(uElementColor, alpha);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/sigil.frag ===


=== FILE: src/client/rendering/shaders/wave.frag ===
--------------------------------------------------
// src/client/rendering/shaders/wave.frag
precision mediump float;

uniform float uTime;
uniform float uProgress;
uniform vec3 uColor;
uniform float uLength;

varying vec2 vUv;

void main() {
    // Wave animation based on UV and time
    float waveSpeed = 8.0;
    float waveFrequency = 10.0;
    float waveHeight = 0.1;

    float wave = sin(vUv.y * waveFrequency - uTime * waveSpeed) * waveHeight;
    wave = smoothstep(0.05, 0.1, wave);

    // Fade effect based on overall progress
    float fadeIn = smoothstep(0.0, 0.2, uProgress);
    float fadeOut = 1.0 - smoothstep(0.7, 1.0, uProgress);
    float alpha = fadeIn * fadeOut;

    // Foam at the front of the wave
    float foamWidth = 0.1;
    // REVERSED: Animate foam from UV.y=1 down to UV.y=0
    float foamPosition = 1.0 - uProgress;
    float foam = smoothstep(foamWidth, 0.0, abs(vUv.y - foamPosition));
    
    vec3 finalColor = uColor * wave + vec3(1.0) * foam;

    gl_FragColor = vec4(finalColor, (wave + foam) * alpha);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/wave.frag ===


=== FILE: src/client/rendering/shaders/wave.vert ===
--------------------------------------------------
// src/client/rendering/shaders/wave.vert
precision mediump float;

uniform float uTime;
uniform float uProgress;
uniform float uLength;

varying vec2 vUv;

void main() {
    vUv = uv;

    vec3 pos = position;

    // REVERSED: Animate wave crest from one end to the other in reverse.
    // The geometry's original Y-axis is now its local Z-axis.
    // pos.z (in local space) corresponds to the original pos.y.
    float waveFront = (1.0 - uProgress) * uLength - (uLength / 2.0);
    float distToFront = pos.z - waveFront;

    // We now check against local z for the displacement height.
    if (distToFront < 1.0 && distToFront > -2.0) {
        // The displacement itself should be on the Y-axis in world space.
        // After rotation, local Y is world Y, so we displace local Y.
        pos.y += sin(distToFront * 3.14159) * 0.5;
    }

    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}
--------------------------------------------------
=== END OF FILE: src/client/rendering/shaders/wave.vert ===


=== FILE: src/client/systems/VFXSystem.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Listens for abstract gameplay events from the World and translates them
 * into concrete visual effects using the VFXManager.
 */
export class VFXSystem {
    constructor(world, vfxManager) {
        this.world = world;
        this.vfxManager = vfxManager;
        this.hitFlashTimers = new Map(); // entity -> timer

        // Bind handlers to ensure `this` is correct
        this._onEntityAdded = this._onEntityAdded.bind(this);
        this._onEntityRemoved = this._onEntityRemoved.bind(this);

        this.registerListeners();
    }

    registerListeners() {
        this.world.on('entityAdded', this._onEntityAdded);
        this.world.on('entityRemoved', this._onEntityRemoved);
        this.world.on('entityTookDamage', data => this.onEntityTookDamage(data));
        this.world.on('playerDashed', data => this.onPlayerDashed(data));
        this.world.on('playerJumped', () => this.vfxManager.trigger('jump'));
        this.world.on('playerGroundSlammed', () => this.vfxManager.trigger('slam'));
        this.world.on('projectileDetonated', data => this.onProjectileDetonated(data));
        this.world.on('playerBuffActivated', data => this.onPlayerBuffActivated(data));
        this.world.on('playerBuffDeactivated', data => this.onPlayerBuffDeactivated(data));
        this.world.on('wavePowerUsed', data => this.onWavePowerUsed(data));
        this.world.on('weaponFired', data => this.onWeaponFired(data));
    }

    _onEntityAdded({ entity }) {
        this.vfxManager.createVisualForEntity(entity);
    }

    _onEntityRemoved({ entity }) {
        this.vfxManager.removeVisualForEntity(entity.id);
    }

    onEntityTookDamage({ entity, amount }) {
        if (!entity || entity.isDead) return;

        const position = entity.physics.body.position.clone();
        position.y += 1.5; // Offset for damage number
        this.vfxManager.createDamageNumber({
            position,
            text: `${Math.floor(amount)}`,
        });

        // Trigger hit flash
        if (entity.mesh?.material) {
            this.hitFlashTimers.set(entity, entity.health.flashDuration);
            if (entity.originalEmissive) {
                entity.mesh.material.emissive.setHex(0xffffff);
            }
        }
        
        if (entity.type === 'player') {
            this.vfxManager.trigger('damage');
        }
    }

    onPlayerDashed({ forwardDot, rightDot }) {
        if (Math.abs(forwardDot) > Math.abs(rightDot)) {
            this.vfxManager.trigger('dashForward');
        } else {
            const directionClass = rightDot > 0 ? 'right-to-left' : 'left-to-right';
            this.vfxManager.trigger('sideways', directionClass);
        }
    }

    onProjectileDetonated({ type, position }) {
        // Here you could switch on `type` for different explosion effects
        this.vfxManager.createParticleExplosion(position);
    }
    
    onWeaponFired(data) {
        this.vfxManager.createWeaponFireVFX({
            ...data,
            camera: this.world.core.renderer.camera
        });
    }

    onPlayerBuffActivated({ buffName }) {
        if (buffName === 'stonePlating') {
            this.vfxManager.activateSustained('earthBuff');
        }
    }

    onPlayerBuffDeactivated({ buffName }) {
        if (buffName === 'stonePlating') {
            this.vfxManager.deactivateSustained('earthBuff');
        }
    }

    onWavePowerUsed({ position, direction }) {
        this.vfxManager.createWaveEffect({ position, direction });
    }
    
    update(deltaTime) {
        if (this.hitFlashTimers.size === 0) return;

        for (const [entity, timer] of this.hitFlashTimers.entries()) {
            let newTimer = timer - deltaTime;
            if (newTimer <= 0) {
                if (entity.mesh && entity.originalEmissive) {
                    entity.mesh.material.emissive.copy(entity.originalEmissive);
                }
                this.hitFlashTimers.delete(entity);
            } else {
                const flashProgress = 1 - (newTimer / entity.health.flashDuration);
                if (entity.mesh && entity.originalEmissive) {
                    entity.mesh.material.emissive.lerpColors(new THREE.Color(0xffffff), entity.originalEmissive, flashProgress);
                }
                this.hitFlashTimers.set(entity, newTimer);
            }
        }
    }
    
    dispose() {
        this.world.off('entityAdded', this._onEntityAdded);
        this.world.off('entityRemoved', this._onEntityRemoved);
        // In a more complex app, you'd unregister other listeners here.
        this.hitFlashTimers.clear();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/systems/VFXSystem.js ===


=== FILE: src/client/systems/WorldUISystem.js ===
--------------------------------------------------
import { HealthBar } from '../ui/HealthBar.js';

/**
 * Manages 3D UI elements that exist in the world space, like enemy health bars.
 * It listens to world events to create, update, and destroy these UI elements.
 */
export class WorldUISystem {
    constructor(scene) {
        this.scene = scene;
        this.world = null;
        this.healthBars = new Map(); // Map<entity, HealthBar>
    }

    registerWorld(world) {
        if (this.world) {
            this.dispose(); // Clean up listeners from old world
        }
        this.world = world;
        this._onEnemySpawned = this._onEnemySpawned.bind(this);
        this._onEnemyDied = this._onEnemyDied.bind(this);

        this.world.on('enemySpawned', this._onEnemySpawned);
        this.world.on('enemyDied', this._onEnemyDied);
    }
    
    _onEnemySpawned({ enemy }) {
        if (!this.healthBars.has(enemy)) {
            const healthBar = new HealthBar(this.scene);
            this.healthBars.set(enemy, healthBar);
        }
    }

    _onEnemyDied({ entity }) {
        if (this.healthBars.has(entity)) {
            const healthBar = this.healthBars.get(entity);
            healthBar.dispose();
            this.healthBars.delete(entity);
        }
    }

    update(deltaTime) {
        if (!this.world || !this.world.player) return;

        for (const [entity, healthBar] of this.healthBars.entries()) {
            // Guard against entities that might be disposed but not yet removed from the map
            if (!entity.physics?.body) {
                healthBar.setVisible(false);
                continue;
            }

            if (entity.isDead) {
                healthBar.setVisible(false);
                continue;
            }
            
            const position = entity.physics.body.position.clone();
            position.y += (entity.mesh.geometry.parameters.height || 1.0) + 1.0;

            const isVisible = this.world.player.camera.position.distanceTo(position) < 30;
            healthBar.setVisible(isVisible);

            if (isVisible) {
                healthBar.update(position, entity.health.currentHealth, entity.health.maxHealth);
            }
        }
    }
    
    dispose() {
        if (this.world) {
            this.world.off('enemySpawned', this._onEnemySpawned);
            this.world.off('enemyDied', this._onEnemyDied);
        }
        for (const healthBar of this.healthBars.values()) {
            healthBar.dispose();
        }
        this.healthBars.clear();
        this.world = null;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/systems/WorldUISystem.js ===


=== FILE: src/client/ui/AbilityIconService.js ===
--------------------------------------------------
// src/client/ui/AbilityIconService.js
import * as THREE from 'three';

/**
 * A reusable service for generating and caching 2D icons of ability sigils.
 */
export class AbilityIconService {
    constructor() {
        this.cache = new Map();
        this.renderer = null;
        this.scene = null;
        this.camera = null;
        this.plane = null;
        this.sigilShader = null;
        this.isInitialized = false;
    }

    /**
     * Sets up the offscreen WebGL context for rendering icons.
     * @private
     */
    async _initialize() {
        if (this.isInitialized) return;

        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        this.scene = new THREE.Scene();
        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        this.camera.position.z = 1;
        this.renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });

        this.plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2));
        this.scene.add(this.plane);

        const fragShaderSource = await fetch('./src/client/rendering/shaders/sigil.frag').then(res => res.text());
        this.sigilShader = {
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
            fragmentShader: fragShaderSource,
        };
        
        this.isInitialized = true;
    }

    /**
     * Generates a data URL for a given ability's sigil icon.
     * @param {object} abilityData - The full data object for the ability.
     * @returns {Promise<string|null>} A promise that resolves to the data URL of the icon.
     */
    async generate(abilityData) {
        if (!this.isInitialized) await this._initialize();
        if (!abilityData || !abilityData.id) return null;

        if (this.cache.has(abilityData.id)) {
            return this.cache.get(abilityData.id);
        }

        const elementMap = { Fire: 0, Water: 1, Air: 2, Earth: 3, Utility: 4 };
        const elementColors = { 
            Fire: new THREE.Color(0xFF771A), 
            Water: new THREE.Color(0x00A3FF), 
            Air: new THREE.Color(0xB3FCFC), 
            Earth: new THREE.Color(0xB39159), 
            Utility: new THREE.Color(0xA16BFF), 
            Default: new THREE.Color(0xFFFFFF)
        };

        const elementId = elementMap[abilityData.element] ?? 5;
        const elementColor = elementColors[abilityData.element] || elementColors.Default;

        this.plane.material = new THREE.ShaderMaterial({
            ...this.sigilShader,
            uniforms: {
                uElementId: { value: elementId },
                uElementColor: { value: elementColor },
            },
            transparent: true,
        });

        this.renderer.render(this.scene, this.camera);
        const dataUrl = this.renderer.domElement.toDataURL();
        
        // Clean up the material
        if (this.plane.material.dispose) {
            this.plane.material.dispose();
        }

        this.cache.set(abilityData.id, dataUrl);
        return dataUrl;
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/AbilityIconService.js ===


=== FILE: src/client/ui/card_inspector_main.js ===
--------------------------------------------------
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { LoadoutManager } from './LoadoutManager.js';
import { CardObject } from '../rendering/CardObject.js';
import { CardParticleSystem } from '../rendering/CardParticleSystem.js';

class CardInspectorApp {
    constructor() {
        this.manager = new LoadoutManager();
        this.canvas = document.getElementById('inspector-canvas');
        this.scene = new THREE.Scene();
        this.backgroundScene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(50, this.canvas.clientWidth / this.canvas.clientHeight, 0.1, 100);
        this.backgroundCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: true });
        this.clock = new THREE.Clock();
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.activeCardObject = null;
        this.particleSystem = null;
        this.godRayPlane = null;
        this.elements = {
            title: document.getElementById('card-name-title'),
            exitBtn: document.getElementById('exit-btn'),
            prompt: document.getElementById('inspector-prompt'),
        };
    }

    async init() {
        await this.manager.init();
        this.renderer.setSize(this.canvas.parentElement.clientWidth, this.canvas.parentElement.clientHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.camera.position.set(0, 0, 3.5);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);
        const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
        keyLight.position.set(2, 3, 3);
        this.scene.add(keyLight);

        this.controls.enableDamping = true;
        this.controls.enablePan = false;
        this.controls.minDistance = 2;
        this.controls.maxDistance = 6;
        this.controls.target.set(0, 0, 0);

        this.setupEventListeners();
        window.addEventListener('resize', () => this.onResize());

        const urlParams = new URLSearchParams(window.location.search);
        const cardId = urlParams.get('id');

        if (cardId) {
            const cardData = this.manager.getCardDetails(cardId);
            if (cardData) {
                this.elements.title.textContent = cardData.name;
                await this.displayCard(cardData);
            } else {
                this.elements.prompt.textContent = 'Card not found.';
            }
        } else {
            this.elements.prompt.textContent = 'No card specified.';
        }

        this.animate();
    }

    createGodRayPlane(color) {
        if (this.godRayPlane) {
            this.backgroundScene.remove(this.godRayPlane);
            this.godRayPlane.geometry.dispose();
            if(this.godRayPlane.material.map) this.godRayPlane.material.map.dispose();
            this.godRayPlane.material.dispose();
        }

        const canvas = document.createElement('canvas');
        const size = 512;
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        const centerX = size / 2, centerY = size / 2;
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size / 2);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.2)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1.5;
        for(let i=0; i < 100; i++) {
            const angle = Math.random() * Math.PI * 2;
            const length = size * 0.4 + (Math.random() * size * 0.3);
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + Math.cos(angle) * length, centerY + Math.sin(angle) * length);
            ctx.stroke();
        }
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ map: texture, color, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
        this.godRayPlane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
        this.backgroundScene.add(this.godRayPlane);
    }
    
    async displayCard(cardData) {
        if (this.activeCardObject) {
            this.activeCardObject.dispose();
            this.scene.remove(this.activeCardObject.mesh);
        }
        if (this.particleSystem) this.particleSystem.dispose();
        
        this.activeCardObject = await CardObject.create(cardData);
        this.scene.add(this.activeCardObject.mesh);
        this.particleSystem = new CardParticleSystem(this.scene, cardData.element);
        const elementColors = { Fire: '#FF771A', Water: '#00A3FF', Air: '#B3FCFC', Earth: '#B39159', Utility: '#A16BFF' };
        this.createGodRayPlane(elementColors[cardData.element] || '#FFFFFF');
        this.elements.prompt.style.opacity = '0';
    }

    setupEventListeners() {
        this.elements.exitBtn.onclick = () => { window.location.href = 'loadout.html'; };
    }

    onResize() {
        const { clientWidth, clientHeight } = this.canvas.parentElement;
        this.camera.aspect = clientWidth / clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(clientWidth, clientHeight);
    }
    
    animate() {
        requestAnimationFrame(() => this.animate());
        const deltaTime = this.clock.getDelta();
        
        this.controls.update();
        if (this.activeCardObject) this.activeCardObject.update(deltaTime);
        if (this.particleSystem) this.particleSystem.update(deltaTime);
        if (this.godRayPlane) this.godRayPlane.rotation.z += 0.001;
        
        this.renderer.autoClear = false;
        this.renderer.clear();
        this.renderer.render(this.backgroundScene, this.backgroundCamera);
        this.renderer.clearDepth();
        this.renderer.render(this.scene, this.camera);
    }
}

const app = new CardInspectorApp();
app.init().catch(err => {
    console.error("Failed to initialize Card Inspector:", err);
    document.getElementById('inspector-prompt').textContent = 'Error loading. See console.';
});
--------------------------------------------------
=== END OF FILE: src/client/ui/card_inspector_main.js ===


=== FILE: src/client/ui/DamageNumber.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Creates a floating text sprite that displays damage dealt, moves upwards, and fades out.
 * This is a client-side visual effect.
 */
export class DamageNumber {
    constructor({ scene, text, position }) {
        this.scene = scene;

        this.lifetime = 1.0;
        this.elapsedTime = 0;
        this.upwardSpeed = 2.0;

        const canvas = this._createCanvas(text);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;

        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
        this.sprite = new THREE.Sprite(material);
        this.sprite.renderOrder = 1000;
        this.sprite.scale.set(canvas.width / 100, canvas.height / 100, 1.0);
        this.sprite.position.copy(position);
        this.sprite.position.x += (Math.random() - 0.5) * 0.5;

        this.scene.add(this.sprite);
    }

    _createCanvas(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const fontSize = 48;
        context.font = `bold ${fontSize}px Arial`;
        
        const textMetrics = context.measureText(text);
        canvas.width = textMetrics.width + 10;
        canvas.height = fontSize + 10;

        context.font = `bold ${fontSize}px Arial`;
        context.fillStyle = 'rgba(255, 255, 100, 1)';
        context.strokeStyle = 'rgba(0, 0, 0, 1)';
        context.lineWidth = 5;
        context.textAlign = 'center';
        
        const x = canvas.width / 2;
        const y = canvas.height / 2 + fontSize / 3;

        context.strokeText(text, x, y);
        context.fillText(text, x, y);

        return canvas;
    }

    update(deltaTime) {
        this.elapsedTime += deltaTime;
        if (this.elapsedTime >= this.lifetime) {
            this.cleanup();
            return false; // Indicate that this object should be removed
        }

        this.sprite.position.y += this.upwardSpeed * deltaTime;
        this.sprite.material.opacity = 1.0 - (this.elapsedTime / this.lifetime);
        return true; // Still active
    }

    cleanup() {
        this.scene.remove(this.sprite);
        this.sprite.material.map.dispose();
        this.sprite.material.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/DamageNumber.js ===


=== FILE: src/client/ui/HealthBar.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * A client-side visual component representing an entity's health.
 * It is positioned and managed by a client-side system.
 */
export class HealthBar {
    constructor(scene) {
        this.scene = scene;
        
        const healthBarGroup = new THREE.Group();
        // Give the group a high renderOrder so it draws on top of most 3D geometry
        healthBarGroup.renderOrder = 999; 

        // Background
        const bgMaterial = new THREE.SpriteMaterial({ color: 0x550000, sizeAttenuation: false, depthTest: false });
        const bgSprite = new THREE.Sprite(bgMaterial);
        bgSprite.scale.set(0.25, 0.025, 1.0);
        bgSprite.renderOrder = 0; // Render background first
        healthBarGroup.add(bgSprite);

        // Foreground
        const fgMaterial = new THREE.SpriteMaterial({ color: 0x00ff00, sizeAttenuation: false, depthTest: false });
        this.fgSprite = new THREE.Sprite(fgMaterial);
        this.fgSprite.scale.set(0.25, 0.025, 1.0);
        // No need for position.z offset if renderOrder is used for layering transparent sprites
        this.fgSprite.renderOrder = 1; // Render foreground on top
        healthBarGroup.add(this.fgSprite);

        this.group = healthBarGroup;
        this.group.visible = false;
        this.scene.add(this.group);
    }

    update(position, currentHealth, maxHealth) {
        const percent = Math.max(0, currentHealth / maxHealth);
        this.fgSprite.scale.x = 0.25 * percent;
        this.fgSprite.position.x = -0.5 * (0.25 * (1 - percent));

        // Update color based on health percentage
        if (percent < 0.3) this.fgSprite.material.color.setHex(0xff0000);
        else if (percent < 0.6) this.fgSprite.material.color.setHex(0xffff00);
        else this.fgSprite.material.color.setHex(0x00ff00);

        this.group.position.copy(position);
    }

    setVisible(visible) {
        this.group.visible = visible;
    }

    dispose() {
        this.scene.remove(this.group);
        this.fgSprite.material.dispose();
        this.group.children[0].material.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/HealthBar.js ===


=== FILE: src/client/ui/HUD.js ===
--------------------------------------------------
// src/client/ui/HUD.js
import * as THREE from 'three';

/**
 * Manages the DOM elements for the in-game Heads-Up Display.
 * This class is a "dumb" view component, updated by the UIManager.
 */
export class HUD {
    constructor(abilityIconService) {
        this.abilityIconService = abilityIconService;
        this.loadedIconUrls = new Map();

        this.elements = {
            healthBar: document.getElementById('health-bar'),
            energyBar: document.getElementById('energy-bar'),
            
            jumpCooldownIndicator: document.getElementById('jump-cooldown-indicator'),
            jumpCooldownProgress: document.getElementById('jump-cooldown-indicator')?.querySelector('.cooldown-progress'),
            dashCooldownIndicator: document.getElementById('dash-cooldown-indicator'),
            dashCooldownProgress: document.getElementById('dash-cooldown-indicator')?.querySelector('.cooldown-progress'),

            abilitySlots: Array.from({ length: 4 }, (_, i) => ({
                element: document.getElementById(`ability-${i}`),
                icon: document.getElementById(`ability-${i}`).querySelector('.ability-icon'),
                cooldownRing: document.getElementById(`ability-${i}`).querySelector('.cooldown-ring-circle'),
            })),
            
            targetFrame: document.getElementById('target-frame'),
            crosshair: document.getElementById('crosshair'),
            tutorialContainer: document.getElementById('tutorial-text-container'),
            tutorialText: document.getElementById('tutorial-text'),
            minimapCanvas: document.getElementById('minimap-canvas'),
            enemyCounter: document.getElementById('enemy-counter'),
            ammoCounter: document.getElementById('ammo-counter'),
            ammoMag: document.getElementById('ammo-mag'),
            ammoReserve: document.getElementById('ammo-reserve'),
        };
        
        this.targetVector = new THREE.Vector3();
        this.RING_CIRCUMFERENCE = 100; // For ability slots
        this.HALF_RING_CIRCUMFERENCE = 157; // For movement cooldowns
    }

    updateResources(health, maxHealth, energy, maxEnergy) {
        const healthPercent = (health / maxHealth) * 100;
        this.elements.healthBar.style.width = `${healthPercent}%`;

        const energyPercent = (energy / maxEnergy) * 100;
        this.elements.energyBar.style.width = `${energyPercent}%`;
    }

    updateMovementCooldowns(jumpTimer, jumpCooldown, dashTimer, dashCooldown, isDoubleJumpOnCooldown, isDashOnCooldown) {
        if (this.elements.jumpCooldownIndicator) {
            const jumpProgress = Math.min(jumpTimer / jumpCooldown, 1.0);
            this.elements.jumpCooldownIndicator.classList.toggle('on-cooldown', isDoubleJumpOnCooldown);
            const offset = this.HALF_RING_CIRCUMFERENCE * (1 - jumpProgress);
            this.elements.jumpCooldownProgress.style.strokeDashoffset = offset;
        }

        if (this.elements.dashCooldownIndicator) {
            const dashProgress = Math.min(dashTimer / dashCooldown, 1.0);
            this.elements.dashCooldownIndicator.classList.toggle('on-cooldown', isDashOnCooldown);
            const offset = this.HALF_RING_CIRCUMFERENCE * (1 - dashProgress);
            this.elements.dashCooldownProgress.style.strokeDashoffset = offset;
        }
    }
    
    _applyIconStyle(element, url) {
        element.style.backgroundImage = `url(${url})`;
        element.style.backgroundColor = 'transparent';
        element.innerHTML = '';
    }

    updateAbilities(abilities, selectedIndex) {
        this.elements.abilitySlots.forEach((slotUI, i) => {
            const ability = abilities[i];
            
            slotUI.element.className = 'ability-slot';

            if (ability) {
                slotUI.element.classList.add(`element-${ability.data.element.toLowerCase()}`);

                if (!this.loadedIconUrls.has(ability.data.id)) {
                    slotUI.icon.innerHTML = '...';
                    this.loadedIconUrls.set(ability.data.id, 'loading');
                    
                    this.abilityIconService.generate(ability.data).then(iconUrl => {
                        if (iconUrl) {
                            this.loadedIconUrls.set(ability.data.id, iconUrl);
                            if (abilities[i]?.data.id === ability.data.id) {
                                this._applyIconStyle(slotUI.icon, iconUrl);
                            }
                        }
                    });
                } else {
                    const iconUrl = this.loadedIconUrls.get(ability.data.id);
                    if (iconUrl && iconUrl !== 'loading') {
                        this._applyIconStyle(slotUI.icon, iconUrl);
                    } else {
                        slotUI.icon.innerHTML = '...';
                    }
                }

                const cooldownProgress = ability.getCooldownProgress();
                const isReady = cooldownProgress >= 1.0;
                slotUI.element.classList.toggle('ready', isReady);
                const offset = this.RING_CIRCUMFERENCE * (1 - cooldownProgress);
                slotUI.cooldownRing.style.strokeDashoffset = offset;
            } else {
                slotUI.icon.style.backgroundImage = 'none';
                slotUI.icon.style.backgroundColor = '';
                slotUI.icon.innerHTML = '';
                slotUI.cooldownRing.style.strokeDashoffset = this.RING_CIRCUMFERENCE;
                slotUI.element.classList.remove('ready');
            }
            
            slotUI.element.classList.toggle('selected', i === selectedIndex);
        });
    }

    updateAmmo(weapon) {
        const ammoCounter = this.elements.ammoCounter;
        if (!ammoCounter) return;

        if (weapon && typeof weapon.magazineAmmo !== 'undefined') {
            ammoCounter.style.display = 'block';
            this.elements.ammoMag.textContent = weapon.magazineAmmo;
            this.elements.ammoReserve.textContent = weapon.reserveAmmo;
            ammoCounter.classList.toggle('reloading', weapon.isReloading);
        } else {
            ammoCounter.style.display = 'none';
        }
    }
    
    updateTargeting(isLockOn, target, camera) {
        this.elements.crosshair.style.opacity = isLockOn ? '0.2' : '1';

        if (isLockOn && target && target.physics?.body) {
            const targetPosition = this.targetVector.copy(target.physics.body.position);
            targetPosition.y += (target.mesh.geometry?.parameters?.height || 2) / 2;
            targetPosition.project(camera);
            
            if (targetPosition.z < 1) {
                const x = (targetPosition.x * 0.5 + 0.5) * window.innerWidth;
                const y = (targetPosition.y * -0.5 + 0.5) * window.innerHeight;
                this.elements.targetFrame.style.display = 'block';
                this.elements.targetFrame.style.left = `${x}px`;
                this.elements.targetFrame.style.top = `${y}px`;
                const distance = camera.position.distanceTo(target.physics.body.position);
                const frameSize = Math.max(30, Math.min(150, 4000 / distance));
                this.elements.targetFrame.style.width = `${frameSize}px`;
                this.elements.targetFrame.style.height = `${frameSize}px`;
            } else {
                this.elements.targetFrame.style.display = 'none';
            }
        } else {
            this.elements.targetFrame.style.display = 'none';
        }
    }
    
    updateEnemyCount(killed, total) {
        if (this.elements.enemyCounter) {
            if (total > 0) {
                this.elements.enemyCounter.style.display = 'block';
                this.elements.enemyCounter.textContent = `ENEMIES: ${total - killed}`;
            } else {
                this.elements.enemyCounter.style.display = 'none';
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/HUD.js ===


=== FILE: src/client/ui/LoadoutManager.js ===
--------------------------------------------------
export class LoadoutManager {
    constructor() {
        this.allAbilities = new Map();
        this.playerProfile = null;
        this.activeLoadout = {
            name: 'Default',
            weapon: null,
            cards: [null, null, null, null]
        };
        this.currentSynergy = { isValid: false, synergyName: 'No Synergy', description: 'Fill all slots to see Synergy.' };
    }

    async init() {
        try {
            const [abilitiesResponse, profileResponse] = await Promise.all([
                fetch('./data/abilities.json'),
                fetch('./data/player-profile.json')
            ]);
            const abilitiesData = await abilitiesResponse.json();
            this.playerProfile = await profileResponse.json();

            for (const [id, data] of Object.entries(abilitiesData)) {
                this.allAbilities.set(id, { id, ...data });
            }

            this.switchActiveLoadout(this.playerProfile.activeLoadoutName);

        } catch (error) {
            console.error("Failed to initialize LoadoutManager:", error);
        }
    }

    getCardDetails(cardId) {
        return this.allAbilities.get(cardId);
    }
    
    getInventoryItems(type = 'all') {
        return this.playerProfile.inventory
            .map(id => this.getCardDetails(id))
            .filter(item => {
                if (!item) return false;
                const isEquipped = this.activeLoadout.cards.includes(item.id) || this.activeLoadout.weapon === item.id;
                if (isEquipped) return false;
                
                if (type === 'all') return true;
                return item.type.toLowerCase() === type.toLowerCase();
            });
    }
    
    getActiveLoadoutCards() {
        return this.activeLoadout.cards.map(id => id ? this.getCardDetails(id) : null);
    }

    getActiveWeapon() {
        return this.activeLoadout.weapon ? this.getCardDetails(this.activeLoadout.weapon) : null;
    }
    
    equipCard(cardId, slotIndex) {
        if (!cardId || slotIndex < 0 || slotIndex >= 4) return;
        
        const existingIndex = this.activeLoadout.cards.indexOf(cardId);
        if (existingIndex !== -1) {
            this.activeLoadout.cards[existingIndex] = null;
        }

        this.activeLoadout.cards[slotIndex] = cardId;
        this._checkSynergy();
    }
    
    unequipCard(slotIndex) {
        if (slotIndex >= 0 && slotIndex < this.activeLoadout.cards.length) {
            this.activeLoadout.cards[slotIndex] = null;
        }
        this._checkSynergy();
    }

    equipWeapon(weaponId) {
        this.activeLoadout.weapon = weaponId;
    }

    unequipWeapon() {
        this.activeLoadout.weapon = null;
    }

    swapCards(slotIndexA, slotIndexB) {
        if (slotIndexA < 0 || slotIndexA >= 4 || slotIndexB < 0 || slotIndexB >= 4) return;
        const temp = this.activeLoadout.cards[slotIndexA];
        this.activeLoadout.cards[slotIndexA] = this.activeLoadout.cards[slotIndexB];
        this.activeLoadout.cards[slotIndexB] = temp;
        this._checkSynergy();
    }
    
    _checkSynergy() {
        const cards = this.getActiveLoadoutCards().filter(Boolean);
        if (cards.length < 4) {
            this.currentSynergy = { isValid: false, synergyName: 'Incomplete Build', description: 'Fill all 4 ability slots to activate a Synergy.' };
            return;
        }

        const counts = cards.reduce((acc, card) => {
            acc[card.element] = (acc[card.element] || 0) + 1;
            return acc;
        }, {});
        const elements = Object.keys(counts);

        if (elements.length === 1 && counts[elements[0]] === 4) {
            const el = elements[0];
            this.currentSynergy = { isValid: true, synergyName: `${el.toUpperCase()} MASTER`, description: `Energy costs for ${el} abilities are halved. Casting two ${el} abilities in quick succession triggers an Overload effect.`};
            return;
        }
        if (elements.length === 2 && counts[elements[0]] === 2 && counts[elements[1]] === 2) {
             const [el1, el2] = elements;
             this.currentSynergy = { isValid: true, synergyName: `ADEPT: ${el1.toUpperCase()}/${el2.toUpperCase()}`, description: `Unlocks a unique passive bonus based on the fusion of ${el1} and ${el2}.`};
             return;
        }
        if (elements.length === 2 && counts['Utility'] === 1) {
            const mainEl = elements.find(el => el !== 'Utility');
            if (mainEl && counts[mainEl] === 3) {
                 this.currentSynergy = { isValid: true, synergyName: `${mainEl.toUpperCase()} SPECIALIST`, description: `Cooldowns for your ${mainEl} abilities are reduced by 15%.`};
                 return;
            }
        }
        this.currentSynergy = { isValid: false, synergyName: 'Invalid Synergy', description: 'Builds must follow a 4, 2+2, or 3+1 (Utility) elemental pattern.' };
    }
    
    saveActiveLoadout(newName) {
        const name = newName.trim();
        if (!name) return;
        
        this.activeLoadout.name = name;
        this.playerProfile.savedLoadouts[name] = {
            name: name,
            weapon: this.activeLoadout.weapon,
            cards: [...this.activeLoadout.cards]
        };
    }
    
    switchActiveLoadout(loadoutName) {
        const saved = this.playerProfile.savedLoadouts[loadoutName];
        if (saved) {
            this.activeLoadout = {
                name: saved.name,
                weapon: saved.weapon,
                cards: [...saved.cards]
            };
            this.playerProfile.activeLoadoutName = loadoutName;
            this._checkSynergy();
        }
    }
    
    saveActiveLoadoutToLocalStorage() {
        const dataToSave = {
            name: this.activeLoadout.name,
            weapon: this.activeLoadout.weapon,
            cards: this.activeLoadout.cards
        };
        localStorage.setItem('activeLoadout', JSON.stringify(dataToSave));
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/LoadoutManager.js ===


=== FILE: src/client/ui/LoadoutUI.js ===
--------------------------------------------------
 import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { CardObject } from '../rendering/CardObject.js';
    import { CardParticleSystem } from '../rendering/CardParticleSystem.js';
    import { WeaponFactory } from '../../game/weapons/WeaponFactory.js';
    
    export class LoadoutUI {
        constructor(manager, abilityIconService) {
            this.manager = manager;
            this.abilityIconService = abilityIconService;
            this.elements = {
                inventoryPanel: document.getElementById('inventory-panel'),
                inventoryGrid: document.getElementById('inventory-grid'),
                
                playerPanel: document.getElementById('player-panel'),
                playerPreviewCanvas: document.getElementById('player-preview-canvas'),
                equippedSlotsContainer: document.getElementById('equipped-slots-container'),
                equippedSlots: document.querySelectorAll('.equipped-slot'),
                
                synergyName: document.getElementById('synergy-name'),
                synergyDescription: document.getElementById('synergy-description'),
                synergyDisplay: document.getElementById('synergy-display'),
    
                cardDetailsPanel: document.getElementById('card-details-panel'),
                detailsView2D: document.getElementById('details-view-2d'),
                detailsName: document.getElementById('details-name'),
                detailsElementTier: document.getElementById('details-element-tier'),
                detailsCost: document.getElementById('details-cost'),
                detailsCooldown: document.getElementById('details-cooldown'),
                detailsDescription: document.getElementById('details-description'),
                detailsFlavor: document.getElementById('details-flavor-text'),
                inspectBtn: document.getElementById('inspect-card-btn'),
    
                inspectorModal: document.getElementById('inspector-modal'),
                inspectionCanvas: document.getElementById('inspection-canvas'),
                inspectorModalCloseBtn: document.getElementById('inspector-modal-close-btn'),
    
                loadoutSelect: document.getElementById('loadout-select-dropdown'),
                loadoutNameInput: document.getElementById('loadout-name-input'),
                saveBtn: document.getElementById('save-loadout-btn'),
                backBtn: document.getElementById('back-to-menu-btn'),
                playBtn: document.getElementById('play-game-btn'),
            };
            this.selectedCardForInspect = null;
    
            this.inspector = {
                isActive: false,
                clock: new THREE.Clock(),
                scene: null, camera: null, renderer: null, controls: null,
                backgroundScene: null, backgroundCamera: null,
                activeMesh: null,
                activeCardObject: null, 
                particleSystem: null, 
                godRayPlane: null,
                tierLight: null,
                resizeObserver: null,
            };
        }
    
        init() {
            this.initPlayerPreview();
            this.initCardInspector();
            this.renderInventory();
            this.renderLoadout();
            this.renderLoadoutSelector();
            this.bindEventListeners();
        }
    
        initPlayerPreview() {
            const canvas = this.elements.playerPreviewCanvas;
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            camera.position.z = 3;
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 2, 3);
            scene.add(directionalLight);
            const playerGeo = new THREE.CapsuleGeometry(0.5, 1.0, 4, 8);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5 });
            const playerMesh = new THREE.Mesh(playerGeo, playerMat);
            playerMesh.position.y = -0.5;
            scene.add(playerMesh);
    
            const onResize = () => {
                if (!canvas.parentElement) return;
                const { clientWidth, clientHeight } = canvas.parentElement;
                renderer.setSize(clientWidth, clientHeight);
                camera.aspect = clientWidth / clientHeight;
                camera.updateProjectionMatrix();
            };
            onResize();
            new ResizeObserver(onResize).observe(canvas.parentElement);
            const animate = () => {
                requestAnimationFrame(animate);
                playerMesh.rotation.y += 0.005;
                renderer.render(scene, camera);
            };
            animate();
        }
    
        initCardInspector() {
            const canvas = this.elements.inspectionCanvas;
            this.inspector.scene = new THREE.Scene();
            this.inspector.backgroundScene = new THREE.Scene();
            this.inspector.camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
            this.inspector.backgroundCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            this.inspector.renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            this.inspector.renderer.setPixelRatio(window.devicePixelRatio);
            this.inspector.renderer.autoClear = false;
    
            this.inspector.camera.position.set(0, 0, 3.5);
            this.inspector.scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
            keyLight.position.set(2, 3, 3);
            this.inspector.scene.add(keyLight);
    
            this.inspector.controls = new OrbitControls(this.inspector.camera, this.inspector.renderer.domElement);
            this.inspector.controls.enableDamping = true;
            this.inspector.controls.enablePan = false;
            this.inspector.controls.minDistance = 2;
            this.inspector.controls.maxDistance = 6;
            
            this._animateInspector();
        }
    
        _animateInspector() {
            requestAnimationFrame(() => this._animateInspector());
            if (!this.inspector.isActive) return;
    
            const deltaTime = this.inspector.clock.getDelta();
            this.inspector.controls.update();
            this.inspector.activeCardObject?.update(deltaTime);
            this.inspector.particleSystem?.update(deltaTime);
            if (this.inspector.godRayPlane) this.inspector.godRayPlane.rotation.z += 0.001;
    
            const { renderer, backgroundScene, backgroundCamera, scene, camera } = this.inspector;
            renderer.clear();
            renderer.render(backgroundScene, backgroundCamera);
            renderer.clearDepth();
            renderer.render(scene, camera);
        }
        
        async showInspectorView(cardId) {
            if (!cardId) return;
            const cardData = this.manager.getCardDetails(cardId);
            if (!cardData) return;
    
            this._cleanupInspectorAssets();
            
            const tierColors = {
                1: new THREE.Color(0x3399ff),
                2: new THREE.Color(0xcc66ff),
                3: new THREE.Color(0xff6633),
                default: new THREE.Color(0xffffff)
            };
            const tierColor = tierColors[cardData.tier] || tierColors.default;
    
            if (cardData.type === 'Weapon') {
                const weapon = WeaponFactory.create(cardId);
                if (weapon?.mesh) {
                    this.inspector.activeMesh = weapon.mesh;
                }
            } else {
                this.inspector.activeCardObject = await CardObject.create(cardData);
                this.inspector.activeMesh = this.inspector.activeCardObject.mesh;
                this.inspector.particleSystem = new CardParticleSystem(this.inspector.scene, cardData.element);
            }
            
            if (this.inspector.activeMesh) {
                this.inspector.scene.add(this.inspector.activeMesh);
            }
    
            this._createGodRayPlane(tierColor);
            this.inspector.tierLight = new THREE.PointLight(tierColor, 10, 20, 1.5);
            this.inspector.tierLight.position.set(0, 0, -4);
            this.inspector.scene.add(this.inspector.tierLight);
            
            this.elements.inspectorModal.classList.add('active');
            this.inspector.isActive = true;
    
            const canvas = this.elements.inspectionCanvas;
            const { clientWidth, clientHeight } = canvas.parentElement;
            this.inspector.renderer.setSize(clientWidth, clientHeight);
            this.inspector.camera.aspect = clientWidth / clientHeight;
            this.inspector.camera.updateProjectionMatrix();
    
            if (!this.inspector.resizeObserver) {
                const onResize = () => {
                    if (!this.inspector.isActive || !canvas.parentElement) return;
                    const { clientWidth, clientHeight } = canvas.parentElement;
                    this.inspector.renderer.setSize(clientWidth, clientHeight);
                    this.inspector.camera.aspect = clientWidth / clientHeight;
                    this.inspector.camera.updateProjectionMatrix();
                };
                this.inspector.resizeObserver = new ResizeObserver(onResize);
                this.inspector.resizeObserver.observe(canvas.parentElement);
            }
        }
    
        hideInspectorView() {
            this.inspector.isActive = false;
            this._cleanupInspectorAssets();
            this.elements.inspectorModal.classList.remove('active');
    
            if (this.inspector.resizeObserver) {
                this.inspector.resizeObserver.disconnect();
                this.inspector.resizeObserver = null;
            }
        }
    
        _cleanupInspectorAssets() {
            if (this.inspector.activeMesh) {
                this.inspector.scene.remove(this.inspector.activeMesh);
                this.inspector.activeMesh = null;
            }
            if (this.inspector.activeCardObject) {
                this.inspector.activeCardObject.dispose();
                this.inspector.activeCardObject = null;
            }
            if (this.inspector.particleSystem) {
                this.inspector.particleSystem.dispose();
                this.inspector.particleSystem = null;
            }
            if (this.inspector.godRayPlane) {
                 this.inspector.backgroundScene.remove(this.inspector.godRayPlane);
                 this.inspector.godRayPlane.geometry.dispose();
                 this.inspector.godRayPlane.material.map?.dispose();
                 this.inspector.godRayPlane.material.dispose();
                 this.inspector.godRayPlane = null;
            }
            if (this.inspector.tierLight) {
                this.inspector.scene.remove(this.inspector.tierLight);
                this.inspector.tierLight.dispose();
                this.inspector.tierLight = null;
            }
        }
    
        _createGodRayPlane(color) {
            if (this.inspector.godRayPlane) {
                this.inspector.backgroundScene.remove(this.inspector.godRayPlane);
                this.inspector.godRayPlane.geometry.dispose();
                this.inspector.godRayPlane.material.map?.dispose();
                this.inspector.godRayPlane.material.dispose();
            }
    
            const canvas = document.createElement('canvas');
            const size = 512;
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d'), centerX = size / 2, centerY = size / 2;
            
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size / 2);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
    
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1.5;
            for(let i=0; i < 100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const length = size * 0.4 + (Math.random() * size * 0.3);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * length, centerY + Math.sin(angle) * length);
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, color, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
            this.inspector.godRayPlane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
            this.inspector.backgroundScene.add(this.inspector.godRayPlane);
        }
        
        renderInventory() {
            this.elements.inventoryGrid.innerHTML = '';
            const inventoryItems = this.manager.getInventoryItems('all');
            inventoryItems.forEach(item => {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.appendChild(this.createCardElement(item));
                this.elements.inventoryGrid.appendChild(slot);
            });
        }
    
        renderLoadout() {
            const loadoutCards = this.manager.getActiveLoadoutCards();
            const equippedWeapon = this.manager.getActiveWeapon();
    
            this.elements.equippedSlots.forEach((slot) => {
                slot.innerHTML = '';
                const slotType = slot.dataset.slotType;
                if (slotType === 'ability') {
                    const index = parseInt(slot.dataset.slotIndex, 10);
                    const card = loadoutCards[index];
                    if (card) slot.appendChild(this.createCardElement(card));
                } else if (slotType === 'weapon') {
                    if (equippedWeapon) slot.appendChild(this.createCardElement(equippedWeapon));
                }
            });
            this.renderSynergy();
        }
    
        renderSynergy() {
            const { isValid, synergyName, description } = this.manager.currentSynergy;
            this.elements.synergyName.textContent = synergyName;
            this.elements.synergyDescription.textContent = description;
            this.elements.synergyDisplay.className = 'synergy-display ' + (isValid ? 'synergy-valid' : 'synergy-invalid');
            this.elements.playBtn.disabled = false;
        }
    
        renderLoadoutSelector() {
            this.elements.loadoutSelect.innerHTML = '';
            Object.keys(this.manager.playerProfile.savedLoadouts).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                this.elements.loadoutSelect.appendChild(option);
            });
            this.elements.loadoutSelect.value = this.manager.activeLoadout.name;
            this.elements.loadoutNameInput.value = this.manager.activeLoadout.name;
        }
    
        createCardElement(cardData) {
            const el = document.createElement('div');
            el.className = `card-item tier-${cardData.tier}`;
            el.draggable = true;
            el.dataset.cardId = cardData.id;
            el.dataset.cardType = cardData.type || 'Ability';
    
            const iconContainer = document.createElement('div');
            iconContainer.className = 'card-item-icon';
            el.appendChild(iconContainer);
            
            if (cardData.type === 'Weapon') {
                el.classList.add('type-weapon');
            } else {
                el.classList.add(`element-${cardData.element.toLowerCase()}`);
                this.abilityIconService.generate(cardData).then(iconUrl => {
                    if (iconUrl) iconContainer.style.backgroundImage = `url(${iconUrl})`;
                }).catch(err => console.error(`Failed to generate icon for ${cardData.name}:`, err));
            }
    
            const textWrapper = document.createElement('div');
            textWrapper.className = 'card-item-text';
            textWrapper.innerHTML = `
                <span class="card-item-name">${cardData.name}</span>
                <span class="card-item-type">${cardData.type}</span>
            `;
            el.appendChild(textWrapper);
            
            el.onclick = (e) => {
                e.stopPropagation();
                this.selectForInspect(cardData.id);
            };
            return el;
        }
        
        selectForInspect(cardId) {
            document.querySelectorAll('.card-item.selected').forEach(el => el.classList.remove('selected'));
            if (!cardId) {
                this.selectedCardForInspect = null;
                this.elements.inspectBtn.disabled = true;
                this.renderCardDetails(null);
                return;
            }
    
            const cardData = this.manager.getCardDetails(cardId);
            this.renderCardDetails(cardData);
            
            document.querySelectorAll(`.card-item[data-card-id="${cardId}"]`).forEach(el => el.classList.add('selected'));
            
            this.selectedCardForInspect = cardId;
            this.elements.inspectBtn.disabled = false;
        }
    
        renderCardDetails(card) {
            if (card) {
                this.elements.detailsName.textContent = card.name;
                this.elements.detailsElementTier.textContent = `${card.element} - Tier ${card.tier}`;
                this.elements.detailsCost.textContent = card.energyCost ? `Cost: ${card.energyCost}` : '';
                this.elements.detailsCooldown.textContent = card.cooldown ? `CD: ${card.cooldown}s` : '';
                this.elements.detailsDescription.textContent = card.description;
                this.elements.detailsFlavor.textContent = `"${card.flavor}"`;
            } else {
                this.elements.detailsName.textContent = 'SELECT A CARD';
                this.elements.detailsElementTier.textContent = 'Click a card to see its details.';
                this.elements.detailsCost.textContent = '';
                this.elements.detailsCooldown.textContent = '';
                this.elements.detailsDescription.textContent = '';
                this.elements.detailsFlavor.textContent = '';
            }
        }
    
        bindEventListeners() {
            this.elements.inspectBtn.onclick = () => this.showInspectorView(this.selectedCardForInspect);
            this.elements.inspectorModalCloseBtn.onclick = () => this.hideInspectorView();
            this.elements.inspectorModal.onclick = (e) => {
                if (e.target === this.elements.inspectorModal) this.hideInspectorView();
            };
    
            let draggedElement = null;
            document.body.addEventListener('dragstart', e => {
                if (e.target.matches('.card-item')) {
                    draggedElement = e.target;
                    setTimeout(() => e.target.classList.add('dragging'), 0);
                    const data = { cardId: e.target.dataset.cardId, cardType: e.target.dataset.cardType };
                    const sourceSlotEl = e.target.closest('.equipped-slot');
                    if (sourceSlotEl) data.sourceType = sourceSlotEl.dataset.slotType;
                    if (sourceSlotEl?.dataset.slotIndex) data.sourceIndex = sourceSlotEl.dataset.slotIndex;
                    e.dataTransfer.setData('application/json', JSON.stringify(data));
                    e.dataTransfer.effectAllowed = 'move';
                }
            });
            document.body.addEventListener('dragend', () => {
                draggedElement?.classList.remove('dragging');
                draggedElement = null;
                this.elements.inventoryPanel.classList.remove('inventory-drag-over');
            });
    
            this.elements.equippedSlots.forEach(slot => {
                slot.addEventListener('dragover', e => { e.preventDefault(); slot.classList.add('drag-over'); });
                slot.addEventListener('dragleave', () => slot.classList.remove('drag-over'));
                slot.addEventListener('drop', e => {
                    e.preventDefault();
                    slot.classList.remove('drag-over');
                    try {
                        const data = JSON.parse(e.dataTransfer.getData('application/json'));
                        if (!data.cardId) return;
    
                        const targetSlotType = slot.dataset.slotType;
                        if (data.cardType.toLowerCase() !== targetSlotType) return;
    
                        if (targetSlotType === 'weapon') {
                            this.manager.equipWeapon(data.cardId);
                        } else if (targetSlotType === 'ability') {
                            const targetIndex = parseInt(slot.dataset.slotIndex, 10);
                            if (data.sourceType === 'ability') {
                                const sourceIndex = parseInt(data.sourceIndex, 10);
                                this.manager.swapCards(sourceIndex, targetIndex);
                            } else {
                                this.manager.equipCard(data.cardId, targetIndex);
                            }
                        }
                        this.renderLoadout();
                        this.renderInventory();
                    } catch (err) { console.warn("Drop on slot failed.", err); }
                });
            });
    
            const inventoryPanel = this.elements.inventoryPanel;
            inventoryPanel.addEventListener('dragover', e => {
                e.preventDefault();
                inventoryPanel.classList.add('inventory-drag-over');
            });
            inventoryPanel.addEventListener('dragleave', () => inventoryPanel.classList.remove('inventory-drag-over'));
            inventoryPanel.addEventListener('drop', e => {
                e.preventDefault();
                inventoryPanel.classList.remove('inventory-drag-over');
                try {
                    const data = JSON.parse(e.dataTransfer.getData('application/json'));
                    if (data.sourceType === 'ability') {
                        this.manager.unequipCard(parseInt(data.sourceIndex, 10));
                    } else if (data.sourceType === 'weapon') {
                        this.manager.unequipWeapon();
                    }
                    this.renderLoadout();
                    this.renderInventory();
                } catch (err) { console.warn("Drop on inventory failed.", err); }
            });
    
            this.elements.saveBtn.onclick = () => { this.manager.saveActiveLoadout(this.elements.loadoutNameInput.value); this.renderLoadoutSelector(); };
            this.elements.loadoutSelect.onchange = (e) => { this.manager.switchActiveLoadout(e.target.value); this.elements.loadoutNameInput.value = e.target.value; this.renderLoadout(); this.renderInventory(); };
            this.elements.backBtn.onclick = () => window.location.href = 'index.html';
            this.elements.playBtn.onclick = () => { this.manager.saveActiveLoadoutToLocalStorage(); window.location.href = 'index.html?showLevelSelect=true'; };
            document.body.addEventListener('click', () => { if(!this.inspector.isActive) this.selectForInspect(null); });
        }
    }
--------------------------------------------------
=== END OF FILE: src/client/ui/LoadoutUI.js ===


=== FILE: src/client/ui/loadout_main.js ===
--------------------------------------------------
// src/client/ui/loadout_main.js
import { LoadoutManager } from './LoadoutManager.js';
import { LoadoutUI } from './LoadoutUI.js';
import { AbilityIconService } from './AbilityIconService.js';

class LoadoutApplication {
    constructor() {
        this.manager = new LoadoutManager();
        this.abilityIconService = new AbilityIconService();
        this.ui = new LoadoutUI(this.manager, this.abilityIconService);
    }

    async init() {
        try {
            await this.manager.init();
            this.ui.init();
        } catch(error) {
            console.error("Failed to initialize Loadout Application:", error);
            document.body.innerHTML = `<div style="color:red; text-align:center; margin-top: 50px;">
                <h1>Loadout Failed to Start</h1>
                <p>Could not load card or player data. Please check console.</p>
            </div>`;
        }
    }
}

const app = new LoadoutApplication();
app.init();
--------------------------------------------------
=== END OF FILE: src/client/ui/loadout_main.js ===


=== FILE: src/client/ui/TutorialManager.js ===
--------------------------------------------------
/**
 * Handles the display of tutorial messages.
 * In the new architecture, this class is simplified to be a pure view-layer component.
 * It receives events and displays text via the UIManager/HUD.
 */
export class TutorialManager {
    constructor() {
        this.hudElements = null;
        this.tutorialTimer = null;
    }

    registerHud(hud) {
        this.hudElements = hud.elements;
    }

    // Called by an event listener when a tutorial trigger is activated in the game world.
    onTriggerActivated(data) {
        if (!this.hudElements) return;

        this.showTutorialText(data.message, data.duration);
    }
    
    showTutorialText(message, duration) {
        if (this.tutorialTimer) clearTimeout(this.tutorialTimer);
        
        const container = this.hudElements.tutorialContainer;
        container.classList.remove('level-complete');
        
        this.hudElements.tutorialText.innerHTML = message;
        container.style.opacity = '1';
        container.style.display = 'block';
        
        if (duration > 0) {
            this.tutorialTimer = setTimeout(() => {
                this.hideTutorialText();
            }, duration * 1000);
        }
    }

    hideTutorialText() {
        const container = this.hudElements.tutorialContainer;
        container.style.opacity = '0';
        setTimeout(() => {
            if (!container.classList.contains('level-complete')) {
                 container.style.display = 'none';
            }
        }, 500); // Must match the CSS transition duration
    }
    
    showLevelCompleted() {
        if (this.tutorialTimer) clearTimeout(this.tutorialTimer);
        const container = this.hudElements.tutorialContainer;
        this.hudElements.tutorialText.textContent = 'LEVEL COMPLETE';
        container.classList.add('level-complete');
        container.style.opacity = '1';
        container.style.display = 'block';
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/TutorialManager.js ===


=== FILE: src/client/ui/UIManager.js ===
--------------------------------------------------
// src/client/ui/UIManager.js
import { HUD } from './HUD.js';
import { Minimap } from '../rendering/Minimap.js';
import { TutorialManager } from './TutorialManager.js';
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Central controller for all UI interactions, screens, and HUD elements.
 * It acts as the bridge between the game state and the DOM.
 */
export class UIManager {
    constructor(abilityIconService) {
        this.screens = {
            mainMenu: document.getElementById('main-menu'),
            levelSelect: document.getElementById('level-select-menu'),
            pauseMenu: document.getElementById('pause-menu'),
            deathScreen: document.getElementById('death-screen'),
        };

        this.elements = {
            levelList: document.getElementById('level-list'),
            respawnTimerText: document.getElementById('respawn-timer-text'),
            loadCustomLevelBtn: document.getElementById('load-custom-level-btn'),
            customLevelInput: document.getElementById('custom-level-input'),
            resumeBtn: document.getElementById('resume-btn'),
            pauseQuitBtn: document.getElementById('pause-quit-btn'),
            deathQuitBtn: document.getElementById('death-quit-btn'),
            energyBarContainer: document.getElementById('energy-bar-container'),
        };

        this.hud = new HUD(abilityIconService);
        this.minimap = new Minimap();
        this.tutorialManager = new TutorialManager();
        this.tutorialManager.registerHud(this.hud);

        this.customLevelPlayBtn = null;
    }

    _getLoadout() {
        const saved = localStorage.getItem('activeLoadout');
        return saved ? JSON.parse(saved) : { cards: [null, null, null, null], weapon: null };
    }
    
    showScreen(screenName) {
        Object.values(this.screens).forEach(screen => { if (screen) screen.style.display = 'none' });
        if (this.screens[screenName]) {
            this.screens[screenName].style.display = 'flex';
        }
    }

    setLoading(isLoading) {
        if (isLoading) {
            this.showScreen('mainMenu');
            this.screens.mainMenu.innerHTML = '<h2>Loading...</h2>';
        } else {
            this.screens.mainMenu.innerHTML = `
                <h1>ELEMENTALS</h1>
                <div class="menu-options">
                    <button id="play-btn">Play</button>
                    <button id="loadout-btn">Loadout</button>
                    <button id="editor-btn">Level Editor</button>
                </div>`;
        }
    }

    bindGame(game) {
        const setupMainMenuListeners = () => {
            const playBtn = document.getElementById('play-btn');
            const loadoutBtn = document.getElementById('loadout-btn');
            const editorBtn = document.getElementById('editor-btn');

            if (playBtn) playBtn.onclick = () => {
                this.populateLevelList(game);
                this.showScreen('levelSelect');
            };
            if (loadoutBtn) loadoutBtn.onclick = () => { window.location.href = 'loadout.html'; };
            if (editorBtn) editorBtn.onclick = () => { window.location.href = 'editor.html'; };
        };
        
        setupMainMenuListeners();
        game.on('mainMenuRendered', setupMainMenuListeners);
        game.on('abilityCastFailed', (data) => this.onAbilityCastFailed(data));

        this.elements.loadCustomLevelBtn.onclick = () => this.elements.customLevelInput.click();
        this.elements.customLevelInput.onchange = (e) => this.handleCustomLevelSelect(e, game);
        document.querySelectorAll('.back-button').forEach(btn => 
            btn.onclick = () => this.showScreen(btn.dataset.target.replace('-',''))
        );

        this.elements.resumeBtn.onclick = () => game.requestPointerLock();
        this.elements.pauseQuitBtn.onclick = () => game.returnToMenu();
        this.elements.deathQuitBtn.onclick = () => game.returnToMenu();
    }

    async populateLevelList(game) {
        try {
            const response = await fetch('./levels/manifest.json');
            const levels = await response.json();
            this.elements.levelList.innerHTML = '';
            
            for (const level of levels) {
                const btn = document.createElement('button');
                btn.textContent = level.name;
                btn.onclick = () => game.startLevel({ 
                    url: level.path,
                    loadout: this._getLoadout() 
                });
                this.elements.levelList.appendChild(btn);
            }
        } catch (error) {
            console.error("Could not load level manifest:", error);
            this.elements.levelList.innerHTML = '<p style="color: #ff4757;">Could not load levels.</p>';
        }
    }

    handleCustomLevelSelect(event, game) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const levelData = JSON.parse(e.target.result);
                this.prepareCustomLevel(levelData, game);
            } catch (err) {
                alert("Invalid or corrupt level file.");
            } finally {
                event.target.value = ''; 
            }
        };
        reader.readAsText(file);
    }

    prepareCustomLevel(data, game) {
        if (this.customLevelPlayBtn && this.customLevelPlayBtn.parentElement) {
            this.customLevelPlayBtn.parentElement.removeChild(this.customLevelPlayBtn);
        }
        const levelName = data.name || 'Custom Level';
        this.customLevelPlayBtn = document.createElement('button');
        this.customLevelPlayBtn.textContent = `Play: ${levelName}`;
        this.customLevelPlayBtn.style.borderColor = '#2ed573';
        this.customLevelPlayBtn.onclick = () => game.startLevel({ data, loadout: this._getLoadout() });
        this.screens.levelSelect.appendChild(this.customLevelPlayBtn);
    }

    onAbilityCastFailed(data) {
        if (data.reason === 'insufficient_energy') {
            this.flashEnergyBar();
        } else if (data.reason === 'on_cooldown' && data.ability) {
            const player = data.entity;
            const abilityIndex = player.abilities.abilities.indexOf(data.ability);
            if (abilityIndex !== -1) {
                this.flashAbilitySlotError(abilityIndex);
            }
        }
    }

    flashEnergyBar() {
        const container = this.elements.energyBarContainer;
        if (!container || container.classList.contains('flash-error')) return;
        container.classList.add('flash-error');
        container.addEventListener('animationend', () => {
            container.classList.remove('flash-error');
        }, { once: true });
    }

    flashAbilitySlotError(index) {
        const slot = this.hud.elements.abilitySlots[index]?.element;
        if (!slot || slot.classList.contains('flash-cooldown-error')) return;
        slot.classList.add('flash-cooldown-error');
        slot.addEventListener('animationend', () => {
            slot.classList.remove('flash-cooldown-error');
        }, { once: true });
    }

    update(game) {
        if (!game || !game.world) return;
        
        const player = game.world.player;
        if (!player) return;

        this.hud.updateResources(
            player.health.currentHealth, player.health.maxHealth, 
            player.abilities.currentEnergy, player.abilities.maxEnergy
        );
        this.hud.updateMovementCooldowns(
            player.doubleJumpCooldownTimer, GAME_CONFIG.PLAYER.DOUBLE_JUMP_COOLDOWN,
            player.dashCooldownTimer, GAME_CONFIG.PLAYER.DASH_COOLDOWN,
            player.doubleJumpOnCooldown,
            player.dashOnCooldown
        );
        this.hud.updateAbilities(player.abilities.abilities, player.abilities.selectedAbilityIndex);
        this.hud.updateAmmo(player.weapon);
        this.hud.updateTargeting(
            player.abilities.abilities[player.abilities.selectedAbilityIndex]?.requiresLockOn, 
            player.lockedTarget,
            game.core.renderer.camera
        );
        this.hud.updateEnemyCount(game.world.enemiesKilled, game.world.initialEnemyCount);
        this.minimap.update(player, game.world.getEnemies(), game.world.getLevelObjects());
        
        if (game.gameState === 'DEAD') {
            this.elements.respawnTimerText.textContent = `Respawning in ${Math.ceil(game.respawnTimer)}...`;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/client/ui/UIManager.js ===


=== FILE: src/core/AssetManager.js ===
--------------------------------------------------
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

export class AssetManager {
    constructor() {
        this.textureLoader = new THREE.TextureLoader();
        this.gltfLoader = new GLTFLoader();
        
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
        this.gltfLoader.setDRACOLoader(dracoLoader);
        
        this.cache = new Map();
        this.loadingPromises = [];
    }

    _loadTexture(name, path) {
        const promise = new Promise((resolve, reject) => {
            if (this.cache.has(name)) {
                resolve(this.cache.get(name));
                return;
            }
            this.textureLoader.load(
                path,
                (texture) => {
                    this.cache.set(name, texture);
                    resolve(texture);
                },
                undefined, // onProgress
                (error) => {
                    console.error(`Failed to load texture: ${name} from ${path}`, error);
                    reject(error);
                }
            );
        });
        this.loadingPromises.push(promise);
    }
    
    _loadGLTF(name, path) {
        const promise = new Promise((resolve, reject) => {
            if (this.cache.has(name)) {
                resolve(this.cache.get(name));
                return;
            }
            this.gltfLoader.load(
                path,
                (gltf) => {
                    this.cache.set(name, gltf);
                    resolve(gltf);
                },
                undefined, // onProgress
                (error) => {
                    console.error(`Failed to load GLTF model: ${name} from ${path}`, error);
                    reject(error);
                }
            );
        });
        this.loadingPromises.push(promise);
    }
    
    _loadAudio(name, path) {
        const promise = new Promise((resolve, reject) => {
             if (this.cache.has(name)) {
                resolve(this.cache.get(name));
                return;
            }
            const audio = new Audio(path);
            audio.addEventListener('canplaythrough', () => {
                this.cache.set(name, audio);
                resolve(audio);
            }, { once: true });
            audio.addEventListener('error', (e) => {
                console.error(`Failed to load audio: ${name} from ${path}`, e);
                reject(e);
            });
        });
        this.loadingPromises.push(promise);
    }

    queue(assets) {
        for (const asset of assets) {
            switch(asset.type) {
                case 'texture':
                    this._loadTexture(asset.name, asset.path);
                    break;
                case 'gltf':
                    this._loadGLTF(asset.name, asset.path);
                    break;
                case 'audio':
                    this._loadAudio(asset.name, asset.path);
                    break;
                default:
                    console.warn(`Unknown asset type: ${asset.type}`);
            }
        }
    }

    async loadAll() {
        try {
            await Promise.all(this.loadingPromises);
        } catch (error) {
            console.error("An error occurred during asset loading.", error);
        } finally {
            this.loadingPromises = [];
        }
    }

    get(name) {
        if (!this.cache.has(name)) {
            throw new Error(`Asset not found in cache: ${name}`);
        }
        return this.cache.get(name);
    }
}
--------------------------------------------------
=== END OF FILE: src/core/AssetManager.js ===


=== FILE: src/core/InputManager.js ===
--------------------------------------------------
// src/core/InputManager.js

import { EventEmitter } from '../shared/EventEmitter.js';

export class InputManager extends EventEmitter {
    constructor() {
        super();
        this.keys = {};
        this.mouse = {
            movementX: 0,
            movementY: 0,
            leftClick: false,
            rightClick: false,
            screenX: 0,
            screenY: 0,
        };
        this.enabled = true;

        this._onKeyDown = this._onKeyDown.bind(this);
        this._onKeyUp = this._onKeyUp.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseDown = this._onMouseDown.bind(this);
        this._onMouseUp = this._onMouseUp.bind(this);
        
        this.addEventListeners();
    }

    addEventListeners() {
        document.addEventListener('keydown', this._onKeyDown);
        document.addEventListener('keyup', this._onKeyUp);
        document.addEventListener('mousemove', this._onMouseMove);
        document.addEventListener('mousedown', this._onMouseDown);
        document.addEventListener('mouseup', this._onMouseUp);
    }

    _onKeyDown(e) {
        // Emit a singlePress event only on the initial press
        if (!this.keys[e.code]) {
            this.emit('singlePress', e);
        }
        this.keys[e.code] = true;
    }
    _onKeyUp(e) { this.keys[e.code] = false; }
    
    _onMouseDown(e) {
        if (e.button === 0) this.mouse.leftClick = true;
        if (e.button === 2) this.mouse.rightClick = true;
    }

    _onMouseUp(e) {
        if (e.button === 0) this.mouse.leftClick = false;
        if (e.button === 2) this.mouse.rightClick = false;
    }

    _onMouseMove(e) {
        this.mouse.screenX = e.clientX;
        this.mouse.screenY = e.clientY;
        this.mouse.movementX = e.movementX;
        this.mouse.movementY = e.movementY;
    }

    update() {
        this.mouse.movementX = 0;
        this.mouse.movementY = 0;
    }
    
    dispose() {
        document.removeEventListener('keydown', this._onKeyDown);
        document.removeEventListener('keyup', this._onKeyUp);
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mousedown', this._onMouseDown);
        document.removeEventListener('mouseup', this._onMouseUp);
    }
}
--------------------------------------------------
=== END OF FILE: src/core/InputManager.js ===


=== FILE: src/core/Physics.js ===
--------------------------------------------------
import * as CANNON from 'cannon-es';

export class Physics {
    constructor() {
        this.world = new CANNON.World({
            gravity: new CANNON.Vec3(0, -9.82, 0),
            allowSleep: true,
        });

        this.world.broadphase = new CANNON.SAPBroadphase(this.world);

        this.bodiesToRemove = new Set();
    }

    addContactMaterial(material) {
        this.world.addContactMaterial(material);
    }

    addBody(body) {
        this.world.addBody(body);
    }

    queueForRemoval(body) {
        if (body) {
            this.bodiesToRemove.add(body);
        }
    }
    
    _removeQueuedBodies() {
        if (this.bodiesToRemove.size > 0) {
            for (const body of this.bodiesToRemove) {
                this.world.removeBody(body);
            }
            this.bodiesToRemove.clear();
        }
    }

    update(deltaTime) {
        this.world.step(1 / 60, deltaTime, 3);
        this._removeQueuedBodies();
    }
}
--------------------------------------------------
=== END OF FILE: src/core/Physics.js ===


=== FILE: src/core/Renderer.js ===
--------------------------------------------------
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

export class Renderer {
    constructor(canvasElement) {
        if (!canvasElement) {
            throw new Error('Renderer requires a canvas element.');
        }

        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            canvas: canvasElement,
            powerPreference: 'high-performance'
        });
        
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        
        this.composer = null;
        this.bloomPass = null;

        this._onWindowResize = this._onWindowResize.bind(this);
        window.addEventListener('resize', this._onWindowResize);
    }
    
    setupPostProcessing(mainScene, camera, viewModelScene = null) {
        this.composer = new EffectComposer(this.renderer);
        this.composer.addPass(new RenderPass(mainScene, camera));

        if (viewModelScene) {
            const viewModelPass = new RenderPass(viewModelScene, camera);
            viewModelPass.clear = false;
            viewModelPass.clearDepth = true;
            this.composer.addPass(viewModelPass);
        }
        
        this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        this.bloomPass.threshold = 0.9;
        this.bloomPass.strength = 0.7;
        this.bloomPass.radius = 0.5;
        this.composer.addPass(this.bloomPass);
    }
    
    _onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        if (this.composer) {
            this.composer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    render() {
        if (this.composer) {
            this.composer.render();
        } else {
            this.renderer.render(this.scene, this.camera);
        }
    }
    
    dispose() {
        window.removeEventListener('resize', this._onWindowResize);
        this.renderer.dispose();
    }
}
--------------------------------------------------
=== END OF FILE: src/core/Renderer.js ===


=== FILE: src/editor/EditorActions.js ===
--------------------------------------------------
// ~ src/editor/EditorActions.js

import * as THREE from 'three';
import { StateChangeCommand } from './UndoManager.js';

export class EditorActions {
    constructor(editor) {
        this.editor = editor;
        this.app = editor.app;
        this.camera = editor.camera;
    }

    _createAndExecuteCreationCommand(entity) {
        const command = {
            execute: () => {
                this.app.add(entity);
                this.editor.select(entity);
            },
            undo: () => {
                // Remove without disposing so it can be redone
                this.app.remove(entity, false);
                this.editor.deselect();
            }
        };
        this.editor.undoManager.execute(command);
    }

    addBox() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
        const boxData = {
            type: "Box", name: `Box_${Date.now()}`, size: [2, 2, 2],
            position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
            rotation: { x: 0, y: 0, z: 0 },
            material: { color: "0xcccccc" }, physics: { mass: 0 }
        };
        const newObj = this.app.levelManager.createObject(boxData);
        this._createAndExecuteCreationCommand(newObj);
    }
    
    addEnemy() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
        const enemyData = { type: "Dummy", position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z } };
        const newEnemy = this.app.levelManager.createEnemy(enemyData);
        this._createAndExecuteCreationCommand(newEnemy);
    }

    addMessageTrigger() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
        const triggerData = {
            type: "Trigger", name: `MessageTrigger_${Date.now()}`, size: [5, 5, 5],
            position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
            rotation: { x: 0, y: 0, z: 0 },
            message: "This is a test message.",
            duration: 5,
            color: "0x00ff00"
        };
        const newTrigger = this.app.levelManager.createTrigger(triggerData, 'Trigger');
        this._createAndExecuteCreationCommand(newTrigger);
    }

    addDeathTrigger() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(10));
        const triggerData = {
            type: "DeathTrigger", name: `DeathZone_${Date.now()}`, size: [10, 2, 10],
            position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
            rotation: { x: 0, y: 0, z: 0 },
        };
        const newTrigger = this.app.levelManager.createTrigger(triggerData, 'DeathTrigger');
        this._createAndExecuteCreationCommand(newTrigger);
    }

    addDirectionalLight() {
        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(20));

        const lightData = {
            color: "0xffffff",
            intensity: 1,
            position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
            targetPosition: { x: 0, y: 0, z: 0 }
        };
        
        const newLight = this.app.levelManager.createDirectionalLight(lightData);
        const newLightObject = this.app.createDirectionalLightWithHelper(newLight);
        this._createAndExecuteCreationCommand(newLightObject);
    }

    deleteSelected() {
        if (!this.editor.selectedObject) return;
        const entity = this.editor.selectedObject;
        const entityType = entity.userData.gameEntity.type;
        
        if (['SpawnPoint', 'DeathSpawnPoint'].includes(entityType)) return;
    
        const definition = JSON.parse(JSON.stringify(entity.definition));
        let recreatedEntity = null; // Closure variable
    
        const command = {
            execute: () => {
                const entityToRemove = recreatedEntity || entity;
                this.app.remove(entityToRemove);
                this.editor.deselect();
                recreatedEntity = null;
            },
            undo: () => {
                recreatedEntity = this.app.levelManager.recreateEntity(definition);
                if (recreatedEntity) {
                    this.app.add(recreatedEntity);
                    this.editor.select(recreatedEntity);
                }
            }
        };
        this.editor.undoManager.execute(command);
    }
    
    _bakeScaleIntoDefinition(entity) {
        if (entity && entity.mesh && entity.definition?.size) {
            const scale = entity.mesh.scale;
            if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
                entity.definition.size[0] *= scale.x;
                entity.definition.size[1] *= scale.y;
                entity.definition.size[2] *= scale.z;
                scale.set(1, 1, 1);
                this.editor.applyDefinition(entity);
            }
        }
    }
    
    copySelected() {
        if (!this.editor.selectedObject) return;
        
        const entity = this.editor.selectedObject;
        const entityType = entity.userData?.gameEntity?.type;
        const validTypes = ['Object', 'Enemy', 'Trigger', 'DeathTrigger'];
    
        if (validTypes.includes(entityType)) {
            this._bakeScaleIntoDefinition(entity); // Bake scale into definition size
            this.editor.syncObjectTransforms(); // Sync position to definition
    
            // Manually sync rotation into definition
            if (entity.definition.rotation) {
                const rot = new THREE.Euler().setFromQuaternion(entity.mesh.quaternion, 'YXZ');
                entity.definition.rotation = {
                    x: THREE.MathUtils.radToDeg(rot.x),
                    y: THREE.MathUtils.radToDeg(rot.y),
                    z: THREE.MathUtils.radToDeg(rot.z)
                };
            }
            
            this.editor.clipboard = JSON.parse(JSON.stringify(entity.definition));
        } else {
            this.editor.clipboard = null;
        }
    }

    pasteFromClipboard() {
        if (!this.editor.clipboard) return;

        const lookDir = new THREE.Vector3();
        this.camera.getWorldDirection(lookDir);
        const spawnPos = new THREE.Vector3().copy(this.camera.position).add(lookDir.multiplyScalar(15));
        
        const newDef = JSON.parse(JSON.stringify(this.editor.clipboard));
        newDef.position = { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z };
        newDef.name = `${newDef.name || newDef.type}_copy`;

        let newEntity;
        switch(newDef.type) {
            case 'Dummy':
                newEntity = this.app.levelManager.createEnemy(newDef);
                break;
            case 'Trigger':
                newEntity = this.app.levelManager.createTrigger(newDef, 'Trigger');
                break;
            case 'DeathTrigger':
                newEntity = this.app.levelManager.createTrigger(newDef, 'DeathTrigger');
                break;
            default:
                newEntity = this.app.levelManager.createObject(newDef);
                break;
        }
        
        if (newEntity) this._createAndExecuteCreationCommand(newEntity);
    }

    newLevel() {
        const newLevelData = {
            name: "New Level",
            spawnPoint: { x: 0, y: 3, z: 0 },
            deathSpawnPoint: { x: 0, y: 3, z: 0 },
            settings: {
                backgroundColor: "0x1d2938",
                fogColor: "0x1d2938",
                fogNear: 20,
                fogFar: 150,
                ambientLight: {
                    color: "0x607080",
                    intensity: 0.7
                },
                directionalLights: [
                    {
                        color: "0xffffff",
                        intensity: 1.5,
                        position: { x: -0.19, y: 100, z: 94.33 },
                        targetPosition: { x: 0, y: 0, z: 0 }
                    }
                ]
            },
            objects: [
                {
                    "type": "Plane",
                    "name": "Ground Plane",
                    "size": [200, 200],
                    "position": { "x": 0, "y": 0, "z": 0 },
                    "rotation": { "x": -90, "y": 0, "z": 0 },
                    "material": { "color": "0x334455", "roughness": 0.9 },
                    "physics": { "mass": 0 },
                    "editorSelectable": false
                }
            ],
            enemies: [],
            triggers: [],
            deathTriggers: []
        };
        this.app.loadLevel(newLevelData);
    }

    loadFile(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try { this.app.loadLevel(JSON.parse(e.target.result)); } 
            catch (err) { alert("Invalid level file."); console.error("Error loading level:", err); }
        };
        reader.readAsText(file);
    }

    getSerializableLevelData() {
        const entities = [...this.app.entities];
        
        entities.forEach(obj => {
            this._bakeScaleIntoDefinition(obj);
            if (!obj.definition || !obj.mesh) return;
            obj.definition.position = { x: obj.mesh.position.x, y: obj.mesh.position.y, z: obj.mesh.position.z };
            if (obj.definition.rotation) {
                const rot = new THREE.Euler().setFromQuaternion(obj.mesh.quaternion, 'YXZ');
                obj.definition.rotation = { x: THREE.MathUtils.radToDeg(rot.x), y: THREE.MathUtils.radToDeg(rot.y), z: THREE.MathUtils.radToDeg(rot.z) };
            }
        });

        this.app.getDirectionalLights().forEach(lightObj => {
            lightObj.definition.position = { x: lightObj.light.position.x, y: lightObj.light.position.y, z: lightObj.light.position.z };
            lightObj.definition.targetPosition = { x: lightObj.light.target.position.x, y: lightObj.light.target.position.y, z: lightObj.light.target.position.z };
        });

        const levelData = {
            name: this.app.levelName || "Custom Level",
            spawnPoint: { x: this.app.spawnPointHelper.position.x, y: this.app.spawnPointHelper.position.y, z: this.app.spawnPointHelper.position.z },
            deathSpawnPoint: { x: this.app.deathSpawnPointHelper.position.x, y: this.app.deathSpawnPointHelper.position.y, z: this.app.deathSpawnPointHelper.position.z },
            settings: this.app.settings,
            objects: this.app.getLevelObjects().map(obj => obj.definition),
            enemies: this.app.getEnemies().map(enemy => enemy.definition),
            triggers: this.app.getTriggers().map(t => t.definition),
            deathTriggers: this.app.getDeathTriggers().map(t => t.definition)
        };
        return levelData;
    }

    saveFile() {
        const levelData = this.getSerializableLevelData();
        const blob = new Blob([JSON.stringify(levelData, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${levelData.name.toLowerCase().replace(/\s/g, '-')}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    playInDebugMode() {
        const levelData = this.getSerializableLevelData();
        try {
            localStorage.setItem('editorLevelData', JSON.stringify(levelData));
            window.location.href = 'index.html?loadFromEditor=true&debug=true';
        } catch (e) {
            console.error("Failed to save level to localStorage:", e);
            alert("Could not play level in debug mode. Level data might be too large.");
        }
    }
    
    updateSkyboxColor(color) {
        this.app.scene.background = new THREE.Color(color);
        this.app.settings.backgroundColor = color.replace('#', '0x');
    }
    
    updateAmbientLight(prop, value) {
        const light = this.app.ambientLight;
        const setting = this.app.settings.ambientLight;
        if (prop === 'color') { light.color.set(value); setting.color = value.replace('#', '0x'); }
        if (prop === 'intensity') { light.intensity = parseFloat(value); setting.intensity = parseFloat(value); }
    }
    
    setSpawnPointToCamera() { this.camera.getWorldPosition(this.app.spawnPointHelper.position); this.editor.syncObjectTransforms(); }
    setDeathSpawnPointToCamera() { this.camera.getWorldPosition(this.app.deathSpawnPointHelper.position); this.editor.syncObjectTransforms(); }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorActions.js ===


=== FILE: src/editor/EditorApp.js ===
--------------------------------------------------
// src/editor/EditorApp.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { Renderer } from '../core/Renderer.js';
import { Physics } from '../core/Physics.js';
import { InputManager } from '../core/InputManager.js';
import { LevelManager } from '../game/world/LevelManager.js';
import { LevelEditor } from './LevelEditor.js';

export class EditorApp {
    constructor() {
        this.clock = new THREE.Clock();
        const canvas = document.getElementById('game-canvas');
        this.renderer = new Renderer(canvas);
        this.physics = new Physics();
        this.input = new InputManager();

        this.scene = this.renderer.scene;
        this.camera = this.renderer.camera;

        // Centralized entity management
        this.entities = new Set();
        
        this.settings = {};
        this.levelName = '';
        this.ambientLight = null;
        this.spawnPoint = new THREE.Vector3(0, 5, 10);
        this.deathSpawnPoint = new THREE.Vector3(0, 5, 12);
        this.spawnPointHelper = null;
        this.deathSpawnPointHelper = null;
        this.gridHelper = null;
    }

    // --- Entity Getters ---
    getEntities(type) {
        return [...this.entities].filter(e => e.userData?.gameEntity?.type === type);
    }
    getLevelObjects() { return this.getEntities('Object'); }
    getEnemies() { return this.getEntities('Enemy'); }
    getTriggers() { return this.getEntities('Trigger'); }
    getDeathTriggers() { return this.getEntities('DeathTrigger'); }
    getDirectionalLights() { return this.getEntities('DirectionalLight'); }

    async init() {
        this.gridHelper = new THREE.GridHelper(200, 200, 0xcccccc, 0x888888);
        this.gridHelper.material.opacity = 0.2;
        this.gridHelper.material.transparent = true;
        this.scene.add(this.gridHelper);

        this.levelManager = new LevelManager(this);
        this.editor = new LevelEditor(this);
        this.editor.actions.newLevel();
        window.editorApp = this;
        this.renderer.renderer.setAnimationLoop(() => this.animate());
    }

    add(entity) {
        if (!entity || this.entities.has(entity)) return;

        this.entities.add(entity);
        const gameEntityType = entity.userData?.gameEntity?.type;

        if (gameEntityType === 'DirectionalLight') {
            this.scene.add(entity.light, entity.light.target, entity.helper, entity.picker, entity.targetHelper);
        } else if (gameEntityType === 'SpawnPoint' || gameEntityType === 'DeathSpawnPoint') {
             this.scene.add(entity);
        } else {
            if (entity.mesh) this.scene.add(entity.mesh);
            if (entity.body) this.physics.addBody(entity.body);
        }
    }

    remove(entity, dispose = true) {
        if (!entity || !this.entities.has(entity)) return;
        
        const gameEntityType = entity.userData?.gameEntity?.type;

        if (gameEntityType === 'DirectionalLight') {
            this.removeDirectionalLight(entity, dispose);
        } else {
            this.removeGenericEntity(entity, dispose);
        }
        this.entities.delete(entity);
    }

    loadLevel(levelData) {
        this.clearLevel();
        const { ambientLight } = this.levelManager.build(levelData);

        this.settings = levelData.settings;
        this.levelName = levelData.name;
        this.ambientLight = ambientLight;
        
        this.createSpawnPointHelper();
        this.createDeathSpawnPointHelper();
        this.editor.onLevelLoaded();
    }

    createDirectionalLightWithHelper(light) {
        const helper = new THREE.DirectionalLightHelper(light, 5, 0xffffff);
        if (helper.lightPlane?.material) helper.lightPlane.material.depthTest = false;
        
        const picker = new THREE.Mesh( new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ visible: false }));
        picker.position.copy(light.position);

        const targetHelper = new THREE.Mesh( new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true }));
        targetHelper.position.copy(light.target.position);
        
        const lightObject = { light, helper, picker, targetHelper, definition: light.userData.definition };
        
        lightObject.userData = { gameEntity: { type: 'DirectionalLight', entity: lightObject } };
        picker.userData.gameEntity = lightObject.userData.gameEntity;
        targetHelper.userData.gameEntity = { type: 'LightTarget', entity: targetHelper, parentLight: lightObject };

        return lightObject;
    }
    
    removeDirectionalLight(lightObject, dispose = true) {
        if (!lightObject) return;
        this.scene.remove(lightObject.light.target, lightObject.light, lightObject.helper, lightObject.picker, lightObject.targetHelper);
        
        if (dispose) {
            lightObject.helper.dispose();
            lightObject.picker.geometry.dispose();
            lightObject.picker.material.dispose();
            lightObject.targetHelper.geometry.dispose();
            lightObject.targetHelper.material.dispose();
            lightObject.light.dispose();
        }
    }
    
    removeGenericEntity(entity, dispose = true) {
        if (!entity) return;
        const mesh = entity.mesh || entity;
        this.scene.remove(mesh);
        
        if (dispose && mesh.geometry) {
            mesh.geometry.dispose();
            if (Array.isArray(mesh.material)) {
                mesh.material.forEach(m => m.dispose());
            } else if (mesh.material?.dispose) {
                mesh.material.dispose();
            }
        }
        if (entity.body) this.physics.queueForRemoval(entity.body);
    }

    createSpawnPointHelper() {
        const helper = new THREE.AxesHelper(2);
        helper.material.depthTest = false;
        helper.position.copy(this.spawnPoint);
        helper.add(new THREE.Mesh( new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 })));
        helper.userData.gameEntity = { type: 'SpawnPoint', entity: helper };
        helper.children[0].userData.gameEntity = helper.userData.gameEntity;
        this.spawnPointHelper = helper;
        this.add(helper);
    }

    createDeathSpawnPointHelper() {
        const helper = new THREE.AxesHelper(2);
        helper.material.depthTest = false;
        helper.position.copy(this.deathSpawnPoint);
        helper.add(new THREE.Mesh( new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.6 })));
        helper.userData.gameEntity = { type: 'DeathSpawnPoint', entity: helper };
        helper.children[0].userData.gameEntity = helper.userData.gameEntity;
        this.deathSpawnPointHelper = helper;
        this.add(helper);
    }

    clearLevel() {
        this.editor.deselect();
        [...this.entities].forEach(entity => this.remove(entity));
        this.entities.clear();
        this.spawnPointHelper = null;
        this.deathSpawnPointHelper = null;
        if (this.ambientLight) {
            this.scene.remove(this.ambientLight);
            this.ambientLight.dispose();
            this.ambientLight = null;
        }
    }

    animate() {
        const deltaTime = this.clock.getDelta();
        this.physics.update(deltaTime);
        this.editor.update(deltaTime);
        this.renderer.render();
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorApp.js ===


=== FILE: src/editor/EditorCamera.js ===
--------------------------------------------------
// src/editor/EditorCamera.js

import * as THREE from 'three';

/**
 * Implements the editor's first-person fly-camera controls.
 * It reads from the InputManager to move and rotate the camera.
 */
export class EditorCamera {
    constructor(editor) {
        this.editor = editor;
        this.camera = editor.camera;
        this.input = editor.input;
    }

    update(deltaTime) {
        // Prevent camera movement while transform controls are active or input is disabled
        if (this.editor.controls.transformControls.dragging || !this.input.enabled) {
            this.input.update();
            return;
        }

        const moveSpeed = 50 * deltaTime;
        const forward = new THREE.Vector3();
        this.camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(this.camera.up, forward).negate();
        
        if (this.input.keys['KeyW']) this.camera.position.addScaledVector(forward, moveSpeed);
        if (this.input.keys['KeyS']) this.camera.position.addScaledVector(forward, -moveSpeed);
        if (this.input.keys['KeyA']) this.camera.position.addScaledVector(right, -moveSpeed);
        if (this.input.keys['KeyD']) this.camera.position.addScaledVector(right, moveSpeed);
        if (this.input.keys['Space']) this.camera.position.y += moveSpeed;
        if (this.input.keys['ShiftLeft']) this.camera.position.y -= moveSpeed;
        
        // REVISED: Left-click to look around
        if (this.input.mouse.leftClick && !this.editor.ui.isClickOnUI(this.input.mouse.screenX, this.input.mouse.screenY)) {
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            euler.setFromQuaternion(this.camera.quaternion);
            euler.y -= this.input.mouse.movementX * 0.002;
            euler.x -= this.input.mouse.movementY * 0.002;
            euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
            this.camera.quaternion.setFromEuler(euler);
        }

        this.input.update();
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorCamera.js ===


=== FILE: src/editor/EditorControls.js ===
--------------------------------------------------
// src/editor/EditorControls.js

import * as THREE from 'three';
import { TransformControls } from 'three/addons/controls/TransformControls.js';
import { StateChangeCommand } from './UndoManager.js';

/**
 * Manages object selection via raycasting, and manipulation via TransformControls (gizmos).
 * It listens for mouse events on the canvas and interacts with the selected object.
 */
export class EditorControls {
    constructor(editor) {
        this.editor = editor;
        this.app = editor.app;
        this.scene = editor.scene;
        this.camera = editor.camera;
        this.renderer = editor.app.renderer.renderer; // FIX: Get the WebGLRenderer directly from the app
        this.input = editor.input;

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        
        this._initialDragState = null; // For Undo/Redo

        this._onMouseDownHandler = this.onMouseDown.bind(this);
        this._onContextMenuHandler = (e) => e.preventDefault();
        
        this.init();
    }
    
    init() {
        this.transformControls = new TransformControls(this.camera, this.renderer.domElement);
        this.transformControls.addEventListener('dragging-changed', (event) => this.onDraggingChanged(event));
        this.transformControls.addEventListener('objectChange', () => this.onObjectChange());
        this.scene.add(this.transformControls);

        this.selectionBox = new THREE.BoxHelper();
        this.selectionBox.material.depthTest = false;
        this.selectionBox.material.transparent = true;
        this.selectionBox.visible = false;
        this.scene.add(this.selectionBox);
        
        this.applySnapSettings();
        
        this.renderer.domElement.addEventListener('mousedown', this._onMouseDownHandler, false);
        this.renderer.domElement.addEventListener('contextmenu', this._onContextMenuHandler, false);
    }

    dispose() {
        this.renderer.domElement.removeEventListener('mousedown', this._onMouseDownHandler, false);
        this.renderer.domElement.removeEventListener('contextmenu', this._onContextMenuHandler, false);
        this.transformControls.dispose();
        this.scene.remove(this.transformControls);
        this.scene.remove(this.selectionBox);
        this.selectionBox.geometry.dispose();
        this.selectionBox.material.dispose();
    }

    onDraggingChanged(event) {
        this.input.enabled = !event.value; // Disable camera controller while dragging
        let entity = this.editor.selectedObject;
        if (!entity) return;

        // If a target is being dragged, the command should apply to the parent light
        if (this.transformControls.object?.userData.gameEntity?.type === 'LightTarget') {
            entity = this.transformControls.object.userData.gameEntity.parentLight;
        }

        if (event.value) { // Drag started
            this._initialDragState = {
                definition: JSON.parse(JSON.stringify(entity.definition)),
            };
        } else { // Drag ended
            const beforeState = this._initialDragState.definition;
            const afterState = JSON.parse(JSON.stringify(entity.definition));
            
            this.editor.syncObjectTransforms(entity); // Ensure latest positions are synced first

            if (entity.userData.gameEntity.type === 'DirectionalLight') {
                afterState.position = { x: entity.light.position.x, y: entity.light.position.y, z: entity.light.position.z };
                afterState.targetPosition = { x: entity.light.target.position.x, y: entity.light.target.position.y, z: entity.light.target.position.z };
            } else {
                 const mesh = entity.mesh || entity.picker || entity;
                 afterState.position = { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z };
                 const euler = new THREE.Euler().setFromQuaternion(mesh.quaternion, 'YXZ');
                 if(afterState.rotation) {
                    afterState.rotation = { x: THREE.MathUtils.radToDeg(euler.x), y: THREE.MathUtils.radToDeg(euler.y), z: THREE.MathUtils.radToDeg(euler.z) };
                 }
                if (this.transformControls.mode === 'scale' && afterState.size) {
                     const initialSize = new THREE.Vector3().fromArray(this._initialDragState.definition.size);
                     const absScale = new THREE.Vector3().copy(mesh.scale).abs();
                     const newSize = initialSize.clone().multiply(absScale);
                     afterState.size = newSize.toArray();
                     mesh.scale.set(1, 1, 1);
                }
            }
            
            const command = new StateChangeCommand(this.editor, entity, beforeState, afterState);
            this.editor.undoManager.execute(command);
            this._initialDragState = null;
        }
    }

    onObjectChange() {
        if (this.editor.selectedObject && !this.transformControls.dragging) {
            this.editor.syncObjectTransforms();
            this.editor.ui.updatePropertiesPanel();
        } else if (this.transformControls.dragging) {
            const selectedEntity = this.editor.selectedObject;
            const draggedObject = this.transformControls.object;
            const draggedEntityType = draggedObject?.userData?.gameEntity?.type;

            if (draggedEntityType === 'LightTarget') {
                this.editor.syncObjectTransforms(draggedObject.userData.gameEntity.parentLight);
            } else if(selectedEntity) {
                this.editor.syncObjectTransforms(selectedEntity);
            }
        }
    }

    onMouseDown(event) {
        // REVISED: Select with right-click (button 2)
        if (event.button !== 2 || this.transformControls.dragging || this.editor.ui.isClickOnUI(event.clientX, event.clientY)) return;
        
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);

        const pickableMeshes = [...this.app.entities]
            .map(e => e.mesh || e.picker || e.targetHelper || e) // Get all possible meshes
            .flat() // Flatten in case of groups
            .filter(Boolean);
            
        const intersects = this.raycaster.intersectObjects(pickableMeshes.filter(m => m.visible), true);
        const validIntersects = intersects.filter(i => i.object.userData.gameEntity?.entity);
        
        if (validIntersects.length > 0) {
            const entity = validIntersects[0].object.userData.gameEntity.entity;
            if (entity.definition?.editorSelectable === false) {
                 this.editor.deselect();
            } else {
                 this.editor.select(entity);
            }
        } else {
            this.editor.deselect();
        }
    }

    setTransformSpace(space) {
        this.transformControls.setSpace(space);
        this.editor.ui.updateSpaceToggle(this.transformControls.space);
    }

    toggleTransformSpace() {
        const currentSpace = this.transformControls.space;
        this.setTransformSpace(currentSpace === 'world' ? 'local' : 'world');
    }

    applySnapSettings() {
        const editor = this.editor;
        if (editor.isSnapEnabled) {
            this.transformControls.setTranslationSnap(editor.translationSnapValue);
            this.transformControls.setRotationSnap(THREE.MathUtils.degToRad(editor.rotationSnapValue));
            this.transformControls.setScaleSnap(editor.translationSnapValue);
        } else {
            this.transformControls.setTranslationSnap(null);
            this.transformControls.setRotationSnap(null);
            this.transformControls.setScaleSnap(null);
        }
    }

    setTransformMode(mode) {
        if (this.transformControls.object) {
            this.transformControls.setMode(mode);
            this.editor.ui.updateTransformModeButtons(mode);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorControls.js ===


=== FILE: src/editor/EditorUI.js ===
--------------------------------------------------
// ~ src/editor/EditorUI.js

import * as THREE from 'three';

export class EditorUI {
    constructor(editor) {
        this.editor = editor;
        this.app = editor.app;
        this.init();
    }

    init() {
        // --- File Menu ---
        document.getElementById('menu-file-new').onclick = () => this.editor.actions.newLevel();
        document.getElementById('menu-file-open').onclick = () => document.getElementById('editor-file-input').click();
        document.getElementById('editor-file-input').onchange = (e) => this.editor.actions.loadFile(e);
        document.getElementById('menu-file-save').onclick = () => this.editor.actions.saveFile();
        document.getElementById('menu-file-play').onclick = () => this.editor.actions.playInDebugMode();
        document.getElementById('menu-file-exit').onclick = () => { window.location.href = 'index.html'; };

        // --- Edit Menu ---
        document.getElementById('menu-edit-undo').onclick = () => this.editor.undoManager.undo();
        document.getElementById('menu-edit-redo').onclick = () => this.editor.undoManager.redo();
        document.getElementById('menu-edit-copy').onclick = () => this.editor.actions.copySelected();
        document.getElementById('menu-edit-paste').onclick = () => this.editor.actions.pasteFromClipboard();
        document.getElementById('menu-edit-delete').onclick = () => this.editor.actions.deleteSelected();
        
        // --- View Menu ---
        document.getElementById('view-toggle-grid').onchange = (e) => { if(this.app.gridHelper) this.app.gridHelper.visible = e.target.checked; };
        document.getElementById('view-toggle-light-helpers').onchange = (e) => this.setHelpersVisibility('DirectionalLight', e.target.checked);
        document.getElementById('view-toggle-spawn-helpers').onchange = (e) => this.setHelpersVisibility('SpawnAndDeath', e.target.checked);
        document.getElementById('view-toggle-msg-triggers').onchange = (e) => this.setHelpersVisibility('Trigger', e.target.checked);
        document.getElementById('view-toggle-death-triggers').onchange = (e) => this.setHelpersVisibility('DeathTrigger', e.target.checked);
        
        // --- Help Menu ---
        document.getElementById('menu-help-metrics').onclick = (event) => {
            event.preventDefault(); // Prevents the <details> menu from closing
            this.showInfoModal();
        };

        // --- Toolbar ---
        document.getElementById('tool-translate').onclick = () => this.editor.controls.setTransformMode('translate');
        document.getElementById('tool-rotate').onclick = () => this.editor.controls.setTransformMode('rotate');
        document.getElementById('tool-scale').onclick = () => this.editor.controls.setTransformMode('scale');
        
        // --- Snapping Controls ---
        const snapToggle = document.getElementById('snap-toggle');
        const transSnapInput = document.getElementById('snap-translation-input');
        const rotSnapInput = document.getElementById('snap-rotation-input');
        const snapLabel = document.querySelector('label[for="snap-toggle"]');

        snapToggle.onchange = (e) => this.editor.setSnapEnabled(e.target.checked);
        transSnapInput.onchange = (e) => this.editor.setTranslationSnap(parseFloat(e.target.value));
        rotSnapInput.onchange = (e) => this.editor.setRotationSnap(parseFloat(e.target.value));
        if (snapLabel) snapLabel.onclick = () => snapToggle.click();

        // Set initial UI values from editor state
        snapToggle.checked = this.editor.isSnapEnabled;
        transSnapInput.value = this.editor.translationSnapValue;
        rotSnapInput.value = this.editor.rotationSnapValue;
        
        // --- Create Button & Context Menu ---
        const createButton = document.getElementById('create-button');
        const createMenu = document.getElementById('create-context-menu');
        createButton.onclick = (e) => {
            e.stopPropagation(); // Prevent document click listener from firing immediately
            createMenu.style.display = createMenu.style.display === 'none' ? 'flex' : 'none';
        };
        createMenu.onclick = (e) => {
            const action = e.target.dataset.action;
            if (action && typeof this.editor.actions[action] === 'function') {
                this.editor.actions[action]();
            }
            createMenu.style.display = 'none'; // Hide menu after action
        };
        // Hide menu if clicking anywhere else
        document.addEventListener('click', () => { createMenu.style.display = 'none'; });

        // --- Outliner ---
        this.outlinerContent = document.getElementById('outliner-content');
        this.outlinerContent.onclick = (e) => {
            const item = e.target.closest('.outliner-item');
            if (item) this.editor.selectByUUID(item.dataset.uuid);
        };
        
        // --- Inspector ---
        this.inspectorContent = document.getElementById('inspector-content');
        this.inspectorPlaceholder = this.inspectorContent.querySelector('.placeholder-text');

        // --- Modal Events ---
        document.querySelector('#editor-info-modal .modal-close-btn').onclick = () => { document.getElementById('editor-info-modal').style.display = 'none'; };
        document.getElementById('editor-info-modal').onclick = (e) => { if(e.target === e.currentTarget) e.currentTarget.style.display = 'none'; };

        // Top Menu Hover Logic to close other menus
        const menuDropdowns = document.querySelectorAll('.menu-dropdown');
        menuDropdowns.forEach(dropdown => {
            dropdown.addEventListener('mouseenter', () => dropdown.open = true);
            dropdown.addEventListener('mouseleave', () => dropdown.open = false);
            dropdown.addEventListener('pointerenter', () => {
                 if (document.querySelector('.menu-dropdown[open]') && document.querySelector('.menu-dropdown[open]') !== dropdown) {
                    document.querySelector('.menu-dropdown[open]').open = false;
                 }
            });
        });
    }

    isClickOnUI(x, y) {
        const uiAreas = [
            document.getElementById('editor-menu-bar'),
            document.getElementById('editor-toolbar'),
            document.getElementById('editor-outliner'),
            document.getElementById('editor-inspector'),
            document.getElementById('create-button-container'),
        ];
    
        for (const area of uiAreas) {
            if (!area) continue;
            const rect = area.getBoundingClientRect();
            if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                return true;
            }
        }
        return false;
    }

    showInfoModal() {
        // --- Player & Physics Parameters (from Player.js and Physics.js) ---
        const playerRadius = 0.8;
        const speed = 8;
        const jumpVy = 8;
        const dashMultiplier = 4;
        const dashDuration = 0.2;
        const gravity = 9.82; // Absolute value

        // --- Calculations ---
        const playerHeight = playerRadius * 2;
        const dashSpeed = speed * dashMultiplier;
        const groundDashDist = dashSpeed * dashDuration;

        // Single Jump
        const timeToPeak1 = jumpVy / gravity;
        const height1 = (jumpVy * jumpVy) / (2 * gravity);
        const airTime1 = 2 * timeToPeak1;
        const distance1 = speed * airTime1;

        // Double Jump (Max Height: jump at peak of first)
        const height2 = height1 + height1; // Second jump from peak (v=0) gains same height
        const timeToFallFromH2 = Math.sqrt((2 * height2) / gravity);
        const airTime2_height = timeToPeak1 + timeToFallFromH2;
        const distance2_height = speed * airTime2_height;
        const horizontalDistToPeak = speed * timeToPeak1;
        
        // Jump + Dash (for max distance)
        const jumpDashDist = horizontalDistToPeak + groundDashDist + (speed * timeToPeak1);

        const infoText = `
[Base Parameters]
Player Collider Height: ${playerHeight.toFixed(2)}m
Ground Speed          : ${speed.toFixed(2)} m/s
Dash Speed            : ${dashSpeed.toFixed(2)} m/s
Gravity               : ${gravity.toFixed(2)} m/s²

[Ground Movement]
Dash Distance         : ${groundDashDist.toFixed(2)}m

[Single Jump]
Max Height            : ${height1.toFixed(2)}m (Gap clearance: ${(height1 + playerHeight).toFixed(2)}m)
Max Distance          : ${distance1.toFixed(2)}m
Air Time              : ${airTime1.toFixed(2)}s

[Double Jump (for max height)]
Max Height            : ${height2.toFixed(2)}m (Gap clearance: ${(height2 + playerHeight).toFixed(2)}m)
Horizontal Distance   : ${distance2_height.toFixed(2)}m
Air Time              : ${airTime2_height.toFixed(2)}s

[Jump + Dash (for max distance)]
Max Distance          : ${jumpDashDist.toFixed(2)}m

NOTE: Distances are ideal, assuming flat ground. "Gap clearance" is max height + player height.
        `.trim();

        document.getElementById('info-modal-text').textContent = infoText;
        document.getElementById('editor-info-modal').style.display = 'flex';
    }


    updateTransformModeButtons(mode) {
        ['translate', 'rotate', 'scale'].forEach(m => {
            document.getElementById(`tool-${m}`).classList.toggle('active', m === mode);
        });
    }

    updateOutliner() {
        this.outlinerContent.innerHTML = '';
        const createItem = (parent, entity, name, uuid, prefix = '') => {
            const item = document.createElement('div');
            item.className = 'outliner-item';
            item.textContent = `${prefix} ${name}`;
            item.dataset.uuid = uuid;
            if (entity === this.editor.selectedObject) item.classList.add('selected');
            parent.appendChild(item);
        };
    
        const createCategory = (title, entities, prefix, nameField = 'name') => {
            if (!entities || entities.length === 0) return;
            const details = document.createElement('details');
            details.open = true;
            const summary = document.createElement('summary');
            summary.textContent = `${title} (${entities.length})`;
            details.appendChild(summary);
            entities.forEach(e => {
                 const name = e.definition?.[nameField] || e.name || (e.userData?.gameEntity?.type) || 'Unnamed';
                 // Use a consistent way to get a unique identifier (mesh, picker, or helper itself)
                 const uuidProvider = e.mesh || e.picker || e;
                 if(uuidProvider) {
                    createItem(details, e, name, uuidProvider.uuid, prefix);
                 }
            });
            this.outlinerContent.appendChild(details);
        };
    
        const spawnPoints = [this.app.spawnPointHelper, this.app.deathSpawnPointHelper].filter(Boolean);
        spawnPoints.forEach(sp => {
            sp.name = sp.userData.gameEntity.type === 'SpawnPoint' ? 'Initial Spawn' : 'Death Respawn';
        });
    
        createCategory('Scene Points', spawnPoints, '[P]', 'name');
        createCategory('Lights', this.app.getDirectionalLights(), '[L]');
        createCategory('Geometry', this.app.getLevelObjects(), '[G]');
        createCategory('Enemies', this.app.getEnemies(), '[E]');
        createCategory('Message Triggers', this.app.getTriggers(), '[T]');
        createCategory('Death Zones', this.app.getDeathTriggers(), '[D]');
    }

    updatePropertiesPanel() {
        this.inspectorContent.innerHTML = ''; // Clear previous content
        if (!this.editor.selectedObject) {
            this.inspectorContent.appendChild(this.inspectorPlaceholder.cloneNode(true));
            return;
        }
    
        const entity = this.editor.selectedObject;
        const entityType = entity.userData?.gameEntity?.type;
        if (!entityType) return;
    
        const fragment = document.createDocumentFragment();
    
        const handleEnterKey = (e, updateFn) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                updateFn(e.target.value);
                e.target.blur();
            }
        };
    
        const createPropGroup = (label) => {
            const group = document.createElement('div');
            group.className = 'prop-group';
            const labelEl = document.createElement('label');
            labelEl.textContent = label;
            group.appendChild(labelEl);
            fragment.appendChild(group);
            return group;
        };
    
        const createTextInput = (parent, value, callback) => {
            const input = document.createElement('input');
            input.type = 'text';
            input.value = value;
            const updateValue = (val) => callback(val);
            input.onchange = (e) => updateValue(e.target.value);
            input.onkeydown = (e) => handleEnterKey(e, updateValue);
            parent.appendChild(input);
        };
    
        const createNumberInput = (parent, value, { min, max, step = 0.1 }, callback) => {
            const input = document.createElement('input');
            input.type = 'number';
            if (min !== undefined) input.min = min;
            if (max !== undefined) input.max = max;
            input.step = step;
            input.value = value;
            const updateValue = (val) => callback(parseFloat(val) || 0);
            input.onchange = (e) => updateValue(e.target.value);
            input.onkeydown = (e) => handleEnterKey(e, updateValue);
            parent.appendChild(input);
        };
    
        const createColorInput = (parent, colorHex, callback) => {
            const input = document.createElement('input');
            input.type = 'color';
            input.value = colorHex;
            input.oninput = (e) => callback(e.target.value);
            parent.appendChild(input);
        };
    
        const createVec3Inputs = (parent, vector, step, callback) => {
            const inputGroup = document.createElement('div');
            inputGroup.className = 'prop-input-group';
            ['x', 'y', 'z'].forEach(axis => {
                const input = document.createElement('input');
                input.type = 'number';
                input.step = step;
                input.value = vector[axis].toFixed(3);
                const updateValue = (val) => callback(axis, parseFloat(val) || 0);
                input.onchange = (e) => updateValue(e.target.value);
                input.onkeydown = (e) => handleEnterKey(e, updateValue);
                inputGroup.appendChild(input);
            });
            parent.appendChild(inputGroup);
        };
    
        // --- Build UI based on Entity Type ---
        const def = entity.definition;
        const mesh = entity.mesh || entity.picker || entity;
    
        if (def && def.name !== undefined) {
            const group = createPropGroup('Name');
            createTextInput(group, def.name, (val) => this.editor.updateSelectedProp('name', null, val));
        }
    
        fragment.appendChild(document.createElement('hr'));
    
        const posGroup = createPropGroup('Position');
        createVec3Inputs(posGroup, mesh.position, 0.25, (axis, val) => this.editor.updateSelectedProp('position', axis, val));
    
        if (def && def.rotation) {
            const rotGroup = createPropGroup('Rotation (Deg)');
            const eulerRot = new THREE.Euler().setFromQuaternion(mesh.quaternion, 'YXZ');
            const degRot = { x: THREE.MathUtils.radToDeg(eulerRot.x), y: THREE.MathUtils.radToDeg(eulerRot.y), z: THREE.MathUtils.radToDeg(eulerRot.z) };
            createVec3Inputs(rotGroup, degRot, 1, (axis, val) => this.editor.updateSelectedProp('rotation', axis, val));
        }
    
        if (def && def.size) {
            const sizeGroup = createPropGroup('Size');
            const sizeVec = { x: def.size[0], y: def.size[1], z: def.size[2] };
            createVec3Inputs(sizeGroup, sizeVec, 0.25, (axis, val) => {
                const map = { x: 0, y: 1, z: 2 };
                this.editor.updateSelectedProp('size', map[axis], val);
            });
        }
    
        if (def && def.material) {
            fragment.appendChild(document.createElement('hr'));
            const matGroup = createPropGroup('Material Color');
            const initialColor = def.material.color ? '#' + new THREE.Color(parseInt(def.material.color, 16)).getHexString() : '#cccccc';
            createColorInput(matGroup, initialColor, (val) => this.editor.updateSelectedProp('material.color', null, val));
        }
    
        if (entityType === 'Trigger') {
            fragment.appendChild(document.createElement('hr'));
            const msgGroup = createPropGroup('Message');
            createTextInput(msgGroup, def.message || '', val => this.editor.updateSelectedProp('message', null, val));
    
            const durGroup = createPropGroup('Duration (s)');
            createNumberInput(durGroup, def.duration || 5, { min: 0.1, max: 100, step: 0.1 }, val => this.editor.updateSelectedProp('duration', null, val));
    
            const colorGroup = createPropGroup('Helper Color');
            const initialColor = def.color ? '#' + new THREE.Color(parseInt(def.color, 16)).getHexString() : '#00ff00';
            createColorInput(colorGroup, initialColor, val => this.editor.updateSelectedProp('color', null, val));
        }
    
        if (entityType === 'DirectionalLight') {
            fragment.appendChild(document.createElement('hr'));
            const lightGroup = createPropGroup('Light Color');
            const initialColor = def.color ? '#' + new THREE.Color(parseInt(def.color, 16)).getHexString() : '#ffffff';
            createColorInput(lightGroup, initialColor, val => this.editor.updateSelectedProp('color', null, val));
    
            const intensityGroup = createPropGroup('Intensity');
            createNumberInput(intensityGroup, entity.light.intensity, { min: 0, max: 20, step: 0.1 }, val => this.editor.updateSelectedProp('intensity', null, val));
    
            const targetGroup = createPropGroup('Target Position');
            createVec3Inputs(targetGroup, entity.light.target.position, 0.25, (axis, val) => this.editor.updateSelectedProp('targetPosition', axis, val));
        }
    
        this.inspectorContent.appendChild(fragment);
    
        const deleteButton = document.createElement('button');
        deleteButton.className = 'delete-button';
        deleteButton.textContent = 'Delete Selected';
        deleteButton.onclick = () => this.editor.actions.deleteSelected();
        this.inspectorContent.appendChild(deleteButton);
    }
    
    setHelpersVisibility(type, isVisible) {
        this.editor.helperVisibility[type] = isVisible;
    
        if (type === 'SpawnAndDeath') {
            if (this.app.spawnPointHelper) this.app.spawnPointHelper.visible = isVisible;
            if (this.app.deathSpawnPointHelper) this.app.deathSpawnPointHelper.visible = isVisible;
            return;
        }
    
        let entities;
        switch (type) {
            case 'DirectionalLight': entities = this.app.getDirectionalLights(); break;
            case 'Trigger': entities = this.app.getTriggers(); break;
            case 'DeathTrigger': entities = this.app.getDeathTriggers(); break;
            default: entities = [];
        }
    
        entities.forEach(e => {
            if (type === 'DirectionalLight') {
                if (e.helper) e.helper.visible = isVisible;
                if (e.targetHelper) e.targetHelper.visible = isVisible;
            } else if (e.mesh) {
                e.mesh.visible = isVisible;
            }
        });
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/EditorUI.js ===


=== FILE: src/editor/editor_main.js ===
--------------------------------------------------
import { EditorApp } from './EditorApp.js';

/**
 * The entry point for the level editor application.
 * It creates and initializes the main EditorApp instance.
 */
class Main {
    constructor() {
        this.app = new EditorApp();
    }

    async run() {
        try {
            await this.app.init();
        } catch(error) {
            console.error("Failed to initialize the editor application:", error);
            document.body.innerHTML = `<div style="color:red; text-align:center; margin-top: 50px;">
                <h1>Editor Failed to Start</h1>
                <p>Please check the console for errors.</p>
            </div>`;
        }
    }
}

const main = new Main();
main.run();
--------------------------------------------------
=== END OF FILE: src/editor/editor_main.js ===


=== FILE: src/editor/LevelEditor.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { EditorControls } from './EditorControls.js';
import { EditorUI } from './EditorUI.js';
import { EditorActions } from './EditorActions.js';
import { EditorCamera } from './EditorCamera.js';
import { UndoManager, StateChangeCommand } from './UndoManager.js';

export class LevelEditor {
    constructor(app) {
        this.app = app;
        this.scene = app.scene;
        this.camera = app.camera;
        this.renderer = app.renderer.renderer;
        this.physics = app.physics;
        this.input = app.input;

        // Core State
        this.selectedObject = null;
        this.clipboard = null;
        this.isSnapEnabled = false;
        this.translationSnapValue = 1;
        this.rotationSnapValue = 15;
        this.helperVisibility = {
            Trigger: true,
            DeathTrigger: true,
            DirectionalLight: true,
            SpawnAndDeath: true,
        };

        // Internal state for rotation logic
        this._initialLightPos = null;
        this._initialPickerQuat = null;

        // Modules
        this.undoManager = new UndoManager(this);
        this.ui = new EditorUI(this);
        this.controls = new EditorControls(this);
        this.actions = new EditorActions(this);
        this.cameraController = new EditorCamera(this);
        
        this.onKeyDownHandler = this.onKeyDown.bind(this);
        document.addEventListener('keydown', this.onKeyDownHandler);
    }

    dispose() {
        document.removeEventListener('keydown', this.onKeyDownHandler);
        this.controls.dispose();
    }

    onKeyDown(event) {
        if (event.target.tagName === 'INPUT' || this.controls.transformControls.dragging) return;

        if (event.ctrlKey) {
            switch (event.code) {
                case 'KeyC': event.preventDefault(); this.actions.copySelected(); break;
                case 'KeyV': event.preventDefault(); this.actions.pasteFromClipboard(); break;
                case 'KeyZ': event.preventDefault(); this.undoManager.undo(); break;
                case 'KeyY': event.preventDefault(); this.undoManager.redo(); break;
            }
        } else {
            switch (event.code) {
                case 'KeyT': this.controls.setTransformMode('translate'); break;
                case 'KeyR': this.controls.setTransformMode('rotate'); break;
                case 'KeyS': this.controls.setTransformMode('scale'); break;
                case 'KeyQ': this.controls.toggleTransformSpace(); break;
                case 'Delete':
                case 'Backspace': this.actions.deleteSelected(); break;
            }
        }
    }

    // --- State & Selection Management ---

    select(entity) {
        if (!entity || this.selectedObject === entity) return;
        this.deselect();
        
        this.selectedObject = entity;
        const entityType = entity.userData?.gameEntity?.type;
        let objectToAttach = entity.mesh || entity.picker || entity.targetHelper || entity;

        if (entityType === 'DirectionalLight') entity.picker.material.visible = true;

        this.controls.transformControls.attach(objectToAttach);
        this.controls.selectionBox.setFromObject(objectToAttach);
        this.controls.selectionBox.visible = true;
        
        this.ui.updatePropertiesPanel();
        this.ui.updateOutliner();
        
        const isEnemy = entityType === 'Enemy';
        const isLightTarget = entityType === 'LightTarget';

        const canRotate = !(entityType === 'SpawnPoint' || entityType === 'DeathSpawnPoint' || isEnemy || isLightTarget);
        const canScale = !(entityType === 'SpawnPoint' || entityType === 'DeathSpawnPoint' || entityType === 'DirectionalLight' || isEnemy || isLightTarget);
        
        document.getElementById('tool-rotate').disabled = !canRotate;
        document.getElementById('tool-scale').disabled = !canScale;

        if (!canRotate && this.controls.transformControls.getMode() === 'rotate') this.controls.setTransformMode('translate');
        if (!canScale && this.controls.transformControls.getMode() === 'scale') this.controls.setTransformMode('translate');
    }

    deselect() {
        if (!this.selectedObject) return;
        
        if (this.selectedObject.userData?.gameEntity?.type === 'DirectionalLight') {
            this.selectedObject.picker.material.visible = false;
        }

        this.selectedObject = null;
        this.controls.transformControls.detach();
        this.controls.selectionBox.visible = false;
        this.ui.updatePropertiesPanel();
        this.ui.updateOutliner();
        
        document.getElementById('tool-rotate').disabled = false;
        document.getElementById('tool-scale').disabled = false;
    }

    selectByUUID(uuid) {
        const entityToSelect = [...this.app.entities].find(e => {
            const mesh = e.mesh || e.picker || e.targetHelper || e;
            return mesh?.uuid === uuid;
        });
        if (entityToSelect) {
            this.select(entityToSelect);
        }
    }

    // --- Snap Control ---
    setSnapEnabled(isEnabled) {
        this.isSnapEnabled = isEnabled;
        this.controls.applySnapSettings();
    }
    
    setTranslationSnap(value) {
        this.translationSnapValue = value || 1;
        this.controls.applySnapSettings();
    }
    
    setRotationSnap(value) {
        this.rotationSnapValue = value || 15;
        this.controls.applySnapSettings();
    }
    
    // --- Data & Property Manipulation ---

    updateSelectedProp(prop, key, value) {
        if (!this.selectedObject) return;
        let entity = this.selectedObject;
        
        // If a light target is selected, apply the change to the parent light's definition
        if (entity.userData?.gameEntity?.type === 'LightTarget') {
            entity = entity.userData.gameEntity.parentLight;
        }

        const beforeState = entity.definition;
        const afterState = JSON.parse(JSON.stringify(beforeState)); // Create a working copy
        let target = afterState;

        const path = prop.split('.');
        for(let i = 0; i < path.length - 1; i++) {
            if(!target[path[i]]) target[path[i]] = {};
            target = target[path[i]];
        }
        const finalKey = path[path.length - 1];
        
        if (key !== null) {
            if(!target[finalKey]) target[finalKey] = {};
            target[finalKey][key] = value;
        } else {
            target[finalKey] = value.toString().startsWith('#') ? value.replace('#', '0x') : value;
        }

        const command = new StateChangeCommand(this, entity, beforeState, afterState);
        this.undoManager.execute(command);
    }
    
    applyDefinition(obj) {
        const type = obj.userData?.gameEntity?.type;
        const def = obj.definition;
        const mesh = obj.mesh;
        const body = obj.body;
    
        if (!def || !type) return;
    
        if (type === 'SpawnPoint' || type === 'DeathSpawnPoint') {
            this.syncObjectTransforms(obj); // Sync position from mesh to internal state
            this.controls.selectionBox.setFromObject(obj);
            return;
        }
    
        if (type === 'DirectionalLight') {
            const light = obj.light;
            light.color.set(parseInt(def.color, 16));
            light.intensity = def.intensity;
            light.position.set(def.position.x, def.position.y, def.position.z);
            if (def.targetPosition) {
                light.target.position.set(def.targetPosition.x, def.targetPosition.y, def.targetPosition.z);
            }
            obj.picker.position.copy(light.position);
            obj.targetHelper.position.copy(light.target.position);
            light.target.updateMatrixWorld(true);
            obj.helper.update();
            this.controls.selectionBox.setFromObject(obj.picker);
            return;
        }
    
        mesh.position.set(def.position.x, def.position.y, def.position.z);
    
        if (def.rotation && obj.isDead === undefined) {
             mesh.rotation.set(
                THREE.MathUtils.degToRad(def.rotation.x || 0),
                THREE.MathUtils.degToRad(def.rotation.y || 0),
                THREE.MathUtils.degToRad(def.rotation.z || 0)
            );
        }
    
        if (def.material?.color && mesh.material && !mesh.material.isWireframeMaterial) {
            mesh.material.color.set(parseInt(def.material.color, 16));
        }
    
        if (def.size) {
            if (type === 'Trigger' || type === 'DeathTrigger') {
                mesh.geometry.dispose();
                mesh.geometry = new THREE.BoxGeometry(...def.size);
                if (type === 'Trigger' && def.color) {
                    mesh.material.color.set(parseInt(def.color, 16));
                }
            } else if (def.type === 'Box' && body?.shapes[0]) {
                const halfExtents = new CANNON.Vec3(def.size[0] / 2, def.size[1] / 2, def.size[2] / 2);
                body.shapes[0].halfExtents.copy(halfExtents);
                body.shapes[0].updateConvexPolyhedronRepresentation();
                body.updateBoundingRadius();
                mesh.geometry.dispose();
                mesh.geometry = new THREE.BoxGeometry(...def.size);
            }
        }
    
        this.syncObjectTransforms(obj);
        this.controls.selectionBox.setFromObject(mesh);
    }
    
    syncObjectTransforms(entityToSync) {
        const entity = entityToSync || this.selectedObject;
        if (!entity) return;
        
        const entityType = entity.userData?.gameEntity?.type;
        
        if (entityType === 'SpawnPoint') {
            this.app.spawnPoint.copy(entity.position);
        } else if (entityType === 'DeathSpawnPoint') {
            this.app.deathSpawnPoint.copy(entity.position);
        } else if (entityType === 'DirectionalLight') {
            const picker = entity.picker;
            const light = entity.light;
            light.position.copy(picker.position);
            light.target.position.copy(entity.targetHelper.position);
            entity.helper.update();
            if (this.selectedObject === entity) this.controls.selectionBox.setFromObject(picker);
        } else if (entity.body) {
            entity.body.position.copy(entity.mesh.position);
            entity.body.quaternion.copy(entity.mesh.quaternion);
        }
    }
    
    onLevelLoaded() {
        this.deselect();
        this.ui.updateOutliner();
        this.ui.updatePropertiesPanel();

        // Apply initial visibility from UI checkboxes
        this.ui.setHelpersVisibility('Trigger', document.getElementById('view-toggle-msg-triggers').checked);
        this.ui.setHelpersVisibility('DeathTrigger', document.getElementById('view-toggle-death-triggers').checked);
        this.ui.setHelpersVisibility('DirectionalLight', document.getElementById('view-toggle-light-helpers').checked);
        this.ui.setHelpersVisibility('SpawnAndDeath', document.getElementById('view-toggle-spawn-helpers').checked);
    }
    
    update(deltaTime) {
        this.cameraController.update(deltaTime);
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/LevelEditor.js ===


=== FILE: src/editor/UndoManager.js ===
--------------------------------------------------
/**
 * A command representing a state change on an entity. It holds the "before"
 * and "after" states, allowing the change to be executed and undone.
 */
export class StateChangeCommand {
    constructor(editor, entity, beforeState, afterState) {
        this.editor = editor;
        this.entity = entity;
        this.beforeState = JSON.parse(JSON.stringify(beforeState));
        this.afterState = JSON.parse(JSON.stringify(afterState));
    }

    execute() {
        this.entity.definition = JSON.parse(JSON.stringify(this.afterState));
        this.editor.applyDefinition(this.entity);
        this.editor.select(this.entity);
    }

    undo() {
        this.entity.definition = JSON.parse(JSON.stringify(this.beforeState));
        this.editor.applyDefinition(this.entity);
        this.editor.select(this.entity);
    }
}

/**
 * Manages the undo and redo stacks for editor commands.
 */
export class UndoManager {
    constructor(editor) {
        this.editor = editor;
        this.undoStack = [];
        this.redoStack = [];
        this.maxHistory = 50;
    }

    execute(command) {
        this.undoStack.push(command);
        if (this.undoStack.length > this.maxHistory) {
            this.undoStack.shift();
        }
        this.redoStack = [];
        command.execute();
    }

    undo() {
        if (this.undoStack.length === 0) return;
        const command = this.undoStack.pop();
        this.redoStack.push(command);
        command.undo();
    }

    redo() {
        if (this.redoStack.length === 0) return;
        const command = this.redoStack.pop();
        this.undoStack.push(command);
        command.execute();
    }
}
--------------------------------------------------
=== END OF FILE: src/editor/UndoManager.js ===


=== FILE: src/game/Game.js ===
--------------------------------------------------
// src/game/Game.js
import * as THREE from 'three';
import { World } from './world/World.js';
import { PlayerController } from '../client/entities/PlayerController.js';
import { EventEmitter } from '../shared/EventEmitter.js';
import { AbilityFactory } from './abilities/AbilityFactory.js';
import { GAME_CONFIG } from '../shared/config.js';

/**
 * Manages the high-level state of the game application.
 * Acts as a state machine (MENU, LOADING, PLAYING) and orchestrates the core modules,
 * the game world, and the UI manager.
 */
export class Game {
    constructor(core, ui) {
        this.emitter = new EventEmitter(); // Composition
        this.core = core;
        this.ui = ui;
        this.viewModelScene = new THREE.Scene();

        this.gameState = 'MENU';
        this.debugModeActive = false;
        
        this.world = null;
        this.playerController = new PlayerController(this.core.input);
        
        this.respawnTimer = 0;
        this.currentLevelConfig = null;
    }

    // --- Event Emitter Delegation ---
    on(eventName, listener) { this.emitter.on(eventName, listener); }
    emit(eventName, data) { this.emitter.emit(eventName, data); }
    off(eventName, listener) { this.emitter.off(eventName, listener); }
    removeAllListeners() { this.emitter.removeAllListeners(); }

    async init() {
        await AbilityFactory.init();
        this.ui.bindGame(this);
        this._setupEventListeners();
        
        const urlParams = new URLSearchParams(window.location.search);
        this.handleUrlParameters(urlParams);
    }

    handleUrlParameters(params) {
        const loadFromEditor = params.get('loadFromEditor') === 'true';
        const debugMode = params.get('debug') === 'true';
        const showLevelSelect = params.get('showLevelSelect') === 'true';

        if (debugMode) this.toggleDebugMode();

        if (loadFromEditor) {
            const editorLevelData = localStorage.getItem('editorLevelData');
            if (editorLevelData) {
                try {
                    const savedLoadout = JSON.parse(localStorage.getItem('activeLoadout') || '{ "cards": [] }');
                    this.startLevel({ data: JSON.parse(editorLevelData), loadout: savedLoadout });
                } catch (e) {
                    console.error("Failed to parse level data from editor:", e);
                    this.returnToMenu();
                } finally {
                    localStorage.removeItem('editorLevelData');
                }
            }
        } else if (showLevelSelect) {
            this.ui.populateLevelList(this);
            this.ui.showScreen('levelSelect');
        } else {
            this.returnToMenu();
        }
    }

    async startLevel(config) {
        if (this.gameState === 'LOADING') return;

        this.currentLevelConfig = config;
        this.gameState = 'LOADING';
        this.ui.setLoading(true);

        if (this.world) {
            this.world.dispose();
            this.world = null;
        }

        this.world = new World(this.core, this);
        this.emit('worldCreated', this.world);
        
        this.world.on('playerDied', () => this.handlePlayerDeath());
        this.world.on('levelCompleted', () => this.ui.tutorialManager.showLevelCompleted());
        this.world.on('tutorialTriggerActivated', (data) => this.ui.tutorialManager.onTriggerActivated(data));
        this.world.on('abilityCastFailed', (data) => {
            this.emit('abilityCastFailed', data);
        });

        try {
            await this.world.loadLevel(config);

            this.core.renderer.setupPostProcessing(
                this.world.scene,
                this.core.renderer.camera,
                this.viewModelScene
            );

            this.playerController.attach(this.world.player);
            
            this.gameState = 'AWAITING_PLAY';
            this.requestPointerLock();
        } catch (error) {
            console.error("Failed to start level:", error);
            this.returnToMenu();
        }
    }

    startGameplay() {
        if (this.gameState !== 'AWAITING_PLAY') return;
        this.gameState = 'PLAYING';
        this.ui.setLoading(false);
        this.ui.showScreen('none');
        document.body.classList.add('game-active');

        if (this.world.player.isDead) {
            this.world.player.spawn(this.world.spawnPoint);
        }
    }
    
    handlePlayerDeath() {
        if (this.gameState === 'DEAD') return;
        this.gameState = 'DEAD';
        this.respawnTimer = GAME_CONFIG.UI.RESPAWN_COOLDOWN;
        this.ui.showScreen('deathScreen');
        document.body.classList.remove('game-active');
        if (document.pointerLockElement) document.exitPointerLock();
    }

    respawnPlayer() {
        this.world.resetPlayer();
        this.gameState = 'AWAITING_PLAY';
        this.ui.showScreen('none');
        this.requestPointerLock();
    }
    
    returnToMenu() {
        if (this.world) {
            this.world.dispose();
            this.world = null;
        }
        this.core.renderer.composer = null;
        this.playerController.detach();
        this.gameState = 'MENU';
        this.ui.setLoading(false);
        this.ui.showScreen('mainMenu');
        document.body.classList.remove('game-active');
        this.emit('mainMenuRendered');
        if (document.pointerLockElement) document.exitPointerLock();
    }
    
    requestPointerLock() {
        this.core.renderer.renderer.domElement.requestPointerLock();
    }

    toggleDebugMode() {
        this.debugModeActive = !this.debugModeActive;
        console.log(`%cDEBUG MODE: ${this.debugModeActive ? 'ACTIVATED' : 'DEACTIVATED'}`, 
            `color: ${this.debugModeActive ? '#2ed573' : '#ff4757'}; font-weight: bold;`);
    }

    _setupEventListeners() {
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement) {
                if (this.gameState === 'AWAITING_PLAY') this.startGameplay();
                if (this.gameState === 'PAUSED') {
                    this.gameState = 'PLAYING';
                    this.ui.showScreen('none');
                    document.body.classList.add('game-active');
                }
            } else {
                if (this.gameState === 'PLAYING') {
                    this.gameState = 'PAUSED';
                    this.ui.showScreen('pauseMenu');
                    document.body.classList.remove('game-active');
                }
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape' && this.gameState === 'PLAYING') {
                // Let the pointerlockchange event handle pausing
            }
        });
    }

    update(deltaTime) {
        switch (this.gameState) {
            case 'PLAYING':
                this.world.update(deltaTime);
                break;
            case 'DEAD':
                this.respawnTimer -= deltaTime;
                if (this.respawnTimer <= 0) {
                    this.respawnPlayer();
                }
                break;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/Game.js ===


=== FILE: src/game/abilities/Ability.js ===
--------------------------------------------------
// src/game/abilities/Ability.js
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Base class for all player abilities. Handles shared logic like cooldowns and energy costs.
 * Subclasses must implement the _executeCast method.
 */
export class Ability {
    constructor(caster, abilityData) {
        this.caster = caster;
        this.data = abilityData;
        this.name = abilityData.name || 'Unnamed Ability';
        this.icon = abilityData.icon || '?';
        this.cooldown = abilityData.cooldown || 0;
        this.energyCost = abilityData.energyCost || 0;
        this.element = abilityData.element || 'Utility';
        this.isCasting = false;

        // Start ready to cast
        this.cooldownTimer = this.cooldown;
    }

    /**
     * Checks if the ability can be cast based on cooldown and caster's energy.
     * @returns {{canCast: boolean, reason: string|null}}
     */
    _getCastability() {
        if (this.caster.world.game?.debugModeActive) return { canCast: true, reason: null };
        if (this.isCasting) return { canCast: false, reason: 'is_casting' };
        if (this.cooldownTimer < this.cooldown) return { canCast: false, reason: 'on_cooldown' };
        if (this.caster.abilities.currentEnergy < this.energyCost) return { canCast: false, reason: 'insufficient_energy' };
        return { canCast: true, reason: null };
    }

    /**
     * Executes the ability's core logic. Must be implemented by subclasses.
     * @returns {boolean} True if the cast logic was successful, false otherwise.
     * @protected
     */
    _executeCast() {
        throw new Error("Ability._executeCast() must be implemented by subclasses.");
    }
    
    /**
     * Public-facing method to cast the ability. Handles resource consumption and cooldowns.
     * @returns {boolean} True if the cast was successful, false otherwise.
     */
    cast() {
        const { canCast, reason } = this._getCastability();

        if (!canCast) {
            if (reason === 'on_cooldown' || reason === 'insufficient_energy') {
                this.caster.world.emit('abilityCastFailed', { 
                    reason: reason, 
                    entity: this.caster, 
                    ability: this 
                });
            }
            return false;
        }

        const castSuccessful = this._executeCast();

        if (castSuccessful) {
            if (!this.caster.world.game || !this.caster.world.game.debugModeActive) {
                this.caster.abilities.currentEnergy -= this.energyCost;
                this.caster.abilities.lastAbilityTime = this.caster.world.physics.world.time;
                this.triggerCooldown();
            }
            return true;
        }
        return false;
    }

    /**
     * Resets the cooldown timer after casting.
     */
    triggerCooldown() {
        this.cooldownTimer = 0;
    }

    /**
     * Gets the current cooldown progress as a value from 0.0 to 1.0.
     * @returns {number}
     */
    getCooldownProgress() {
        if (this.cooldown === 0) return 1.0;
        return Math.min(this.cooldownTimer / this.cooldown, 1.0);
    }
    
    /**
     * Updates the cooldown timer.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    update(deltaTime) {
        if (this.cooldownTimer < this.cooldown) {
            this.cooldownTimer += deltaTime;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/Ability.js ===


=== FILE: src/game/abilities/AbilityFactory.js ===
--------------------------------------------------
// ~ src/game/abilities/AbilityFactory.js
import { FireballAbility } from './FireballAbility.js';
import { FirefliesAbility } from './FirefliesAbility.js';
import { StonePlatingAbility } from './StonePlatingAbility.js';
import { WavePowerAbility } from './WavePowerAbility.js';

const AbilityMap = {
    'FIRE_001': FireballAbility,
    'FIRE_002': FirefliesAbility,
    'EARTH_001': StonePlatingAbility,
    'WATER_001': WavePowerAbility,
    // Add new ability classes here
};

let allAbilitiesData = null; // Module-level cache

/**
 * A factory for creating ability instances from their IDs.
 */
export class AbilityFactory {
    /**
     * Loads and caches the ability definitions from the JSON file.
     * Must be called once before any abilities can be created.
     */
    static async init() {
        if (allAbilitiesData) return; // Already initialized
        try {
            const response = await fetch('./data/abilities.json');
            allAbilitiesData = await response.json();
            console.log('Ability data loaded successfully.');
        } catch (error) {
            console.error('Failed to load ability data:', error);
            allAbilitiesData = {}; // Prevent further failed attempts
        }
    }

    /**
     * Creates an ability instance for a given caster and card ID.
     * @param {string} cardId - The ID of the ability card (e.g., 'FIRE_001').
     * @param {object} caster - The entity that will use the ability.
     * @returns {import('./Ability.js').Ability | null} An instance of the ability, or null if the ID is not found.
     */
    static create(cardId, caster) {
        if (!allAbilitiesData) {
            console.error('AbilityFactory not initialized. Call init() first.');
            return null;
        }

        const AbilityClass = AbilityMap[cardId];
        const abilityData = allAbilitiesData[cardId];

        if (AbilityClass && abilityData) {
            // Pass the full data object to the constructor
            return new AbilityClass(caster, abilityData);
        }

        console.warn(`AbilityFactory: No class or data found for card ID: ${cardId}`);
        return null;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/AbilityFactory.js ===


=== FILE: src/game/abilities/EnemyProjectile.js ===
--------------------------------------------------
// src/game/abilities/EnemyProjectile.js

import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
import { GAME_CONFIG } from '../../shared/config.js';
import { PhysicsBodyComponent } from '../components/PhysicsBodyComponent.js';

/**
 * A projectile fired by an enemy entity. It is a simple physics object that deals damage on impact.
 */
export class EnemyProjectile {
    constructor({ world, caster, initialVelocity }) {
        this.id = THREE.MathUtils.generateUUID();
        this.type = 'enemy_projectile';
        this.world = world;
        this.caster = caster;

        const config = GAME_CONFIG.ENEMY.DUMMY;
        this.damage = config.PROJECTILE_DAMAGE;
        this.lifetime = 3.0;
        this.isDead = false;

        // Physics
        const shape = new CANNON.Sphere(0.2);
        const body = new CANNON.Body({
            mass: 0.1,
            shape,
            collisionFilterGroup: COLLISION_GROUPS.PROJECTILE,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.PLAYER,
        });

        const spawnDirection = new CANNON.Vec3().copy(initialVelocity);
        spawnDirection.normalize(); // This modifies the vector in-place.
        const spawnPos = new CANNON.Vec3().copy(caster.physics.body.position);
        const offset = spawnDirection.scale(2); // .scale() returns a new, scaled vector.
        spawnPos.vadd(offset, spawnPos);
        
        body.position.copy(spawnPos);
        body.velocity.copy(initialVelocity);
        
        this.physics = new PhysicsBodyComponent(body);
        
        // FIX: Ensure userData object exists before assignment
        if (!body.userData) body.userData = {};
        body.userData.entity = this; // Link back for collision detection

        body.addEventListener('collide', (e) => this.onCollide(e));
        
        this.world.physics.addBody(body);
        this.world.add(this);
    }

    onCollide(event) {
        if (this.isDead) return;
        const targetEntity = event.body?.userData?.entity;
        if (targetEntity?.type === 'player') {
            targetEntity.takeDamage(this.damage);
        }
        this.world.remove(this);
    }

    update(deltaTime) {
        if (this.isDead) return;

        this.lifetime -= deltaTime;
        if (this.lifetime <= 0) {
            this.world.remove(this);
        }
    }
    
    dispose() {
        if (this.isDead) return;
        this.isDead = true;
        this.world.physics.queueForRemoval(this.physics.body);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/EnemyProjectile.js ===


=== FILE: src/game/abilities/Fireball.js ===
--------------------------------------------------
// src/game/abilities/Fireball.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';

/**
 * The Fireball projectile entity. Handles its own movement, collision, and area-of-effect logic.
 * Emits an event for the client to create the visual explosion.
 */
export class Fireball {
    constructor({ world, caster, spawnPosition }) {
        this.world = world;
        this.physics = world.physics;
        this.id = Math.random();

        this.LIFETIME = 2.0;
        this.SPEED = 35;
        this.RADIUS = 0.3;
        this.LINGER_DURATION = 3.0;
        this.DAMAGE_PER_SECOND = 75;
        
        this.state = 'TRAVELING';
        this.stateTimer = 0;
        this.isDead = false;

        const shape = new CANNON.Sphere(this.RADIUS);
        this.body = new CANNON.Body({
            mass: 0.5, shape,
            collisionFilterGroup: COLLISION_GROUPS.PROJECTILE,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY,
        });

        // Use the safe spawn position passed from the ability
        this.body.position.copy(spawnPosition);

        // Still need caster's direction for velocity
        const threeCameraDirection = new THREE.Vector3();
        caster.camera.getWorldDirection(threeCameraDirection);
        const cannonVelocity = new CANNON.Vec3().copy(threeCameraDirection).scale(this.SPEED);
        this.body.velocity.copy(cannonVelocity);
        
        this.onCollideHandler = (e) => {
            if (this.body) {
                this.detonate(this.body.position.clone());
            }
        };
        this.body.addEventListener('collide', this.onCollideHandler);

        this.preStepHandler = () => {
            if (this.state === 'TRAVELING' && this.body) {
                const antiGravity = new CANNON.Vec3(0, -this.physics.world.gravity.y, 0).scale(this.body.mass);
                this.body.applyForce(antiGravity, this.body.position);
            }
        };
        this.physics.world.addEventListener('preStep', this.preStepHandler);

        this.aoeSphere = new CANNON.Sphere(this.RADIUS * 40);
        this.aoeBody = new CANNON.Body({ type: CANNON.Body.STATIC, isTrigger: true });
        this.aoeBody.addShape(this.aoeSphere);

        this.physics.addBody(this.body);
        this.world.add(this);
    }

    detonate(position) {
        if (this.state !== 'TRAVELING') return;

        this.state = 'LINGERING';
        this.stateTimer = 0;
        
        if (this.body) {
            this.body.removeEventListener('collide', this.onCollideHandler);
            this.physics.queueForRemoval(this.body);
            this.body = null;
        }
        
        this.aoeBody.position.copy(position);
        this.physics.addBody(this.aoeBody);

        this.world.emit('projectileDetonated', { type: 'Fireball', position });
    }

    update(deltaTime) {
        if (this.isDead) return;

        this.stateTimer += deltaTime;

        if (this.state === 'TRAVELING') {
            if (this.stateTimer > this.LIFETIME && this.body) {
                this.detonate(this.body.position.clone());
            }
        } else if (this.state === 'LINGERING') {
            this.updateAoeDamage(deltaTime);
            if (this.stateTimer > this.LINGER_DURATION) {
                this.world.remove(this);
            }
        }
    }

    updateAoeDamage(deltaTime) {
        const damage = this.DAMAGE_PER_SECOND * deltaTime;
        const radiusSq = this.aoeSphere.radius * this.aoeSphere.radius;

        // Check player
        if (this.world.player.physics.body.position.distanceSquared(this.aoeBody.position) < radiusSq) {
            this.world.player.takeDamage(damage);
        }
        // Check enemies
        for (const enemy of this.world.getEnemies()) {
            if (enemy.physics.body.position.distanceSquared(this.aoeBody.position) < radiusSq) {
                enemy.takeDamage(damage);
            }
        }
    }
    
    dispose() {
        if (this.isDead) return;
        this.isDead = true;
        this.physics.world.removeEventListener('preStep', this.preStepHandler);
        if (this.body) {
            this.body.removeEventListener('collide', this.onCollideHandler);
            this.physics.queueForRemoval(this.body);
        }
        if (this.aoeBody) this.physics.queueForRemoval(this.aoeBody);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/Fireball.js ===


=== FILE: src/game/abilities/FireballAbility.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { Ability } from './Ability.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';

export class FireballAbility extends Ability {
    constructor(caster, abilityData) {
        super(caster, abilityData);
    }

    _executeCast() {
        const camera = this.caster.camera;
        const world = this.caster.world;
        const physics = world.physics;

        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir);

        const idealSpawnPoint = cameraPos.clone().add(cameraDir.clone().multiplyScalar(1.5));
        
        const rayFrom = new CANNON.Vec3().copy(cameraPos);
        const rayTo = new CANNON.Vec3().copy(idealSpawnPoint);
        const result = new CANNON.RaycastResult();
        
        physics.world.raycastClosest(rayFrom, rayTo, {
            collisionFilterMask: COLLISION_GROUPS.WORLD 
        }, result);

        let spawnPosition;
        if (result.hasHit) {
            const hitPoint = result.hitPointWorld;
            
            // FIX: Corrected method chaining.
            // .normalize() returns the length (a number), not the vector.
            const nudgeDirection = rayTo.vsub(rayFrom); // Get direction vector
            nudgeDirection.normalize(); // Normalize it in-place
            
            // .scale() returns a new, scaled vector.
            const nudgeVector = nudgeDirection.scale(-0.1); 
            
            spawnPosition = hitPoint.vadd(nudgeVector);
        } else {
            spawnPosition = rayTo;
        }
        
        this.caster.world.createFireball({ caster: this.caster, spawnPosition });
        return true;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FireballAbility.js ===


=== FILE: src/game/abilities/FirefliesAbility.js ===
--------------------------------------------------
import { Ability } from './Ability.js';

export class FirefliesAbility extends Ability {
    constructor(caster, abilityData) {
        super(caster, abilityData);
        this.numProjectiles = 5;
        this.requiresLockOn = true;

        // State for update-based casting
        this.castTimer = 0;
        this.projectilesFired = 0;
        this.targetWhileCasting = null;
        this.CAST_INTERVAL = 0.075; // 75ms
    }

    _executeCast() {
        const targetEnemy = this.caster.lockedTarget; 
        if (!targetEnemy || targetEnemy.isDead) return false;

        this.isCasting = true;
        this.castTimer = 0;
        this.projectilesFired = 0;
        this.targetWhileCasting = targetEnemy;

        return true;
    }

    update(deltaTime) {
        super.update(deltaTime); // Handles the main cooldown

        if (!this.isCasting) return;

        this.castTimer += deltaTime;

        // Check if it's time to fire the next projectile
        if (this.castTimer >= this.projectilesFired * this.CAST_INTERVAL) {
            if (this.projectilesFired < this.numProjectiles) {
                if (!this.caster.isDead && this.targetWhileCasting && !this.targetWhileCasting.isDead) {
                    this.caster.world.createFireflyProjectile({ 
                        caster: this.caster, 
                        target: this.targetWhileCasting 
                    });
                }
                this.projectilesFired++;
            }
        }

        // End casting sequence
        if (this.projectilesFired >= this.numProjectiles) {
            this.isCasting = false;
            this.targetWhileCasting = null;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FirefliesAbility.js ===


=== FILE: src/game/abilities/FireflyProjectile.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
import { PhysicsBodyComponent } from '../components/PhysicsBodyComponent.js';

/**
 * The Firefly homing projectile entity. Handles its own steering and collision logic.
 */
export class FireflyProjectile {
    constructor({ world, caster, target }) {
        this.id = THREE.MathUtils.generateUUID();
        this.type = 'firefly_projectile';
        this.world = world;
        this.caster = caster;
        this.target = target;
        
        this.damage = 100;
        this.lifetime = 6.0;
        this.speed = 18;
        this.isDead = false;
        this.homingForce = 4.0;
        
        const shape = new CANNON.Sphere(0.15);
        const body = new CANNON.Body({
            mass: 0.05, shape,
            collisionFilterGroup: COLLISION_GROUPS.PROJECTILE,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY,
            linearDamping: 0.1,
        });
        body.allowSleep = false;
        
        const initialDirection = new THREE.Vector3();
        caster.camera.getWorldDirection(initialDirection);
        const initialPosition = new THREE.Vector3();
        caster.camera.getWorldPosition(initialPosition).add(initialDirection.clone().multiplyScalar(0.7));
        body.position.copy(initialPosition);
        body.velocity.copy(initialDirection.multiplyScalar(this.speed));

        if (!body.userData) body.userData = {};
        body.userData.entity = this;

        this.physics = new PhysicsBodyComponent(body);

        body.addEventListener('collide', (e) => this.detonate());
        
        this.preStepHandler = () => { 
            if (this.physics.body) {
                const antiGravity = new CANNON.Vec3(0, -this.world.physics.world.gravity.y, 0).scale(this.physics.body.mass);
                this.physics.body.applyForce(antiGravity, this.physics.body.position);
            }
        };
        this.world.physics.world.addEventListener('preStep', this.preStepHandler);

        this.world.physics.addBody(body);
        this.world.add(this);
    }

    update(deltaTime) {
        if (this.isDead) return;

        this.lifetime -= deltaTime;
        if (this.lifetime <= 0) {
            this.detonate();
            return;
        }
        
        this.applySteering();
        this.orientToVelocity(deltaTime);
    }
    
    orientToVelocity(deltaTime) {
        const body = this.physics.body;
        if (body.velocity.lengthSquared() > 0.1) {
            const lookAtTarget = new CANNON.Vec3();
            body.position.vadd(body.velocity, lookAtTarget);
            
            const tempObject3D = new THREE.Object3D();
            tempObject3D.position.copy(body.position);
            tempObject3D.lookAt(lookAtTarget.x, lookAtTarget.y, lookAtTarget.z);
            
            body.quaternion.slerp(tempObject3D.quaternion, 15 * deltaTime, body.quaternion);
        }
    }

    applySteering() {
        if (!this.target || this.target.isDead || !this.target.physics?.body) return;

        const desiredVelocity = new CANNON.Vec3();
        this.target.physics.body.position.vsub(this.physics.body.position, desiredVelocity);

        if (desiredVelocity.lengthSquared() < 1) {
            this.detonate();
            return;
        }

        desiredVelocity.normalize();
        desiredVelocity.scale(this.speed, desiredVelocity);
        
        const steeringForce = new CANNON.Vec3();
        desiredVelocity.vsub(this.physics.body.velocity, steeringForce);
        steeringForce.normalize();
        steeringForce.scale(this.homingForce, steeringForce);
        
        this.physics.body.applyForce(steeringForce, this.physics.body.position);
    }

    detonate() {
        if (this.isDead) return;

        this.world.emit('projectileDetonated', { type: 'Firefly', position: this.physics.body.position });
        
        const radiusSq = 4 * 4;
        for (const enemy of this.world.getEnemies()) {
            if (enemy.physics?.body && enemy.physics.body.position.distanceSquared(this.physics.body.position) < radiusSq) {
                enemy.takeDamage(this.damage);
            }
        }
        
        this.world.remove(this);
    }
    
    dispose() {
        if (this.isDead) return;
        this.isDead = true;
        this.world.physics.world.removeEventListener('preStep', this.preStepHandler);
        if (this.physics.body) this.world.physics.queueForRemoval(this.physics.body);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/FireflyProjectile.js ===


=== FILE: src/game/abilities/StonePlatingAbility.js ===
--------------------------------------------------
 import { Ability } from './Ability.js';
    import { StatusEffect } from '../effects/StatusEffect.js';
    
    export class StonePlatingAbility extends Ability {
        constructor(caster, abilityData) {
            super(caster, abilityData);
            this.duration = 15.0;
        }
    
        _executeCast() {
            if (this.caster.statusEffects.has('stonePlating')) return false;
    
            const effect = new StatusEffect(this.caster, {
                name: 'stonePlating',
                duration: this.duration,
                properties: {
                    damageReduction: 0.80,
                    meleeDamageBoost: 0.30
                },
                onApply: (target) => {
                    target.world.emit('playerBuffActivated', { buffName: 'stonePlating' });
                },
                onRemove: (target) => {
                    target.world.emit('playerBuffDeactivated', { buffName: 'stonePlating' });
                }
            });
    
            this.caster.statusEffects.addEffect(effect);
            
            return true;
        }
    
        update(deltaTime) {
            // This is called for all abilities, even inactive ones, to handle their main cooldown
            super.update(deltaTime);
            // The active buff logic is now handled by the StatusEffectSystem
        }
    }
--------------------------------------------------
=== END OF FILE: src/game/abilities/StonePlatingAbility.js ===


=== FILE: src/game/abilities/WavePowerAbility.js ===
--------------------------------------------------
// src/game/abilities/WavePowerAbility.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { Ability } from './Ability.js';
import { GAME_CONFIG } from '../../shared/config.js';

export class WavePowerAbility extends Ability {
    constructor(caster, abilityData) {
        super(caster, abilityData);
        this.config = GAME_CONFIG.WAVE_POWER;

        // Reusable objects for performance
        this._forward = new THREE.Vector3();
        this._right = new THREE.Vector3();
        this._enemyLocalPos = new THREE.Vector3();
    }
    
    canCast() {
        const isGrounded = this.caster.jumpsRemaining === GAME_CONFIG.PLAYER.MAX_JUMPS;
        return super.canCast() && isGrounded;
    }

    _executeCast() {
        const UP_VECTOR = new THREE.Vector3(0, 1, 0);
        const playerPos = this.caster.physics.body.position;
        this.caster.camera.getWorldDirection(this._forward);
        this._forward.y = 0;
        this._forward.normalize();
        this._right.crossVectors(this._forward, UP_VECTOR);

        // Define the rectangular AoE in front of the player
        const halfWidth = this.config.WIDTH / 2;
        const halfLength = this.config.LENGTH / 2;
        
        // The center of the AoE rectangle
        const center = new THREE.Vector3().copy(playerPos).add(this._forward.clone().multiplyScalar(halfLength));
        
        // Matrix to transform world coordinates to the rectangle's local space
        const worldToLocalMatrix = new THREE.Matrix4().lookAt(this._forward, new THREE.Vector3(0,0,0), UP_VECTOR).setPosition(center).invert();

        let enemiesHit = 0;
        for (const enemy of this.caster.world.getEnemies()) {
            if (enemy.isDead || !enemy.physics.body) continue;

            // Transform enemy position to be relative to the AoE rectangle
            this._enemyLocalPos.copy(enemy.physics.body.position).applyMatrix4(worldToLocalMatrix);

            // Check if the enemy is within the rectangle's bounds
            if (Math.abs(this._enemyLocalPos.x) <= halfWidth && Math.abs(this._enemyLocalPos.z) <= halfLength) {
                this.applyEffect(enemy);
                enemiesHit++;
            }
        }
        
        // Emit event for VFX
        this.caster.world.emit('wavePowerUsed', { position: playerPos, direction: this._forward });

        return true;
    }

    applyEffect(enemy) {
        // Apply damage
        enemy.takeDamage(this.config.DAMAGE);

        // Apply knockback state and force
        enemy.ai.isKnockedBack = true;
        enemy.ai.knockbackTimer = this.config.KNOCKBACK_DURATION;

        const impulseDirection = new CANNON.Vec3().copy(this._forward);
        impulseDirection.y = this.config.IMPULSE_UPWARD / this.config.IMPULSE_FORWARD;
        impulseDirection.normalize();

        const impulse = impulseDirection.scale(this.config.IMPULSE_FORWARD);
        
        enemy.physics.body.applyImpulse(impulse, enemy.physics.body.position);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/abilities/WavePowerAbility.js ===


=== FILE: src/game/components/AbilityLoadoutComponent.js ===
--------------------------------------------------
/**
 * Data component storing an entity's equipped abilities and related state.
 */
export class AbilityLoadoutComponent {
    constructor() {
        /** @type {import('../abilities/Ability.js').Ability[]} */
        this.abilities = [null, null, null, null];
        this.selectedAbilityIndex = 0;

        this.currentEnergy = 1000;
        this.maxEnergy = 1000;
        this.energyRegenRate = 25; // per second
        this.energyRegenDelay = 5.0; // seconds
        this.lastAbilityTime = -Infinity;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/AbilityLoadoutComponent.js ===


=== FILE: src/game/components/AIComponent.js ===
--------------------------------------------------
// src/game/components/AIComponent.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

/**
 * Data component storing state and parameters for an AI-controlled entity.
 */
export class AIComponent {
    constructor() {
        this.state = 'IDLE'; // e.g., IDLE, SEARCHING, COMBAT, REPOSITIONING
        
        // --- Perception ---
        this.lastKnownPlayerPosition = new CANNON.Vec3();
        this.perception = {
            detectionRange: 40,
            loseSightRange: 50,
            attackRange: 30,
            optimalRange: 22,
            minimumRange: 10,
            hasLineOfSight: false,
            distanceToPlayer: Infinity,
        };

        // --- Timers & Cooldowns ---
        this.aiUpdateInterval = 0.1; // Stagger AI logic updates for performance
        this.aiUpdateTimer = Math.random() * this.aiUpdateInterval; // Random initial offset
        
        this.actionTimers = {
            attack: 1.5,
            jump: 2.0,
            dash: 2.0,
            reposition: 3.0,
        };
        
        this.actionCooldowns = {
            attack: 1.5,
            jump: 2.0,
            dash: 2.0,
            reposition: 3.0,
        };

        // --- Movement & States---
        this.strafeDirection = 1;
        this.isDashing = false;
        this.dashDuration = 0.2;
        this.dashStateTimer = 0;
        this.dashDirection = new THREE.Vector3();
        this.isKnockedBack = false;
        this.knockbackTimer = 0;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/AIComponent.js ===


=== FILE: src/game/components/HealthComponent.js ===
--------------------------------------------------
/**
 * Data component storing health and damage-related state for an entity.
 */
export class HealthComponent {
    constructor(maxHealth = 100) {
        this.maxHealth = maxHealth;
        this.currentHealth = maxHealth;
        
        // For client-side visual feedback
        this.flashDuration = 0.15;
        this.flashTimer = 0;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/HealthComponent.js ===


=== FILE: src/game/components/PhysicsBodyComponent.js ===
--------------------------------------------------
/**
 * Data component holding a reference to an entity's CANNON-ES physics body.
 */
export class PhysicsBodyComponent {
    /**
     * @param {import('cannon-es').Body} body
     */
    constructor(body) {
        this.body = body;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/PhysicsBodyComponent.js ===


=== FILE: src/game/components/PlayerInputComponent.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Data component storing processed input state for a player-controlled entity.
 * This decouples the entity from the raw input manager.
 */
export class PlayerInputComponent {
    constructor() {
        this.moveDirection = new THREE.Vector3();
        this.lookDirection = new THREE.Quaternion();
        
        this.jumpRequested = false;
        this.dashRequested = false;
        this.slamRequested = false;

        this.firePrimary = false;
        this.fireSecondary = false;
        
        this.abilitySlotRequested = -1; // -1 means no request, 0-3 for slots
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/PlayerInputComponent.js ===


=== FILE: src/game/components/StatusEffectComponent.js ===
--------------------------------------------------
// src/game/components/StatusEffectComponent.js

/**
 * A data component that holds and manages status effects for an entity.
 */
export class StatusEffectComponent {
    constructor() {
        /** @type {Map<string, import('../effects/StatusEffect.js').StatusEffect>} */
        this.activeEffects = new Map();
    }

    /**
     * Adds a new effect to the entity or refreshes the duration of an existing one.
     * @param {import('../effects/StatusEffect.js').StatusEffect} effect - The effect instance to add.
     */
    addEffect(effect) {
        const existing = this.activeEffects.get(effect.name);
        if (existing) {
            // Refresh duration of existing effect
            existing.timer = 0;
            return;
        }

        this.activeEffects.set(effect.name, effect);
        effect.apply();
    }

    /**
     * Checks if an effect is currently active.
     * @param {string} effectName - The name of the effect.
     * @returns {boolean}
     */
    has(effectName) {
        return this.activeEffects.has(effectName);
    }

    /**
     * Gets an active effect instance by name.
     * @param {string} effectName - The name of the effect.
     * @returns {import('../effects/StatusEffect.js').StatusEffect | undefined}
     */
    get(effectName) {
        return this.activeEffects.get(effectName);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/StatusEffectComponent.js ===


=== FILE: src/game/components/TransformComponent.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * Data component storing position, rotation, and scale for an entity.
 * Useful for entities that have a visual representation but no physics body.
 */
export class TransformComponent {
    constructor() {
        this.position = new THREE.Vector3();
        this.quaternion = new THREE.Quaternion();
        this.scale = new THREE.Vector3(1, 1, 1);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/components/TransformComponent.js ===


=== FILE: src/game/effects/StatusEffect.js ===
--------------------------------------------------
// src/game/effects/StatusEffect.js

/**
 * Represents a single buff, debuff, or state applied to an entity.
 * Encapsulates duration, properties, and lifecycle callbacks.
 */
export class StatusEffect {
    /**
     * @param {object} target - The entity the effect is applied to.
     * @param {object} options - Configuration for the effect.
     * @param {string} options.name - The unique name of the effect.
     * @param {number} [options.duration=Infinity] - The duration of the effect in seconds.
     * @param {object} [options.properties={}] - A key-value store for static data like damage multipliers.
     * @param {Function} [options.onApply] - Callback executed when the effect is first applied.
     * @param {Function} [options.onTick] - Callback executed on every game update.
     * @param {Function} [options.onRemove] - Callback executed when the effect expires or is removed.
     */
    constructor(target, { name, duration = Infinity, properties = {}, onApply, onTick, onRemove }) {
        this.target = target;
        this.name = name;
        this.duration = duration;
        this.properties = properties;
        this.timer = 0;
        this.isFinished = false;

        this._onApply = onApply;
        this._onTick = onTick;
        this._onRemove = onRemove;
    }

    /**
     * Called when the effect is first added to a target.
     */
    apply() {
        if (this._onApply) {
            this._onApply(this.target);
        }
    }

    /**
     * Called every frame the effect is active.
     * @param {number} deltaTime - The time since the last frame.
     */
    tick(deltaTime) {
        this.timer += deltaTime;
        if (this.duration !== Infinity && this.timer >= this.duration) {
            this.isFinished = true;
        }
        if (this._onTick) {
            this._onTick(this.target, deltaTime);
        }
    }

    /**
     * Called when the effect is removed from a target.
     */
    remove() {
        if (this._onRemove) {
            this._onRemove(this.target);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/effects/StatusEffect.js ===


=== FILE: src/game/entities/Enemy.js ===
--------------------------------------------------
  import * as THREE from 'three';
    import { HealthComponent } from '../components/HealthComponent.js';
    import { AIComponent } from '../components/AIComponent.js';
    import { PhysicsBodyComponent } from '../components/PhysicsBodyComponent.js';
    import { StatusEffectComponent } from '../components/StatusEffectComponent.js';
    import { GAME_CONFIG } from '../../shared/config.js';
    
    /**
     * Encapsulates the enemy entity's state and components.
     */
    export class Enemy {
        constructor(world, body, mesh, definition) {
            this.id = THREE.MathUtils.generateUUID();
            this.type = 'enemy';
            this.world = world;
            this.name = definition.name || 'Dummy';
            this.mesh = mesh;
            this.definition = definition;
            
            // Components
            this.health = new HealthComponent(GAME_CONFIG.ENEMY.DUMMY.MAX_HEALTH);
            this.ai = new AIComponent();
            this.physics = new PhysicsBodyComponent(body);
            this.statusEffects = new StatusEffectComponent();
    
            // Client-side visual state
            this.originalEmissive = new THREE.Color(mesh.material.emissive.getHex());
            this.isDead = false;
    
            // Link back to entity for easy access from physics/rendering
            const gameEntityLink = { type: 'Enemy', entity: this };
            this.userData = { gameEntity: gameEntityLink };
            mesh.userData.gameEntity = gameEntityLink;
            if (!body.userData) body.userData = {};
            body.userData.entity = this; // Use consistent .entity property for collisions
        }
        
        takeDamage(amount) {
            if (this.isDead) return;
    
            this.health.currentHealth -= amount;
            this.world.emit('entityTookDamage', { entity: this, amount });
    
            if (this.health.currentHealth <= 0) {
                this.health.currentHealth = 0;
                this.die();
            }
        }
    
        die() {
            if (this.isDead) return;
            this.isDead = true;
            this.world.emit('enemyDied', { entity: this });
        }
    
        dispose() {
            if (this.physics.body) {
                this.physics.body.userData.entity = null;
                this.world.physics.queueForRemoval(this.physics.body);
                this.physics.body = null;
            }
            if (this.mesh) {
                this.mesh.userData.entity = null;
                this.mesh.geometry?.dispose();
                if (this.mesh.material.dispose) {
                    this.mesh.material.dispose();
                }
                this.world.scene.remove(this.mesh);
                this.mesh = null;
            }
        }
    }
--------------------------------------------------
=== END OF FILE: src/game/entities/Enemy.js ===


=== FILE: src/game/entities/Player.js ===
--------------------------------------------------
 import * as THREE from 'three';
    import * as CANNON from 'cannon-es';
    import { HealthComponent } from '../components/HealthComponent.js';
    import { PlayerInputComponent } from '../components/PlayerInputComponent.js';
    import { PhysicsBodyComponent } from '../components/PhysicsBodyComponent.js';
    import { AbilityLoadoutComponent } from '../components/AbilityLoadoutComponent.js';
    import { StatusEffectComponent } from '../components/StatusEffectComponent.js';
    import { GAME_CONFIG } from '../../shared/config.js';
    import { AbilityFactory } from '../abilities/AbilityFactory.js';
    import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
    
    /**
     * Encapsulates the player entity's state, components, and core logic.
     */
    export class Player {
        constructor(world, camera, weapon, body) {
            this.id = THREE.MathUtils.generateUUID();
            this.type = 'player';
            this.world = world;
            this.camera = camera;
            this.weapon = weapon;
            if (this.weapon) this.weapon.wielder = this;
            
            this.health = new HealthComponent(GAME_CONFIG.PLAYER.MAX_HEALTH);
            this.input = new PlayerInputComponent();
            this.physics = new PhysicsBodyComponent(body);
            this.abilities = new AbilityLoadoutComponent();
            this.statusEffects = new StatusEffectComponent();
            
            this.jumpsRemaining = 0;
            this.isSlamming = false;
            this.isDead = true;
            this.lockedTarget = null;
            this.doubleJumpOnCooldown = false;
            this.doubleJumpCooldownTimer = GAME_CONFIG.PLAYER.DOUBLE_JUMP_COOLDOWN;
            this.isDashing = false;
            this.dashOnCooldown = false;
            this.dashCooldownTimer = GAME_CONFIG.PLAYER.DASH_COOLDOWN;
            this.dashStateTimer = 0;
            this.dashDirection = new THREE.Vector3();
            this.targetFov = GAME_CONFIG.PLAYER.FOV;
    
            if (!body.userData) body.userData = {};
            body.userData.entity = this;
            
            this.physics.body.addEventListener('collide', (e) => this.onCollide(e));
        }
    
        onCollide(event) {
            const otherBody = event.body;
            if (otherBody.collisionFilterGroup & COLLISION_GROUPS.WORLD) {
                const contactNormal = new CANNON.Vec3();
                if (event.contact.bi.id === this.physics.body.id) event.contact.ni.negate(contactNormal);
                else contactNormal.copy(event.contact.ni);
    
                if (contactNormal.dot(CANNON.Vec3.UNIT_Y) > 0.5) {
                    if (this.isSlamming) {
                        this.isSlamming = false;
                        this.world.emit('playerGroundSlammed');
                    }
                    this.jumpsRemaining = GAME_CONFIG.PLAYER.MAX_JUMPS;
                    if (!this.doubleJumpOnCooldown) {
                        this.doubleJumpCooldownTimer = GAME_CONFIG.PLAYER.DOUBLE_JUMP_COOLDOWN;
                    }
                }
            }
        }
    
        setMoveDirection(direction) { this.input.moveDirection.copy(direction); }
        setLookDirection(euler) { this.input.lookDirection.setFromEuler(euler); }
        
        jump() {
            if (this.statusEffects.has('stonePlating')) {
                // Allow first jump from the ground, but not subsequent (double) jumps.
                if (this.jumpsRemaining < GAME_CONFIG.PLAYER.MAX_JUMPS) {
                    return; // Block double jump
                }
            }
            this.input.jumpRequested = true;
        }
        
        dash(direction) {
            if (this.statusEffects.has('stonePlating') || this.dashOnCooldown) return;
            this.input.dashRequested = true;
            this.dashDirection.copy(direction);
        }
        
        reloadWeapon() {
            if (this.weapon && typeof this.weapon.reload === 'function') {
                this.weapon.reload();
            }
        }
    
        inspectWeapon() {
            if (this.weapon && typeof this.weapon.inspect === 'function') {
                this.weapon.inspect();
            }
        }
    
        requestSlam(isSlamming) { this.input.slamRequested = this.input.slamHeld = isSlamming; }
        selectAbility(index) { if (index >= 0 && index < this.abilities.abilities.length) this.abilities.selectedAbilityIndex = index; }
        useSelectedAbility() { const ability = this.abilities.abilities[this.abilities.selectedAbilityIndex]; if (ability) ability.cast(); }
    
        applyLoadout(loadoutData) {
            // Ensure loadoutData is an object and has a 'cards' array property.
            const cardIds = (loadoutData && Array.isArray(loadoutData.cards)) 
                ? loadoutData.cards 
                : [null, null, null, null]; // Default to empty slots if data is malformed.
            
            this.abilities.abilities = cardIds.map(cardId => 
                cardId ? AbilityFactory.create(cardId, this) : null
            );
        }
    
        takeDamage(amount) {
            if (this.isDead || (this.world.game && this.world.game.debugModeActive)) return;
            
            let finalAmount = amount;
            if (this.statusEffects.has('stonePlating')) {
                const buff = this.statusEffects.get('stonePlating');
                finalAmount *= (1 - buff.properties.damageReduction);
            }
    
            this.health.currentHealth -= finalAmount;
            this.world.emit('entityTookDamage', { entity: this, amount: finalAmount });
            if (this.health.currentHealth <= 0) {
                this.health.currentHealth = 0;
                this.die();
            }
        }
    
        die() { if (!this.isDead) { this.isDead = true; this.world.emit('playerDied'); } }
    
        reset(spawnPosition) {
            this.health.currentHealth = this.health.maxHealth;
            this.abilities.currentEnergy = this.abilities.maxEnergy;
            this.isDead = false; this.isSlamming = false; this.isDashing = false; this.lockedTarget = null;
            this.jumpsRemaining = 0;
            this.doubleJumpOnCooldown = false; this.doubleJumpCooldownTimer = GAME_CONFIG.PLAYER.DOUBLE_JUMP_COOLDOWN;
            this.dashOnCooldown = false; this.dashCooldownTimer = GAME_CONFIG.PLAYER.DASH_COOLDOWN;
            this.dashStateTimer = 0;
            this.abilities.abilities.forEach(a => { if(a) a.cooldownTimer = a.cooldown; });
            this.abilities.lastAbilityTime = -Infinity;
            this.statusEffects.activeEffects.clear();
            
            this.physics.body.position.copy(spawnPosition);
            this.physics.body.velocity.set(0, 0, 0);
            this.physics.body.angularVelocity.set(0, 0, 0);
            this.physics.body.wakeUp();
        }
        
        spawn(spawnPosition) { this.reset(spawnPosition); }
    }
--------------------------------------------------
=== END OF FILE: src/game/entities/Player.js ===


=== FILE: src/game/prefabs/EnemyPrefab.js ===
--------------------------------------------------
// src/game/prefabs/EnemyPrefab.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { Enemy } from '../entities/Enemy.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * A factory for creating enemy entities with all their required components.
 */
export class EnemyPrefab {

    /**
     * Creates a new enemy entity.
     * @param {import('../world/World.js').World} world - The world context.
     * @param {object} definition - The enemy definition from level data.
     * @returns {Enemy} The fully assembled enemy entity.
     */

    static create(world, definition) {
        const config = GAME_CONFIG.ENEMY.DUMMY;

        // 1. Visuals (Mesh)
        const geometry = new THREE.CapsuleGeometry(0.7, 1.0, 4, 8);
        const material = new THREE.MeshStandardMaterial({ color: 0x990000, roughness: 0.4, emissive: 0x000000 });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.position.copy(definition.position);

        // 2. Physics (Body)
        const shape = new CANNON.Sphere(config.RADIUS);
        const body = new CANNON.Body({
            mass: config.MASS,
            shape,
            position: new CANNON.Vec3(definition.position.x, definition.position.y, definition.position.z),
            fixedRotation: true,
            collisionFilterGroup: COLLISION_GROUPS.ENEMY,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.PLAYER | COLLISION_GROUPS.ENEMY | COLLISION_GROUPS.PROJECTILE | COLLISION_GROUPS.TRIGGER,
        });

        // 3. Entity creation
        const entity = new Enemy(world, body, mesh, definition);
        
        return entity;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/prefabs/EnemyPrefab.js ===


=== FILE: src/game/prefabs/PlayerPrefab.js ===
--------------------------------------------------
// src/game/prefabs/PlayerPrefab.js
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { Player } from '../entities/Player.js';
import { WeaponFactory } from '../weapons/WeaponFactory.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * A factory for creating the player entity with all its required components.
 */
export class PlayerPrefab {
    static create(world, camera, viewModelScene, loadoutData) {
        const { physics } = world;
        const config = GAME_CONFIG.PLAYER;

        const shape = new CANNON.Sphere(config.RADIUS);
        const material = new CANNON.Material({ name: 'playerMaterial', friction: 0.0 });
        const body = new CANNON.Body({
            mass: config.MASS,
            shape,
            material,
            fixedRotation: true,
            allowSleep: false,
            collisionFilterGroup: COLLISION_GROUPS.PLAYER,
            collisionFilterMask: COLLISION_GROUPS.WORLD | COLLISION_GROUPS.ENEMY | COLLISION_GROUPS.PROJECTILE | COLLISION_GROUPS.TRIGGER,
        });
        const playerWorldContactMaterial = new CANNON.ContactMaterial(
            physics.world.defaultMaterial, material,
            { friction: 0.0, restitution: 0.0, contactEquationStiffness: 1e8, contactEquationRelaxation: 3, frictionEquationStiffness: 1e8 }
        );
        physics.addContactMaterial(playerWorldContactMaterial);
        
        const weaponId = loadoutData?.weapon || 'WEAPON_001';
        const weapon = WeaponFactory.create(weaponId);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
        directionalLight.position.set(0.5, 0.8, -0.2).normalize();
        
        if (weapon?.mesh) {
            camera.add(weapon.mesh);
        }
        viewModelScene.add(ambientLight, directionalLight, camera);
        
        const entity = new Player(world, camera, weapon, body);
        entity.applyLoadout(loadoutData || { cards: [null, null, null, null], weapon: null });
        
        return entity;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/prefabs/PlayerPrefab.js ===


=== FILE: src/game/systems/AbilitySystem.js ===
--------------------------------------------------
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Manages ability cooldowns and energy regeneration for entities.
 */
export class AbilitySystem {
    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        for (const entity of world.getEntities()) {
            if (entity.abilities) {
                this._updateCooldowns(entity.abilities, deltaTime);
                this._updateEnergy(world, entity, deltaTime);
            }
        }
    }

    _updateCooldowns(abilitiesComponent, deltaTime) {
        for (const ability of abilitiesComponent.abilities) {
            if (ability) {
                ability.update(deltaTime);
            }
        }
    }

    _updateEnergy(world, entity, deltaTime) {
        const abilities = entity.abilities;
        const config = GAME_CONFIG.PLAYER;

        if (world.physics.world.time - abilities.lastAbilityTime > config.ENERGY_REGEN_DELAY) {
            if (abilities.currentEnergy < abilities.maxEnergy) {
                abilities.currentEnergy = Math.min(
                    abilities.maxEnergy,
                    abilities.currentEnergy + config.ENERGY_REGEN_RATE * deltaTime
                );
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/AbilitySystem.js ===


=== FILE: src/game/systems/AISystem.js ===
--------------------------------------------------
// src/game/systems/AISystem.js
import * as CANNON from 'cannon-es';
import * as THREE from 'three';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
import { Util } from '../../shared/util.js';
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * Manages AI behavior for enemy entities.
 */
export class AISystem {
    constructor() {
        // --- PERFORMANCE: Reusable objects to prevent GC churn ---
        this._perceptionRayFrom = new CANNON.Vec3();
        this._perceptionRayTo = new CANNON.Vec3();
        this._losRayResult = new CANNON.RaycastResult();
        this._obstacleRayResult = new CANNON.RaycastResult();
        this._groundRayResult = new CANNON.RaycastResult();
        this._lookAtTarget = new THREE.Vector3();
        this._tempQuaternion = new CANNON.Quaternion();
        this._tempObject3D = new THREE.Object3D();
    }

    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        const player = world.player;
        if (!player || player.isDead) {
            world.getEnemies().forEach(enemy => {
                enemy.ai.state = 'IDLE';
                enemy.physics.body.velocity.x *= 0.9;
                enemy.physics.body.velocity.z *= 0.9;
            });
            return;
        }

        for (const enemy of world.getEnemies()) {
            if (enemy.isDead) continue;

            if (enemy.ai.isKnockedBack) {
                enemy.ai.knockbackTimer -= deltaTime;
                if (enemy.ai.knockbackTimer <= 0) {
                    enemy.ai.isKnockedBack = false;
                }
                continue; // Skip AI logic while knocked back
            }
            
            enemy.ai.aiUpdateTimer += deltaTime;
            if (enemy.ai.aiUpdateTimer >= enemy.ai.aiUpdateInterval) {
                this._runAI(world, enemy, player);
                enemy.ai.aiUpdateTimer = 0;
            }
            
            this._updateTimers(enemy.ai, deltaTime);
            this._applyMovement(enemy);
        }
    }
    
    _runAI(world, enemy, player) {
        this._updatePerception(world, enemy, player);
        this._updateState(enemy);
        this._executeStateActions(world, enemy, player);
    }
    
    _updatePerception(world, enemy, player) {
        const ai = enemy.ai;
        ai.perception.distanceToPlayer = enemy.physics.body.position.distanceTo(player.physics.body.position);
        
        this._perceptionRayFrom.copy(enemy.physics.body.position);
        this._perceptionRayFrom.y += 1.0;
        this._perceptionRayTo.copy(player.physics.body.position);
        this._perceptionRayTo.y += 1.0;

        this._losRayResult.reset();
        world.physics.world.raycastClosest(
            this._perceptionRayFrom, this._perceptionRayTo,
            { collisionFilterMask: COLLISION_GROUPS.WORLD, skipBackfaces: true },
            this._losRayResult
        );
        
        ai.perception.hasLineOfSight = !this._losRayResult.hasHit;
        if (ai.perception.hasLineOfSight) {
            ai.lastKnownPlayerPosition.copy(player.physics.body.position);
        }
    }

    _updateState(enemy) {
        const ai = enemy.ai;
        if (ai.perception.hasLineOfSight && ai.perception.distanceToPlayer < ai.perception.detectionRange) {
            ai.state = 'COMBAT';
        } else if (ai.state === 'COMBAT' && ai.perception.distanceToPlayer > ai.perception.loseSightRange) {
            ai.state = 'SEARCHING';
        } else if (ai.state === 'SEARCHING' && enemy.physics.body.position.distanceTo(ai.lastKnownPlayerPosition) < 2) {
            ai.state = 'IDLE';
        }
    }

    _executeStateActions(world, enemy, player) {
        const { ai, physics } = enemy;
        if (ai.isDashing) {
            if (ai.dashStateTimer >= ai.dashDuration) ai.isDashing = false;
            return;
        }
        
        this._faceTarget(enemy, ai.lastKnownPlayerPosition);
        if (ai.state === 'COMBAT') this._handleCombatDecisions(world, enemy, player);
    }

    _handleCombatDecisions(world, enemy, player) {
        const { ai, physics } = enemy;
        const { distanceToPlayer, hasLineOfSight, attackRange } = ai.perception;
        
        if (hasLineOfSight && distanceToPlayer <= attackRange && ai.actionTimers.attack <= 0) {
            this._shoot(world, enemy, player);
            ai.actionTimers.attack = ai.actionCooldowns.attack;
        }

        this._navigateObstacles(world, enemy);
        if (ai.actionTimers.dash <= 0) {
            const toPlayerDir = new CANNON.Vec3().copy(ai.lastKnownPlayerPosition).vsub(physics.body.position);
            const right = new THREE.Vector3().crossVectors(toPlayerDir, CANNON.Vec3.UNIT_Y).normalize();
            ai.dashDirection.copy(right.multiplyScalar(Math.random() > 0.5 ? 1 : -1));
            ai.isDashing = true;
            ai.dashStateTimer = 0;
            ai.actionTimers.dash = ai.actionCooldowns.dash;
        }
    }

    _applyMovement(enemy) {
        const { ai, physics } = enemy;
        const speed = GAME_CONFIG.ENEMY.DUMMY.SPEED;
        
        physics.body.wakeUp(); // Wake the body before changing its velocity.

        if (ai.isDashing) {
            const dashSpeed = speed * GAME_CONFIG.PLAYER.DASH_SPEED_MULTIPLIER;
            physics.body.velocity.x = ai.dashDirection.x * dashSpeed;
            physics.body.velocity.y = 0;
            physics.body.velocity.z = ai.dashDirection.z * dashSpeed;
            return;
        }

        let moveDirection = new CANNON.Vec3();
        switch(ai.state) {
            case 'IDLE': physics.body.velocity.x *= 0.9; physics.body.velocity.z *= 0.9; break;
            case 'SEARCHING':
                ai.lastKnownPlayerPosition.vsub(physics.body.position, moveDirection);
                break;
            case 'COMBAT':
                moveDirection = this._getCombatRepositionVector(enemy);
                break;
        }
        
        if (moveDirection.lengthSquared() > 0) {
            moveDirection.y = 0;
            moveDirection.normalize();
            physics.body.velocity.x = moveDirection.x * speed;
            physics.body.velocity.z = moveDirection.z * speed;
        }
    }
    
    _getCombatRepositionVector(enemy) {
        const { ai, physics } = enemy;
        const { distanceToPlayer, optimalRange, minimumRange } = ai.perception;
        const toPlayerDir = new CANNON.Vec3().copy(ai.lastKnownPlayerPosition).vsub(physics.body.position);

        if (distanceToPlayer > optimalRange) return toPlayerDir;
        if (distanceToPlayer < minimumRange) return toPlayerDir.negate();
        
        if (ai.actionTimers.reposition <= 0) {
            ai.strafeDirection *= -1;
            ai.actionTimers.reposition = ai.actionCooldowns.reposition;
        }
        return new CANNON.Vec3(toPlayerDir.z, 0, -toPlayerDir.x).scale(ai.strafeDirection);
    }
    
    _navigateObstacles(world, enemy) {
        const { physics, ai } = enemy;
        if (physics.body.velocity.lengthSquared() < 0.1 || ai.actionTimers.jump <= 0) return;

        const rayFrom = new CANNON.Vec3().copy(physics.body.position);
        
        const velocityDirection = physics.body.velocity.clone();
        velocityDirection.normalize(); // Normalizes in-place, returns length. Do not chain.
        const rayVector = velocityDirection.scale(2); // .scale() returns a new scaled vector.
        const rayTo = rayFrom.clone().vadd(rayVector);

        this._obstacleRayResult.reset();
        world.physics.world.raycastClosest(rayFrom, rayTo, { collisionFilterMask: COLLISION_GROUPS.WORLD }, this._obstacleRayResult);
        
        if (this._obstacleRayResult.hasHit) {
             const groundRayTo = rayFrom.clone().vadd(new CANNON.Vec3(0, -1.1, 0));
             this._groundRayResult.reset();
             world.physics.world.raycastClosest(rayFrom, groundRayTo, { collisionFilterMask: COLLISION_GROUPS.WORLD }, this._groundRayResult);
             if (this._groundRayResult.hasHit) {
                 physics.body.velocity.y = GAME_CONFIG.PLAYER.JUMP_HEIGHT;
                 ai.actionTimers.jump = ai.actionCooldowns.jump;
             }
        }
    }
    
    _shoot(world, enemy, player) {
        const config = GAME_CONFIG.ENEMY.DUMMY;
        const timeToTarget = enemy.ai.perception.distanceToPlayer / config.PROJECTILE_SPEED;
        const predictionTime = Math.min(timeToTarget, 1.0);
        const predictedPosition = new THREE.Vector3().copy(player.physics.body.position).add(
            new THREE.Vector3().copy(player.physics.body.velocity).multiplyScalar(predictionTime)
        );
        predictedPosition.y += 0.5;

        const launchVelocity = Util.calculateBallisticLaunchVelocity(
            new THREE.Vector3().copy(enemy.physics.body.position), predictedPosition,
            config.PROJECTILE_SPEED, Math.abs(world.physics.world.gravity.y)
        );

        world.createEnemyProjectile({
            caster: enemy,
            initialVelocity: launchVelocity || new THREE.Vector3().subVectors(predictedPosition, enemy.physics.body.position).normalize().multiplyScalar(config.PROJECTILE_SPEED)
        });
    }

    _updateTimers(ai, deltaTime) {
        for (const key in ai.actionTimers) {
            if (ai.actionTimers[key] > 0) {
                ai.actionTimers[key] -= deltaTime;
            }
        }
        if (ai.isDashing) ai.dashStateTimer += deltaTime;
    }
    
    _faceTarget(enemy, targetPosition) {
        this._lookAtTarget.copy(targetPosition);
        this._lookAtTarget.y = enemy.physics.body.position.y;
        this._tempObject3D.position.copy(enemy.physics.body.position);
        this._tempObject3D.lookAt(this._lookAtTarget);
        this._tempQuaternion.copy(this._tempObject3D.quaternion);
        enemy.physics.body.quaternion.slerp(this._tempQuaternion, 0.1, enemy.physics.body.quaternion);
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/AISystem.js ===


=== FILE: src/game/systems/DeathSystem.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

const DEATH_DURATION = 2.5; // seconds

/**
 * Manages the death sequence for entities, providing a more visually
 * appealing effect than immediate removal.
 */
export class DeathSystem {
    constructor() {
        this.dyingEntities = new Map(); // Map<entity, { timer: number }>
    }

    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        // Find newly dead enemies and start their death sequence
        for (const enemy of world.getEnemies()) {
            if (enemy.isDead && !this.dyingEntities.has(enemy)) {
                this.startDeathSequence(enemy);
            }
        }

        // Update ongoing death sequences
        for (const [entity, state] of this.dyingEntities.entries()) {
            state.timer -= deltaTime;
            
            this.updateFadeOut(entity, state.timer);

            if (state.timer <= 0) {
                world.remove(entity);
                this.dyingEntities.delete(entity);
            }
        }
    }

    /**
     * Initiates the death sequence for an enemy.
     * @param {import('../entities/Enemy.js').Enemy} enemy
     */
    startDeathSequence(enemy) {
        this.dyingEntities.set(enemy, { timer: DEATH_DURATION });
        
        if (enemy.physics?.body) {
            const body = enemy.physics.body;
            // Make it a ragdoll
            body.fixedRotation = false;
            body.updateMassProperties();

            // Give it a little push for a dynamic fall
            const impulse = new CANNON.Vec3(
                (Math.random() - 0.5) * 100,
                Math.random() * 150,
                (Math.random() - 0.5) * 100
            );
            const point = new CANNON.Vec3(0, 0.5, 0);
            body.applyImpulse(impulse, point);
        }

        // Prepare material for fading
        if (enemy.mesh?.material) {
            enemy.mesh.material.transparent = true;
        }
    }

    /**
     * Updates the opacity of an entity's mesh to create a fade-out effect.
     * @param {object} entity
     * @param {number} timer
     */
    updateFadeOut(entity, timer) {
        if (entity.mesh?.material) {
            const opacity = Math.max(0, timer / DEATH_DURATION);
            entity.mesh.material.opacity = opacity;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/DeathSystem.js ===


=== FILE: src/game/systems/MovementSystem.js ===
--------------------------------------------------
 // src/game/systems/MovementSystem.js
    
    import * as THREE from 'three';
    import * as CANNON from 'cannon-es';
    import { GAME_CONFIG } from '../../shared/config.js';
    import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
    
    /**
     * Handles player movement based on input, including jumping, dashing, and ground slams.
     */
    export class MovementSystem {
        constructor() {
            // No properties needed for ground check
        }
        
        /**
         * @param {import('../world/World.js').World} world
         * @param {number} deltaTime
         */
        update(world, deltaTime) {
            const player = world.player;
            if (!player || player.isDead) return;
    
            player.physics.body.wakeUp();
    
            const { input, physics } = player;
    
            // Ground checking and jump reset is now handled in Player.js via onCollide
            this._handleCooldowns(player, deltaTime);
            this._handleLook(player);
            this._handleFOV(player, deltaTime);
            
            this._initiateDash(player);
    
            if (player.isSlamming) {
                physics.body.velocity.y = GAME_CONFIG.PLAYER.GROUND_SLAM_VELOCITY;
            } else if (player.isDashing) {
                this._applyDashMovement(player);
            } else {
                this._applyStandardMovement(player, input.moveDirection);
            }
            
            this._handleJump(player);
            this._handleSlam(player);
    
            input.jumpRequested = false;
        }
    
        _initiateDash(player) {
            if (player.input.dashRequested && !player.isDashing && !player.dashOnCooldown) {
                player.isDashing = true;
                player.dashOnCooldown = true;
                player.dashStateTimer = 0;
                player.dashCooldownTimer = 0;
                
                const cameraDir = new THREE.Vector3();
                player.camera.getWorldDirection(cameraDir);
                cameraDir.y = 0;
                cameraDir.normalize();
    
                const rightDir = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), cameraDir).normalize();
                
                const forwardDot = player.dashDirection.dot(cameraDir);
                const rightDot = player.dashDirection.dot(rightDir);
        
                player.world.emit('playerDashed', { forwardDot, rightDot });
        
                if (Math.abs(forwardDot) > Math.abs(rightDot)) {
                    player.targetFov = GAME_CONFIG.PLAYER.FOV + (forwardDot > 0 ? 15 : -10);
                }
                
                player.input.dashRequested = false;
            }
        }
    
        _handleFOV(player, deltaTime) {
            if (Math.abs(player.camera.fov - player.targetFov) > 0.01) {
                player.camera.fov = THREE.MathUtils.lerp(player.camera.fov, player.targetFov, deltaTime * 10);
                player.camera.updateProjectionMatrix();
            }
            
            if (!player.isDashing && player.targetFov !== GAME_CONFIG.PLAYER.FOV) {
                player.targetFov = GAME_CONFIG.PLAYER.FOV;
            }
        }
    
        _handleCooldowns(player, deltaTime) {
            const config = GAME_CONFIG.PLAYER;
            
            if (player.doubleJumpOnCooldown) {
                player.doubleJumpCooldownTimer += deltaTime;
                if (player.doubleJumpCooldownTimer >= config.DOUBLE_JUMP_COOLDOWN) {
                    player.doubleJumpOnCooldown = false;
                    player.doubleJumpCooldownTimer = config.DOUBLE_JUMP_COOLDOWN;
                }
            }
            
            if (player.dashOnCooldown) {
                player.dashCooldownTimer += deltaTime;
                if (player.dashCooldownTimer >= config.DASH_COOLDOWN) {
                    player.dashOnCooldown = false;
                }
            }
    
            if (player.isDashing) {
                player.dashStateTimer += deltaTime;
                if (player.dashStateTimer >= config.DASH_DURATION) {
                    player.isDashing = false;
                }
            }
        }
    
        _handleLook(player) {
            player.camera.quaternion.slerp(player.input.lookDirection, 0.9);
        }
    
        _applyStandardMovement(player, moveDirection) {
            let speed = GAME_CONFIG.PLAYER.SPEED;
            if (player.statusEffects.has('stonePlating')) {
                speed *= 0.8; // Reduce speed by 20%
            }
            
            const velocity = player.physics.body.velocity;
            velocity.x = moveDirection.x * speed;
            velocity.z = moveDirection.z * speed;
        }
    
        _applyDashMovement(player) {
            const dashSpeed = GAME_CONFIG.PLAYER.SPEED * GAME_CONFIG.PLAYER.DASH_SPEED_MULTIPLIER;
            const velocity = player.physics.body.velocity;
            velocity.x = player.dashDirection.x * dashSpeed;
            velocity.z = player.dashDirection.z * dashSpeed;
        }
        
        _handleJump(player) {
            if (!player.input.jumpRequested || player.jumpsRemaining <= 0) return;
    
            const performJump = () => {
                player.physics.body.velocity.y = GAME_CONFIG.PLAYER.JUMP_HEIGHT;
                player.world.emit('playerJumped');
                player.jumpsRemaining--;
            };
            
            // This logic mirrors the old implementation correctly now.
            if (player.jumpsRemaining === 1 && GAME_CONFIG.PLAYER.MAX_JUMPS === 2) {
                if (!player.doubleJumpOnCooldown) {
                    player.doubleJumpOnCooldown = true;
                    player.doubleJumpCooldownTimer = 0;
                    performJump();
                }
            } else {
                performJump();
            }
        }
        
        _handleSlam(player) {
            const isAirborne = player.jumpsRemaining < GAME_CONFIG.PLAYER.MAX_JUMPS;
            
            if (player.input.slamRequested && !player.isSlamming) {
                if (isAirborne && player.physics.body.velocity.y < 0) {
                    player.isSlamming = true;
                }
            } else if (player.isSlamming && !player.input.slamHeld) {
                player.isSlamming = false;
            }
        }
    }
--------------------------------------------------
=== END OF FILE: src/game/systems/MovementSystem.js ===


=== FILE: src/game/systems/OutOfBoundsSystem.js ===
--------------------------------------------------
import { GAME_CONFIG } from '../../shared/config.js';

/**
 * A system to handle entities falling out of the world bounds.
 * This acts as a failsafe to prevent soft-locks.
 */

export class OutOfBoundsSystem {
    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        const threshold = GAME_CONFIG.DEATH_Y;

        for (const entity of world.getEntities()) {
            // Skip entities that are already dead or don't have a physics body
            if (entity.isDead || !entity.physics?.body) continue;

            if (entity.physics.body.position.y < threshold) {
                // The `die` method on both Player and Enemy will handle the necessary events.
                if (typeof entity.die === 'function') {
                    entity.die();
                }
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/OutOfBoundsSystem.js ===


=== FILE: src/game/systems/PhysicsSyncSystem.js ===
--------------------------------------------------
// src/game/systems/PhysicsSyncSystem.js

/**
 * Synchronizes the visual representation (Three.js mesh) of entities
 * with their physics simulation state (CANNON-ES body).
 */

export class PhysicsSyncSystem {
    /**
     * @param {import('../world/World.js').World} world
     */
    update(world) {
        // General sync for all entities with a mesh and body
        for (const entity of world.getEntities()) {
            if (entity.mesh && entity.physics?.body) {
                entity.mesh.position.copy(entity.physics.body.position);
                entity.mesh.quaternion.copy(entity.physics.body.quaternion);
            }
        }

        // Specific sync for the player's camera, which acts as the 'view'
        if (world.player && !world.player.isDead) {
            world.player.camera.position.copy(world.player.physics.body.position);
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/PhysicsSyncSystem.js ===


=== FILE: src/game/systems/StatusEffectSystem.js ===
--------------------------------------------------
// src/game/systems/StatusEffectSystem.js

/**
 * Manages the lifecycle of all active status effects in the world.
 * It ticks effects, checks for expiration, and handles their removal.
 */
export class StatusEffectSystem {
    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        for (const entity of world.getEntities()) {
            if (!entity.statusEffects) continue;

            const effectsToDelete = [];
            for (const effect of entity.statusEffects.activeEffects.values()) {
                effect.tick(deltaTime);
                if (effect.isFinished) {
                    effectsToDelete.push(effect);
                }
            }

            for (const effect of effectsToDelete) {
                effect.remove();
                entity.statusEffects.activeEffects.delete(effect.name);
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/StatusEffectSystem.js ===


=== FILE: src/game/systems/TargetingSystem.js ===
--------------------------------------------------
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { GAME_CONFIG } from '../../shared/config.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';

/**
 * Handles target acquisition for abilities that require a lock-on.
 */
export class TargetingSystem {
    constructor() {
        // Reusable objects to prevent garbage collection churn
        this._targetRayOrigin = new THREE.Vector3();
        this._targetRayDirection = new THREE.Vector3();
        this._enemyPos = new THREE.Vector3();
        this._toEnemyVector = new THREE.Vector3();
        this._losRayFrom = new CANNON.Vec3();
        this._losRayTo = new CANNON.Vec3();
        this._raycastResult = new CANNON.RaycastResult();
    }

    /**
     * Updates the player's locked-on target based on the current view and selected ability.
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        const player = world.player;
        if (!player || player.isDead) return;

        const currentAbility = player.abilities.abilities[player.abilities.selectedAbilityIndex];
        if (!currentAbility?.requiresLockOn) {
            player.lockedTarget = null;
            return;
        }

        player.camera.getWorldPosition(this._targetRayOrigin);
        player.camera.getWorldDirection(this._targetRayDirection);

        let bestEnemy = null;
        let minScore = Infinity;

        for (const enemy of world.getEnemies()) {
            if (enemy.isDead) continue;
            
            this._enemyPos.copy(enemy.physics.body.position);
            this._enemyPos.y += 1.0; // Aim for the center of the enemy's body

            const distanceToEnemy = this._targetRayOrigin.distanceTo(this._enemyPos);
            if (distanceToEnemy > GAME_CONFIG.TARGETING.MAX_RANGE) continue;
            
            this._toEnemyVector.subVectors(this._enemyPos, this._targetRayOrigin).normalize();
            
            const dotProduct = this._toEnemyVector.dot(this._targetRayDirection);
            if (dotProduct < 0) continue; // Enemy is behind the player

            const angle = Math.acos(Math.min(1, Math.max(-1, dotProduct)));

            if (angle < GAME_CONFIG.TARGETING.MAX_ANGLE_RAD) {
                // Perform line-of-sight check
                this._losRayFrom.copy(this._targetRayOrigin);
                this._losRayTo.copy(this._enemyPos);
                
                this._raycastResult.reset();
                world.physics.world.raycastClosest(
                    this._losRayFrom, this._losRayTo, 
                    { collisionFilterMask: COLLISION_GROUPS.WORLD, skipBackfaces: true }, 
                    this._raycastResult
                );

                if (!this._raycastResult.hasHit) {
                    // Score prioritizes being closer to the center of the screen, then distance.
                    const score = angle + (distanceToEnemy / GAME_CONFIG.TARGETING.MAX_RANGE);
                    if (score < minScore) {
                        minScore = score;
                        bestEnemy = enemy;
                    }
                }
            }
        }
        player.lockedTarget = bestEnemy;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/TargetingSystem.js ===


=== FILE: src/game/systems/TriggerSystem.js ===
--------------------------------------------------
// + src/game/systems/TriggerSystem.js

/**
 * A centralized system for handling logic for all trigger volumes.
 * It is event-driven and listens for collision events on trigger entities.
 */
export class TriggerSystem {
    constructor(world) {
        this.world = world;
        this._boundOnEntityAdded = this.onEntityAdded.bind(this);
        this.world.on('entityAdded', this._boundOnEntityAdded);
        this._initAllTriggers();
    }

    /**
     * Iterates through existing triggers in the world and initializes them.
     * This is useful for when the system is created after entities already exist.
     */
    _initAllTriggers() {
        const triggers = [...this.world.getTriggers(), ...this.world.getDeathTriggers()];
        triggers.forEach(trigger => this._initTrigger(trigger));
    }

    /**
     * Initializes a single trigger by attaching a collision handler.
     * @param {object} trigger - The trigger entity.
     */
    _initTrigger(trigger) {
        // Ensure we don't add the same listener multiple times.
        if (trigger.body && !trigger.body.hasEventListener('collide', trigger._collisionHandler)) {
            trigger._collisionHandler = (event) => this.onTriggerCollide(trigger, event);
            trigger.body.addEventListener('collide', trigger._collisionHandler);
        }
    }

    /**
     * Handler for when a new entity is added to the world.
     * If it's a trigger, initialize it.
     * @param {object} entity - The entity that was added.
     */
    onEntityAdded({ entity }) {
        if (entity.type === 'Trigger' || entity.type === 'DeathTrigger') {
            this._initTrigger(entity);
        }
    }

    /**
     * The core collision logic that runs when a trigger's body reports a collision.
     * @param {object} triggerEntity - The trigger volume itself.
     * @param {object} event - The CANNON.js collision event.
     */
    onTriggerCollide(triggerEntity, event) {
        const otherBody = event.body;
        const targetEntity = otherBody?.userData?.entity;

        if (!targetEntity) return;

        // Apply logic based on the type of the trigger volume.
        if (triggerEntity.type === 'DeathTrigger') {
            if (typeof targetEntity.takeDamage === 'function') {
                targetEntity.takeDamage(99999); // Apply lethal damage
            }
        } else if (triggerEntity.type === 'Trigger') {
            // Tutorial message triggers should only affect the player and only fire once.
            if (targetEntity.type === 'player' && !triggerEntity.hasFired) {
                this.world.emit('tutorialTriggerActivated', {
                    message: triggerEntity.message,
                    duration: triggerEntity.duration,
                });
                triggerEntity.hasFired = true;
            }
        }
    }

    /**
     * Cleans up all event listeners when the world is disposed.
     */
    dispose() {
        this.world.off('entityAdded', this._boundOnEntityAdded);
        const triggers = [...this.world.getTriggers(), ...this.world.getDeathTriggers()];
        triggers.forEach(trigger => {
            if (trigger.body && trigger._collisionHandler) {
                trigger.body.removeEventListener('collide', trigger._collisionHandler);
                delete trigger._collisionHandler;
            }
        });
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/TriggerSystem.js ===


=== FILE: src/game/systems/WeaponSystem.js ===
--------------------------------------------------
// + src/game/systems/WeaponSystem.js

/**
 * Manages the update logic for weapons, such as cooldowns and animations.
 */
export class WeaponSystem {
    /**
     * @param {import('../world/World.js').World} world
     * @param {number} deltaTime
     */
    update(world, deltaTime) {
        for (const entity of world.getEntities()) {
            if (entity.weapon?.update) {
                entity.weapon.update(deltaTime);
            }
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/systems/WeaponSystem.js ===


=== FILE: src/game/weapons/Katana.js ===
--------------------------------------------------
 import * as THREE from 'three';
    import { Weapon } from './Weapon.js';
    import { GAME_CONFIG } from '../../shared/config.js';
    
    export class Katana extends Weapon {
        constructor() {
            super(null, {
                name: 'Katana',
                damage: GAME_CONFIG.KATANA.DAMAGE,
                cooldown: GAME_CONFIG.KATANA.COOLDOWN,
            });
    
            this.swingRange = GAME_CONFIG.KATANA.RANGE;
            
            // REWORK: State management for animations
            this.state = 'idle'; // idle, swinging, inspecting
            this.animationProgress = 0;
            this.animationDuration = 0;
    
            // Internal helpers
            this._forward = new THREE.Vector3();
            this._enemyPos = new THREE.Vector3();
            
            this._defineKeyframes();
            this.createMesh();
            
            this.mesh.position.copy(this.idlePosition);
            this.mesh.quaternion.copy(this.qIdle);
        }
    
        _defineKeyframes() {
            // --- Swing Animation ---
            this.swingDuration = 0.45;
            this.hitTiming = 120; // ms
            this.idlePosition = new THREE.Vector3(0.35, -0.35, -0.7);
            this.windUpPosition = new THREE.Vector3(0.5, 0.4, -0.6);
            this.followThroughPosition = new THREE.Vector3(-0.4, -0.5, -0.7);
            const idleRotation = new THREE.Euler(THREE.MathUtils.degToRad(10), THREE.MathUtils.degToRad(-15), THREE.MathUtils.degToRad(5), 'YXZ');
            const windUpRotation = new THREE.Euler(THREE.MathUtils.degToRad(70), THREE.MathUtils.degToRad(30), THREE.MathUtils.degToRad(-20), 'YXZ');
            const followThroughRotation = new THREE.Euler(THREE.MathUtils.degToRad(-45), THREE.MathUtils.degToRad(-40), THREE.MathUtils.degToRad(45), 'YXZ');
            this.qIdle = new THREE.Quaternion().setFromEuler(idleRotation);
            this.qWindUp = new THREE.Quaternion().setFromEuler(windUpRotation);
            this.qFollowThrough = new THREE.Quaternion().setFromEuler(followThroughRotation);
    
            // --- NEW: Inspect Animation ---
            this.p_inspect_up = new THREE.Vector3(0.1, -0.1, -0.6);
            this.q_inspect_up = new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.5, -0.2, 0.2, 'YXZ'));
            this.p_inspect_flat = this.p_inspect_up.clone();
            this.q_inspect_flat = new THREE.Quaternion().setFromEuler(new THREE.Euler(-1.4, 0.1, -0.2, 'YXZ'));
        }
    
        createMesh() {
            this.mesh = new THREE.Group();
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.9, roughness: 0.3 });
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.7, 0.01), bladeMat);
            blade.position.y = 0.7 / 2 + 0.02 / 2;
            blade.castShadow = true;
            
            const guardMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6, roughness: 0.5 });
            const guard = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.02, 0.15), guardMat);
            guard.castShadow = true;
            
            const hiltMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
            const hilt = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.02, 0.25, 8), hiltMat);
            hilt.position.y = -0.25 / 2 - 0.02 / 2;
            hilt.castShadow = true;
            
            this.mesh.add(blade, guard, hilt);
        }
    
        attack() {
            if (!this.canAttack() || this.state !== 'idle') return false;
            
            this.state = 'swinging';
            this.animationDuration = this.swingDuration;
            this.animationProgress = 0;
            this.triggerCooldown();
            setTimeout(() => { if (this.state === 'swinging') this.detectHit(); }, this.hitTiming);
            return true;
        }
    
        inspect() {
            if (this.state !== 'idle') return;
            this.state = 'inspecting';
            this.animationDuration = 2.5;
            this.animationProgress = 0;
        }
    
        detectHit() {
            if (!this.wielder) return;
    
            this.wielder.camera.getWorldDirection(this._forward);
            const playerPos = this.wielder.physics.body.position;
    
            for (const enemy of this.wielder.world.getEnemies()) {
                if (enemy.isDead || !enemy.physics.body) continue;
    
                this._enemyPos.copy(enemy.physics.body.position);
                const distance = playerPos.distanceTo(this._enemyPos);
    
                if (distance < this.swingRange + enemy.physics.body.shapes[0].radius) {
                    const toEnemy = this._enemyPos.clone().sub(playerPos).normalize();
                    if (this._forward.dot(toEnemy) > 0.64) {
                        let damage = this.damage;
                        if (this.wielder.statusEffects.has('stonePlating')) {
                            const effect = this.wielder.statusEffects.get('stonePlating');
                            damage *= (1 + effect.properties.meleeDamageBoost);
                        }
                        if (this.wielder.isSlamming) {
                            damage *= GAME_CONFIG.KATANA.SLAM_DAMAGE_MULTIPLIER;
                        }
                        enemy.takeDamage(damage);
                    }
                }
            }
        }
    
        update(deltaTime) {
            super.update(deltaTime);
            if (this.state === 'idle') {
                this.mesh.position.lerp(this.idlePosition, 10 * deltaTime);
                this.mesh.quaternion.slerp(this.qIdle, 10 * deltaTime);
                return;
            }
    
            this.animationProgress += deltaTime;
            const p = Math.min(this.animationProgress / this.animationDuration, 1.0);
    
            switch(this.state) {
                case 'swinging':
                    this.updateSwingAnimation(p);
                    break;
                case 'inspecting':
                    this.updateInspectAnimation(p);
                    break;
            }
            
            if (p >= 1.0) {
                this.state = 'idle';
            }
        }
    
        updateSwingAnimation(p) {
            const windUpPhaseEnd = 0.20;
            const slashPhaseEnd = 0.60;
    
            let currentPosition = new THREE.Vector3();
            let currentQuaternion = new THREE.Quaternion();
            let phaseProgress, easedProgress;
    
            if (p < windUpPhaseEnd) {
                phaseProgress = p / windUpPhaseEnd;
                easedProgress = 1 - Math.pow(1 - phaseProgress, 3);
                currentPosition.lerpVectors(this.idlePosition, this.windUpPosition, easedProgress);
                currentQuaternion.slerpQuaternions(this.qIdle, this.qWindUp, easedProgress);
            } else if (p < slashPhaseEnd) {
                phaseProgress = (p - windUpPhaseEnd) / (slashPhaseEnd - windUpPhaseEnd);
                easedProgress = 1 - Math.pow(1 - phaseProgress, 4);
                currentPosition.lerpVectors(this.windUpPosition, this.followThroughPosition, easedProgress);
                currentQuaternion.slerpQuaternions(this.qWindUp, this.qFollowThrough, easedProgress);
            } else {
                phaseProgress = (p - slashPhaseEnd) / (1.0 - slashPhaseEnd);
                easedProgress = phaseProgress < 0.5 ? 2 * p * p : 1 - Math.pow(-2 * p + 2, 2) / 2;
                currentPosition.lerpVectors(this.followThroughPosition, this.idlePosition, easedProgress);
                currentQuaternion.slerpQuaternions(this.qFollowThrough, this.qIdle, easedProgress);
            }
    
            this.mesh.position.copy(currentPosition);
            this.mesh.quaternion.copy(currentQuaternion);
        }
        
        updateInspectAnimation(p) {
            const p1_end = 0.15, p2_end = 0.8, p3_end = 1.0;
            let phaseProgress, easedProgress;
            let currentPosition = new THREE.Vector3();
            let currentQuaternion = new THREE.Quaternion();
        
            if (p < p1_end) {
                phaseProgress = p / p1_end;
                easedProgress = 1 - Math.pow(1 - phaseProgress, 3);
                currentPosition.lerpVectors(this.idlePosition, this.p_inspect_up, easedProgress);
                currentQuaternion.slerpQuaternions(this.qIdle, this.q_inspect_up, easedProgress);
            } else if (p < p2_end) {
                phaseProgress = (p - p1_end) / (p2_end - p1_end);
                easedProgress = phaseProgress < 0.5 ? 4 * phaseProgress**3 : 1 - Math.pow(-2 * phaseProgress + 2, 3) / 2;
                currentPosition.lerpVectors(this.p_inspect_up, this.p_inspect_flat, easedProgress);
                currentQuaternion.slerpQuaternions(this.q_inspect_up, this.q_inspect_flat, easedProgress);
            } else {
                phaseProgress = (p - p2_end) / (p3_end - p2_end);
                easedProgress = 1 - Math.pow(1 - phaseProgress, 3);
                currentPosition.lerpVectors(this.p_inspect_flat, this.idlePosition, easedProgress);
                currentQuaternion.slerpQuaternions(this.q_inspect_flat, this.qIdle, easedProgress);
            }
        
            this.mesh.position.copy(currentPosition);
            this.mesh.quaternion.copy(currentQuaternion);
        }
    }
--------------------------------------------------
=== END OF FILE: src/game/weapons/Katana.js ===


=== FILE: src/game/weapons/Revolver.js ===
--------------------------------------------------
  import * as THREE from 'three';
    import { Weapon } from './Weapon.js';
    import { GAME_CONFIG } from '../../shared/config.js';
    import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';
    
    export class Revolver extends Weapon {
        constructor() {
            super(null, {
                name: 'Revolver',
                damage: 100,
                cooldown: 0.5,
            });
    
            this.range = 200;
            this.magazineSize = 6;
            this.magazineAmmo = 6;
            this.reserveAmmo = 24;
    
            this.state = 'idle'; // idle, firing, reloading, inspecting
            this.animationProgress = 0;
            this.animationDuration = 0;
    
            this._defineKeyframes();
            this.createMesh();
            
            this.mesh.position.copy(this.p_idle);
            this.mesh.quaternion.copy(this.q_idle);
        }
    
        _defineKeyframes() {
            // --- Base Positions & Rotations ---
            // REWORK: Weapon is offset to the right but rotated (yaw) to point towards the center crosshair.
            this.p_idle = new THREE.Vector3(0.3, -0.4, -0.7);
            this.q_idle = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, -0.3, 0));
            
            // --- ADS (Aim Down Sights) - Future Use ---
            this.p_ads = new THREE.Vector3(0, -0.3, -0.5);
            this.q_ads = new THREE.Quaternion();
    
            // --- Reloading Keyframes ---
            this.p_reload_start = new THREE.Vector3(0.3, -0.5, -0.7);
            this.q_reload_start = new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.8, -0.4, 0.2));
            
            // --- Inspecting Keyframes ---
            this.p_inspect_center = new THREE.Vector3(0.1, -0.35, -0.6);
            this.q_inspect_start = new THREE.Quaternion().setFromEuler(new THREE.Euler(0.2, -0.2, 0.5));
            this.q_inspect_roll = new THREE.Quaternion().setFromEuler(new THREE.Euler(0.5, -0.2, -1.5));
        }
    
        createMesh() {
            this.mesh = new THREE.Group();
            const darkMetal = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.9, roughness: 0.4 });
            const gripRubber = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.7 });
    
            // --- Frame ---
            const frameGeo = new THREE.BoxGeometry(0.045, 0.1, 0.14);
            const frame = new THREE.Mesh(frameGeo, darkMetal);
            frame.position.set(0, -0.01, -0.05);
    
            // --- Barrel Assembly ---
            const barrelAssembly = new THREE.Group();
            barrelAssembly.position.set(0, 0.045, -0.12);
            const shroud = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.055, 0.22), darkMetal);
            shroud.position.z = -0.09;
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.014, 0.014, 0.2, 8), darkMetal);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.z = -0.08;
            barrelAssembly.add(shroud, barrel);
    
            // --- Top Rail & Sights ---
            const topRail = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.015, 0.18), darkMetal);
            topRail.position.set(0, 0.08, -0.11);
            const rearSight = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 0.01), darkMetal);
            rearSight.position.set(0, 0.05, 0.02);
    
            // --- Grip ---
            const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.025, 0.16, 8), gripRubber);
            grip.position.set(0, -0.1, 0.01);
            grip.rotation.x = -0.2;
            grip.scale.x = 1.3;
    
            // --- Cylinder & Crane (for reload animation) ---
            this.crane = new THREE.Group();
            this.crane.position.set(-0.0225, -0.01, -0.05); // Pivot point on the frame
            this.cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.07, 6), darkMetal);
            this.cylinder.rotation.x = Math.PI / 2;
            this.crane.add(this.cylinder);
    
            // --- Hammer ---
            this.hammer = new THREE.Mesh(new THREE.BoxGeometry(0.015, 0.04, 0.02), darkMetal);
            this.hammer.position.set(0, 0.05, 0.02);
            this.hammer.geometry.translate(0, -0.02, 0); // Set pivot to bottom
    
            this.mesh.add(frame, barrelAssembly, topRail, rearSight, grip, this.crane, this.hammer);
            this.mesh.scale.setScalar(1.1);
            return this.mesh;
        }
    
        attack() {
            if (this.state !== 'idle' || !this.canAttack()) return false;
            
            if (this.magazineAmmo <= 0) {
                this.reload();
                return false;
            }
    
            this.state = 'firing';
            this.animationDuration = this.cooldown * 0.9;
            this.animationProgress = 0;
            this.magazineAmmo--;
            this.triggerCooldown();
    
            const raycaster = new THREE.Raycaster();
            const camera = this.wielder.camera;
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            
            const enemyMeshes = this.wielder.world.getEnemies().map(e => e.mesh).filter(Boolean);
            const worldMeshes = this.wielder.world.getLevelObjects().map(e => e.mesh).filter(Boolean);
            const entitiesToTest = [...enemyMeshes, ...worldMeshes];
    
            const intersects = raycaster.intersectObjects(entitiesToTest, true);
    
            let hitPoint = null;
            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.distance < this.range) {
                    hitPoint = hit.point; // Always set hit point
                    const gameEntity = hit.object.userData.gameEntity;
                    if (gameEntity && gameEntity.type === 'Enemy') {
                        gameEntity.entity.takeDamage(this.damage);
                    }
                }
            }
            
            if (!hitPoint) {
                hitPoint = raycaster.ray.at(this.range, new THREE.Vector3());
            }
    
            this.wielder.world.emit('weaponFired', { weapon: this, hitPoint });
    
            if (this.magazineAmmo === 0) {
                setTimeout(() => this.reload(), 500);
            }
    
            return true;
        }
    
        reload() {
            if (this.state !== 'idle' || this.magazineAmmo === this.magazineSize || this.reserveAmmo <= 0) return;
    
            this.state = 'reloading';
            this.animationDuration = 2.8;
            this.animationProgress = 0;
        }
    
        inspect() {
            if (this.state !== 'idle') return;
            this.state = 'inspecting';
            this.animationDuration = 3.5;
            this.animationProgress = 0;
        }
    
        update(deltaTime) {
            super.update(deltaTime);
            if (this.state === 'idle') {
                this.mesh.position.lerp(this.p_idle, 10 * deltaTime);
                this.mesh.quaternion.slerp(this.q_idle, 10 * deltaTime);
                this.crane.rotation.y = THREE.MathUtils.lerp(this.crane.rotation.y, 0, 15 * deltaTime);
                this.hammer.rotation.z = THREE.MathUtils.lerp(this.hammer.rotation.z, 0, 15 * deltaTime);
                return;
            }
    
            this.animationProgress += deltaTime;
            const p = Math.min(this.animationProgress / this.animationDuration, 1.0);
    
            switch(this.state) {
                case 'firing': this.updateFireAnimation(p, deltaTime); break;
                case 'reloading': this.updateReloadAnimation(p, deltaTime); break;
                case 'inspecting': this.updateInspectAnimation(p); break;
            }
            
            if (p >= 1.0) {
                if (this.state === 'reloading') {
                    const ammoNeeded = this.magazineSize - this.magazineAmmo;
                    const ammoToReload = Math.min(ammoNeeded, this.reserveAmmo);
                    this.magazineAmmo += ammoToReload;
                    this.reserveAmmo -= ammoToReload;
                }
                this.state = 'idle';
            }
        }
    
        updateFireAnimation(p, deltaTime) {
            // Kickback
            const kickbackAmount = 0.2;
            this.mesh.position.z = this.p_idle.z + Math.sin(p * Math.PI) * kickbackAmount;
            
            // Muzzle flip
            const flipAmount = -0.5;
            this.mesh.rotation.x = Math.sin(p * Math.PI) * flipAmount;
            
            // Hammer animation
            const hammerCockBack = -Math.PI / 4;
            if (p < 0.1) this.hammer.rotation.z = THREE.MathUtils.lerp(0, hammerCockBack, p / 0.1);
            else this.hammer.rotation.z = THREE.MathUtils.lerp(hammerCockBack, 0, (p-0.1) / 0.9);
            
            // Cylinder rotation
            this.cylinder.rotation.y -= deltaTime * 20 * (1 - p);
        }
    
        updateReloadAnimation(p, deltaTime) {
            // Phase 1: Bring to center and start opening (0.0 -> 0.2)
            const p1 = Math.min(1, p / 0.2);
            this.mesh.position.lerpVectors(this.p_idle, this.p_reload_start, p1);
            this.mesh.quaternion.slerpQuaternions(this.q_idle, this.q_reload_start, p1);
    
            // Phase 2: Swing cylinder out (0.1 -> 0.4)
            const p2 = Math.min(1, Math.max(0, (p - 0.1) / 0.3));
            const swingOutAngle = -Math.PI / 2.5;
            this.crane.rotation.y = THREE.MathUtils.lerp(0, swingOutAngle, p2);
    
            // Phase 3: Eject shells (0.4 -> 0.6) - a quick spin
            if (p > 0.4 && p < 0.6) {
                this.cylinder.rotation.y -= deltaTime * 50;
            }
    
            // Phase 4: Swing cylinder in (0.7 -> 0.9)
            const p4 = Math.min(1, Math.max(0, (p - 0.7) / 0.2));
            this.crane.rotation.y = THREE.MathUtils.lerp(swingOutAngle, 0, p4);
    
            // Phase 5: Return to idle (0.8 -> 1.0)
            const p5 = Math.min(1, Math.max(0, (p - 0.8) / 0.2));
            this.mesh.position.lerpVectors(this.p_reload_start, this.p_idle, p5);
            this.mesh.quaternion.slerpQuaternions(this.q_reload_start, this.q_idle, p5);
        }
        
        updateInspectAnimation(p) {
            const p1_end = 0.2, p2_end = 0.7, p3_end = 1.0;
            
            if (p < p1_end) { // Move to center
                const progress = p / p1_end;
                this.mesh.position.lerpVectors(this.p_idle, this.p_inspect_center, progress);
                this.mesh.quaternion.slerpQuaternions(this.q_idle, this.q_inspect_start, progress);
            } else if (p < p2_end) { // Roll
                const progress = (p - p1_end) / (p2_end - p1_end);
                this.mesh.quaternion.slerpQuaternions(this.q_inspect_start, this.q_inspect_roll, progress);
                this.cylinder.rotation.y += 0.05 * (1.0 - progress);
            } else { // Return to idle
                const progress = (p - p2_end) / (p3_end - p2_end);
                this.mesh.position.lerpVectors(this.p_inspect_center, this.p_idle, progress);
                this.mesh.quaternion.slerpQuaternions(this.q_inspect_roll, this.q_idle, progress);
            }
        }
    }
--------------------------------------------------
=== END OF FILE: src/game/weapons/Revolver.js ===


=== FILE: src/game/weapons/Weapon.js ===
--------------------------------------------------
/**
 * Base class for all weapons. Handles shared logic like cooldowns.
 */
export class Weapon {
    constructor(wielder, { name, damage, cooldown }) {
        this.wielder = wielder; // Can be null initially
        this.name = name || 'Unnamed Weapon';
        this.damage = damage || 10;
        this.cooldown = cooldown || 0.5;
        this.cooldownTimer = this.cooldown;
        this.mesh = null; // To be created by subclasses
    }

    canAttack() {
        return this.cooldownTimer >= this.cooldown;
    }

    attack() {
        throw new Error("Weapon.attack() must be implemented by subclasses.");
    }

    inspect() {
        // Base implementation does nothing. Can be overridden by subclasses.
    }

    triggerCooldown() {
        this.cooldownTimer = 0;
    }

    update(deltaTime) {
        if (this.cooldownTimer < this.cooldown) {
            this.cooldownTimer += deltaTime;
        }
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/Weapon.js ===


=== FILE: src/game/weapons/WeaponFactory.js ===
--------------------------------------------------
import { Katana } from './Katana.js';
import { Revolver } from './Revolver.js';

const WeaponMap = {
    'WEAPON_001': Katana,
    'WEAPON_REVOLVER': Revolver,
};

/**
 * A factory for creating weapon instances from their IDs.
 */
export class WeaponFactory {
    /**
     * Creates a weapon instance for a given weapon ID.
     * @param {string} weaponId - The ID of the weapon (e.g., 'WEAPON_001').
     * @returns {import('./Weapon.js').Weapon | null} An instance of the weapon, or null if the ID is not found.
     */
    static create(weaponId) {
        const WeaponClass = WeaponMap[weaponId];

        if (WeaponClass) {
            return new WeaponClass();
        }

        console.warn(`WeaponFactory: No class found for weapon ID: ${weaponId}`);
        return null;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/weapons/WeaponFactory.js ===


=== FILE: src/game/world/LevelManager.js ===
--------------------------------------------------

import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { EnemyPrefab } from '../prefabs/EnemyPrefab.js';
import { COLLISION_GROUPS } from '../../shared/CollisionGroups.js';

export class LevelManager {
    constructor(world) {
        this.world = world;
        this.scene = world.scene;
    }

    build(levelData) {
        this.world.levelName = levelData.name || 'Unnamed Level';
        this.world.spawnPoint.copy(levelData.spawnPoint);
        this.world.deathSpawnPoint.copy(levelData.deathSpawnPoint || levelData.spawnPoint);

        const sceneSetupResult = this._setupScene(levelData.settings);
        
        (levelData.objects || []).map(d => this.createObject(d)).forEach(e => this.world.add(e));
        (levelData.enemies || []).map(d => this.createEnemy(d)).forEach(e => this.world.add(e));
        (levelData.triggers || []).map(d => this.createTrigger(d, 'Trigger')).forEach(e => this.world.add(e));
        (levelData.deathTriggers || []).map(d => this.createTrigger(d, 'DeathTrigger')).forEach(e => this.world.add(e));

        if (this.world.initialEnemyCount !== undefined) {
            this.world.initialEnemyCount = this.world.getEnemies().length;
            this.world.enemiesKilled = 0;
        }

        return sceneSetupResult;
    }

    _setupScene(settings) {
        this.scene.background = new THREE.Color(parseInt(settings.backgroundColor, 16));
        this.scene.fog = new THREE.Fog(parseInt(settings.fogColor, 16), settings.fogNear, settings.fogFar);
        
        const existingLights = this.scene.children.filter(c => c.isLight);
        existingLights.forEach(l => {
            if(l.target) this.scene.remove(l.target);
            this.scene.remove(l);
        });

        const ambientLight = new THREE.AmbientLight(parseInt(settings.ambientLight.color, 16), settings.ambientLight.intensity);
        this.scene.add(ambientLight);

        (settings.directionalLights || []).forEach(lightData => {
            const light = this.createDirectionalLight(lightData);
            this.scene.add(light, light.target);
        });

        return { ambientLight };
    }
    
    createDirectionalLight(lightData) {
        const light = new THREE.DirectionalLight(parseInt(lightData.color, 16), lightData.intensity);
        light.position.set(lightData.position.x, lightData.position.y, lightData.position.z);
        if (lightData.targetPosition) light.target.position.set(lightData.targetPosition.x, lightData.targetPosition.y, lightData.targetPosition.z);
        light.castShadow = true;
        light.userData.definition = lightData;
        return light;
    }

    createObject(objData) {
        let mesh, body, shape;
        const mat = new THREE.MeshStandardMaterial({ color: parseInt(objData.material?.color, 16) || 0xcccccc, roughness: objData.material?.roughness ?? 0.8 });
        const size = (objData.size || [1,1,1]).map(s => Math.abs(s) || 0.1);

        if (objData.type === 'Plane') {
            mesh = new THREE.Mesh(new THREE.PlaneGeometry(size[0], size[1]), mat);
            shape = new CANNON.Plane();
        } else {
            mesh = new THREE.Mesh(new THREE.BoxGeometry(...size), mat);
            shape = new CANNON.Box(new CANNON.Vec3(size[0] / 2, size[1] / 2, size[2] / 2));
        }
        
        body = new CANNON.Body({ mass: objData.physics?.mass ?? 0, shape, type: (objData.physics?.mass ?? 0) > 0 ? CANNON.Body.DYNAMIC : CANNON.Body.STATIC, collisionFilterGroup: COLLISION_GROUPS.WORLD });
        
        mesh.position.set(objData.position.x, objData.position.y, objData.position.z);
        if (objData.rotation) mesh.rotation.set(THREE.MathUtils.degToRad(objData.rotation.x || 0), THREE.MathUtils.degToRad(objData.rotation.y || 0), THREE.MathUtils.degToRad(objData.rotation.z || 0));
        
        body.position.copy(mesh.position);
        body.quaternion.copy(mesh.quaternion);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        const entity = { type: 'Object', mesh, body, definition: objData };
        const link = { type: 'Object', entity };
        entity.userData = { gameEntity: link };
        mesh.userData.gameEntity = link;
        if (!body.userData) body.userData = {};
        body.userData.entity = entity;
        
        return entity;
    }

    createEnemy(enemyData) {
        return EnemyPrefab.create(this.world, enemyData);
    }

    createTrigger(triggerData, type) {
        const isDeathTrigger = type === 'DeathTrigger';
        const color = isDeathTrigger ? 0xff0000 : parseInt(triggerData.color || "0x00ff00", 16);
        const material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.35, wireframe: true, depthWrite: false });
        
        const size = (triggerData.size || [1,1,1]).map(s => Math.abs(s) || 0.1);
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(...size), material);
        mesh.position.set(triggerData.position.x, triggerData.position.y, triggerData.position.z);

        const shape = new CANNON.Box(new CANNON.Vec3(...size.map(s => s / 2)));
        const body = new CANNON.Body({ type: CANNON.Body.STATIC, isTrigger: true, shape, position: new CANNON.Vec3(triggerData.position.x, triggerData.position.y, triggerData.position.z), collisionFilterGroup: COLLISION_GROUPS.TRIGGER, collisionFilterMask: COLLISION_GROUPS.PLAYER | COLLISION_GROUPS.ENEMY });
        
        if (triggerData.rotation) {
            mesh.rotation.set(THREE.MathUtils.degToRad(triggerData.rotation.x || 0), THREE.MathUtils.degToRad(triggerData.rotation.y || 0), THREE.MathUtils.degToRad(triggerData.rotation.z || 0));
            body.quaternion.copy(mesh.quaternion);
        }
        
        const entityType = isDeathTrigger ? 'DeathTrigger' : 'Trigger';
        const entity = { type: entityType, mesh, body, definition: triggerData, message: triggerData.message, duration: triggerData.duration, hasFired: false };
        entity.userData = { gameEntity: { type: entityType, entity } };
        mesh.userData.gameEntity = entity.userData.gameEntity;
        if (!body.userData) body.userData = {};
        body.userData.entity = entity;
        
        return entity;
    }
}
--------------------------------------------------
=== END OF FILE: src/game/world/LevelManager.js ===


=== FILE: src/game/world/World.js ===
--------------------------------------------------
  import * as THREE from 'three';
    import { EventEmitter } from '../../shared/EventEmitter.js';
    import { LevelManager } from './LevelManager.js';
    import { PlayerPrefab } from '../prefabs/PlayerPrefab.js';
    import { MovementSystem } from '../systems/MovementSystem.js';
    import { AISystem } from '../systems/AISystem.js';
    import { AbilitySystem } from '../systems/AbilitySystem.js';
    import { WeaponSystem } from '../systems/WeaponSystem.js';
    import { TargetingSystem } from '../systems/TargetingSystem.js';
    import { DeathSystem } from '../systems/DeathSystem.js';
    import { TriggerSystem } from '../systems/TriggerSystem.js';
    import { OutOfBoundsSystem } from '../systems/OutOfBoundsSystem.js';
    import { StatusEffectSystem } from '../systems/StatusEffectSystem.js';
    import { Fireball } from '../abilities/Fireball.js';
    import { EnemyProjectile } from '../abilities/EnemyProjectile.js';
    import { FireflyProjectile } from '../abilities/FireflyProjectile.js';
    
    /**
     * Represents a single level instance, containing all entities, systems, and game state.
     */
    export class World {
        constructor(core, game) {
            this.emitter = new EventEmitter(); // Composition
            this.core = core;
            this.game = game;
            this.scene = core.renderer.scene;
            this.physics = core.physics;
            
            this.levelName = '';
            this.spawnPoint = new THREE.Vector3();
            this.deathSpawnPoint = new THREE.Vector3();
            this.player = null;
            this.entities = new Set();
            this._entitiesByType = new Map();
            this.initialEnemyCount = 0;
            this.enemiesKilled = 0;
    
            this.levelManager = new LevelManager(this);
            this.systems = [
                new MovementSystem(),
                new AISystem(),
                new AbilitySystem(),
                new WeaponSystem(),
                new TargetingSystem(),
                new DeathSystem(),
                new OutOfBoundsSystem(),
                new StatusEffectSystem(),
            ];
            this.triggerSystem = new TriggerSystem(this);
            
            this.on('enemyDied', () => this.onEnemyDied());
        }
    
        // --- Event Emitter Delegation ---
        on(eventName, listener) { this.emitter.on(eventName, listener); }
        emit(eventName, data) { this.emitter.emit(eventName, data); }
        off(eventName, listener) { this.emitter.off(eventName, listener); }
        removeAllListeners() { this.emitter.removeAllListeners(); }
    
        async loadLevel(config) {
            let levelData;
            if (config.url) {
                const response = await fetch(config.url);
                if (!response.ok) throw new Error(`Failed to load level: ${response.statusText}`);
                levelData = await response.json();
            } else if (config.data) {
                levelData = config.data;
            } else {
                throw new Error('Level configuration must provide a URL or data.');
            }
    
            this.levelManager.build(levelData);
    
            this.player = PlayerPrefab.create(
                this,
                this.core.renderer.camera,
                this.game.viewModelScene,
                config.loadout
            );
            this.add(this.player);
        }
        
        onEnemyDied() {
            this.enemiesKilled++;
            if (this.initialEnemyCount > 0 && this.enemiesKilled >= this.initialEnemyCount) {
                this.emit('levelCompleted');
            }
        }
    
        add(entity) {
            if (!entity || this.entities.has(entity)) return;
            this.entities.add(entity);
            if (entity.type) {
                if (!this._entitiesByType.has(entity.type)) {
                    this._entitiesByType.set(entity.type, new Set());
                }
                this._entitiesByType.get(entity.type).add(entity);
            }
            
            if (entity.mesh) this.scene.add(entity.mesh);
            const body = entity.physics?.body || entity.body;
            if (body) this.physics.addBody(body);
    
            this.emit('entityAdded', { entity });
    
            if (entity.type === 'enemy') this.emit('enemySpawned', { enemy: entity });
        }
    
        remove(entity) {
            if (!entity || !this.entities.has(entity)) return;
            this.emit('entityRemoved', { entity });
            if (entity.dispose) entity.dispose();
            else {
                if (entity.mesh) {
                    this.scene.remove(entity.mesh);
                    entity.mesh.geometry?.dispose();
                    if (Array.isArray(entity.mesh.material)) entity.mesh.material.forEach(m => m.dispose());
                    else entity.mesh.material?.dispose();
                }
                const body = entity.physics?.body || entity.body;
                if (body) this.physics.queueForRemoval(body);
            }
            
            this.entities.delete(entity);
            if (entity.type && this._entitiesByType.has(entity.type)) {
                this._entitiesByType.get(entity.type).delete(entity);
            }
        }
    
        getEntities() { return Array.from(this.entities); }
        getEnemies() { return Array.from(this._entitiesByType.get('enemy') || []); }
        getLevelObjects() { return Array.from(this._entitiesByType.get('Object') || []); }
        getTriggers() { return Array.from(this._entitiesByType.get('Trigger') || []); }
        getDeathTriggers() { return Array.from(this._entitiesByType.get('DeathTrigger') || []); }
    
        resetPlayer() {
            if (this.player) {
                this.player.reset(this.deathSpawnPoint);
                this.emit('playerRespawned');
            }
        }
    
        createFireball(data) { new Fireball({ world: this, ...data }); }
        createEnemyProjectile(data) { new EnemyProjectile({ world: this, ...data }); }
        createFireflyProjectile(data) { new FireflyProjectile({ world: this, ...data }); }
    
        update(deltaTime) {
            for (const system of this.systems) system.update(this, deltaTime);
            for (const entity of this.entities) if (entity.update) entity.update(deltaTime);
        }
        
        dispose() {
            this.removeAllListeners();
            this.triggerSystem.dispose();
            [...this.entities].forEach(entity => this.remove(entity));
            this.scene.children.slice().forEach(child => {
                if (child.type !== 'PerspectiveCamera') this.scene.remove(child);
            });
            this.physics.world.bodies.forEach(body => this.physics.queueForRemoval(body));
            this.physics._removeQueuedBodies();
            this.systems = [];
        }
    }
--------------------------------------------------
=== END OF FILE: src/game/world/World.js ===


=== FILE: src/shared/CollisionGroups.js ===
--------------------------------------------------
// Defines distinct bit Categ for physics objects.
// This allows fine-grained control over which objects can collide with each other.
// Each category should be a power of 2.

export const COLLISION_GROUPS = {
    WORLD: 1,      // Static level geometry
    PLAYER: 2,     // Player characters
    PROJECTILE: 4, // Player and enemy projectiles
    ENEMY: 8,      // AI-controlled characters
    TRIGGER: 16    // Non-colliding trigger volumes
};
--------------------------------------------------
=== END OF FILE: src/shared/CollisionGroups.js ===


=== FILE: src/shared/config.js ===
--------------------------------------------------
// src/shared/config.js
// This file centralizes all game balance and configuration constants.
// Modifying these values will directly impact gameplay without needing to change core logic.

export const GAME_CONFIG = {
    // General world settings
    DEATH_Y: -100, // Y-coordinate below which entities are considered out of bounds

    // General physics
    GRAVITY: 9.82,

    // Player movement parameters
    PLAYER: {
        MAX_HEALTH: 1000,
        MAX_ENERGY: 1000,
        ENERGY_REGEN_RATE: 25, // points per second
        ENERGY_REGEN_DELAY: 5.0, // seconds after last ability use
        
        FOV: 75, // Default field of view
        SPEED: 8.0, // meters per second
        JUMP_HEIGHT: 8.0, // initial vertical velocity on jump
        MAX_JUMPS: 2,
        
        DASH_SPEED_MULTIPLIER: 4.0,
        DASH_DURATION: 0.2, // seconds
        DASH_COOLDOWN: 2.0, // seconds
        
        DOUBLE_JUMP_COOLDOWN: 1.5, // seconds
        DOUBLE_TAP_WINDOW: 300, // milliseconds
        
        GROUND_SLAM_VELOCITY: -25.0, // downward velocity on slam
        
        RADIUS: 0.8, // for physics body
        MASS: 70, // kg
    },

    // Weapon parameters
    KATANA: {
        DAMAGE: 250,
        COOLDOWN: 0.6, // seconds
        RANGE: 4.0, // meters
        SLAM_DAMAGE_MULTIPLIER: 2.0,
    },
    
    // Ability-specific parameters
    WAVE_POWER: {
        WIDTH: 8.0, // meters
        LENGTH: 25.0, // meters
        IMPULSE_FORWARD: 3000, // in kg*m/s
        IMPULSE_UPWARD: 1000, // in kg*m/s
        DAMAGE: 200,
        KNOCKBACK_DURATION: 1.0, // seconds
    },

    // Enemy base parameters
    ENEMY: {
        DUMMY: {
            MAX_HEALTH: 500,
            SPEED: 7.0,
            MASS: 80,
            RADIUS: 0.8,
            PROJECTILE_DAMAGE: 100,
            PROJECTILE_SPEED: 40,
            ATTACK_COOLDOWN: 1.5,
        }
    },
    
    // Targeting system parameters
    TARGETING: {
        MAX_RANGE: 100, // meters
        MAX_ANGLE_RAD: Math.atan(0.26), // Approx. 15 degrees tan(15 deg)
    },

    // HUD and UI
    UI: {
        RESPAWN_COOLDOWN: 5.0,
    }
};
--------------------------------------------------
=== END OF FILE: src/shared/config.js ===


=== FILE: src/shared/EventEmitter.js ===
--------------------------------------------------
/**
 * A simple event emitter class for handling custom events.
 * This allows for decoupled communication between different parts of the application.
 */
export class EventEmitter {
    constructor() {
        this.events = {};
    }

    /**
     * Registers a listener for a specific event.
     * @param {string} eventName - The name of the event.
     * @param {Function} listener - The callback function to execute.
     */
    on(eventName, listener) {
        if (!this.events[eventName]) {
            this.events[eventName] = [];
        }
        this.events[eventName].push(listener);
    }

    /**
     * Emits an event, calling all registered listeners with the provided data.
     * @param {string} eventName - The name of the event to emit.
     * @param {*} [data] - Optional data to pass to the listeners.
     */
    emit(eventName, data) {
        const listeners = this.events[eventName];
        if (listeners) {
            listeners.forEach(listener => listener(data));
        }
    }

    /**
     * Removes a specific listener for an event.
     * @param {string} eventName - The name of the event.
     * @param {Function} listenerToRemove - The listener function to remove.
     */
    off(eventName, listenerToRemove) {
        const listeners = this.events[eventName];
        if (listeners) {
            this.events[eventName] = listeners.filter(listener => listener !== listenerToRemove);
        }
    }

    /**
     * Removes all listeners for all events.
     */
    removeAllListeners() {
        this.events = {};
    }
}
--------------------------------------------------
=== END OF FILE: src/shared/EventEmitter.js ===


=== FILE: src/shared/util.js ===
--------------------------------------------------
import * as THREE from 'three';

/**
 * A collection of common utility functions.
 */

export const Util = {
    /**
     * Calculates the launch velocity for a projectile to hit a target, considering gravity.
     * @param {THREE.Vector3} startPos - The starting position of the projectile.
     * @param {THREE.Vector3} targetPos - The target position.
     * @param {number} projectileSpeed - The initial speed of the projectile.
     * @param {number} gravity - The magnitude of gravity (should be positive).
     * @returns {THREE.Vector3|null} The initial velocity vector, or null if the target is unreachable.
     */
    calculateBallisticLaunchVelocity(startPos, targetPos, projectileSpeed, gravity) {
        const delta = new THREE.Vector3().subVectors(targetPos, startPos);
        const deltaXZ = new THREE.Vector2(delta.x, delta.z);
        const distXZ = deltaXZ.length();

        const v = projectileSpeed;
        const g = gravity;
        const y = delta.y;
        const x = distXZ;

        const discriminant = v**4 - g * (g * x**2 + 2 * y * v**2);
        
        if (discriminant < 0) {
            // Target is out of range
            return null;
        }

        // We choose the lower angle for a more direct shot. 
        // Use + for a higher, arcing shot.
        const angle = Math.atan2(v**2 - Math.sqrt(discriminant), g * x);
        
        const Vy = v * Math.sin(angle);
        const Vxz = v * Math.cos(angle);
        
        const dirXZ = deltaXZ.normalize();
        
        return new THREE.Vector3(dirXZ.x * Vxz, Vy, dirXZ.y * Vxz);
    }
};
--------------------------------------------------
=== END OF FILE: src/shared/util.js ===


================================================================================
Snapshot Complete.
